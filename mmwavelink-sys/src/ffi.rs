/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 32;
pub const __WORDSIZE32_SIZE_ULONG: u32 = 0;
pub const __WORDSIZE32_PTRDIFF_LONG: u32 = 0;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 0;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const RL_NULL: u32 = 0;
pub const RL_INVALID: i32 = -1;
pub const RL_ZERO: u32 = 0;
pub const RL_ONE: u32 = 1;
pub const RL_TWO: u32 = 2;
pub const RL_THREE: u32 = 3;
pub const RL_FOUR: u32 = 4;
pub const RL_FIVE: u32 = 5;
pub const RL_SIX: u32 = 6;
pub const RL_SEVEN: u32 = 7;
pub const RL_EIGHT: u32 = 8;
pub const RL_NINE: u32 = 9;
pub const RL_TEN: u32 = 10;
pub const RL_ELEVEN: u32 = 11;
pub const RL_TWELVE: u32 = 12;
pub const RL_THIRTEEN: u32 = 13;
pub const RL_FOURTEEN: u32 = 14;
pub const RL_FIFTEEN: u32 = 15;
pub const RL_SIXTEEN: u32 = 16;
pub const RL_SEVENTEEN: u32 = 17;
pub const RL_EIGHTEEN: u32 = 18;
pub const RL_NINETEEN: u32 = 19;
pub const RL_TWENTY: u32 = 20;
pub const RL_TWENTY_ONE: u32 = 21;
pub const RL_TWENTY_TWO: u32 = 22;
pub const RL_TWENTY_THREE: u32 = 23;
pub const RL_TWENTY_FOUR: u32 = 24;
pub const RL_TWENTY_FIVE: u32 = 25;
pub const RL_TWENTY_SIX: u32 = 26;
pub const RL_TWENTY_SEVEN: u32 = 27;
pub const RL_TWENTY_EIGHT: u32 = 28;
pub const RL_TWENTY_NINE: u32 = 29;
pub const RL_THIRTY: u32 = 30;
pub const RL_THIRTY_ONE: u32 = 31;
pub const RL_THIRTY_TWO: u32 = 32;
pub const RL_OSI_WAIT_FOREVER: u32 = 65535;
pub const RL_OSI_WAIT_SECOND: u32 = 1000;
pub const RL_OSI_NO_WAIT: u32 = 0;
pub const RL_MMWAVELINK_VERSION: &'static [u8; 16usize] = b"1.2.6.6.27.8.20\0";
pub const RL_MMWAVELINK_VERSION_MAJOR: u32 = 1;
pub const RL_MMWAVELINK_VERSION_MINOR: u32 = 2;
pub const RL_MMWAVELINK_VERSION_BUILD: u32 = 6;
pub const RL_MMWAVELINK_VERSION_DEBUG: u32 = 6;
pub const RL_MMWAVELINK_VERSION_DAY: u32 = 27;
pub const RL_MMWAVELINK_VERSION_MONTH: u32 = 8;
pub const RL_MMWAVELINK_VERSION_YEAR: u32 = 20;
pub const RL_RET_CODE_PROTOCOL_ERROR: i32 = -1;
pub const RL_RET_CODE_INVALID_INPUT: i32 = -2;
pub const RL_RET_CODE_SELF_ERROR: i32 = -3;
pub const RL_RET_CODE_RADAR_IF_ERROR: i32 = -4;
pub const RL_RET_CODE_MALLOC_ERROR: i32 = -5;
pub const RL_RET_CODE_CRC_FAILED: i32 = -6;
pub const RL_RET_CODE_CHKSUM_FAILED: i32 = -7;
pub const RL_RET_CODE_RESP_TIMEOUT: i32 = -8;
pub const RL_RET_CODE_FATAL_ERROR: i32 = -9;
pub const RL_RET_CODE_RADAR_OSIF_ERROR: i32 = -10;
pub const RL_RET_CODE_INVALID_STATE_ERROR: i32 = -11;
pub const RL_RET_CODE_API_NOT_SUPPORTED: i32 = -12;
pub const RL_RET_CODE_MSGID_MISMATCHED: i32 = -13;
pub const RL_RET_CODE_NULL_PTR: i32 = -14;
pub const RL_RET_CODE_INTERFACE_CB_NULL: i32 = -15;
pub const RL_RET_CODE_NACK_ERROR: i32 = -16;
pub const RL_RET_CODE_HOSTIRQ_TIMEOUT: i32 = -17;
pub const RL_RET_CODE_RX_SEQ_NUM_NOT_MATCH: i32 = -18;
pub const RL_RET_CODE_INVLD_OPCODE: u32 = 1;
pub const RL_RET_CODE_INVLD_NUM_SB: u32 = 2;
pub const RL_RET_CODE_INVLD_SB_ID: u32 = 3;
pub const RL_RET_CODE_INVLD_SB_LEN: u32 = 4;
pub const RL_RET_CODE_SB_INVL_DATA: u32 = 5;
pub const RL_RET_CODE_SB_PROCESS_ERR: u32 = 6;
pub const RL_RET_CODE_MISMATCH_FILE_CRC: u32 = 7;
pub const RL_RET_CODE_MISMATCH_FILE_TYPE: u32 = 8;
pub const RL_RET_CODE_FRAME_ALREADY_STARTED: u32 = 20;
pub const RL_RET_CODE_FRAME_ALREADY_ENDED: u32 = 21;
pub const RL_RET_CODE_FRAME_CFG_NOT_RECVD: u32 = 22;
pub const RL_RET_CODE_FRAME_TRIG_INVL_IN: u32 = 23;
pub const RL_RET_CODE_CH_CFG_RX_INVAL_IN: u32 = 24;
pub const RL_RET_CODE_CH_CFG_TX_INVAL_IN: u32 = 25;
pub const RL_RET_CODE_CH_CFG_CASC_INVAL_IN: u32 = 26;
pub const RL_RET_CODE_ADC_BITS_INVAL_IN: u32 = 27;
pub const RL_RET_CODE_ADC_FORM_INVAL_IN: u32 = 28;
pub const RL_RET_CODE_LP_ADC_INVAL_IN: u32 = 29;
pub const RL_RET_CODE_DYN_PS_INVAL_IN: u32 = 30;
pub const RL_RET_CODE_HSI_DIV_INVAL_IN: u32 = 31;
pub const RL_RET_CODE_RESERVED0: u32 = 32;
pub const RL_RET_CODE_HSI_DIV_INVAL_1IN: u32 = 33;
pub const RL_RET_CODE_HSI_DIV_INVAL_2IN: u32 = 34;
pub const RL_RET_CODE_PF_IND_INVAL_IN: u32 = 35;
pub const RL_RET_CODE_PF_START_FREQ_INVAL_IN: u32 = 36;
pub const RL_RET_CODE_PF_IDLE_TIME_INVAL_IN: u32 = 37;
pub const RL_RET_CODE_PF_IDLE_TIME_1INVAL_IN: u32 = 38;
pub const RL_RET_CODE_PF_ADC_START_INVAL_IN: u32 = 39;
pub const RL_RET_CODE_PF_RAMP_END_INVAL_IN: u32 = 40;
pub const RL_RET_CODE_PF_RAMP_END_1INVAL_IN: u32 = 41;
pub const RL_RET_CODE_PF_TX0_INVAL_IN: u32 = 42;
pub const RL_RET_CODE_PF_TX1_INVAL_IN: u32 = 43;
pub const RL_RET_CODE_PF_TX2_INVAL_IN: u32 = 44;
pub const RL_RET_CODE_RESERVED1: u32 = 45;
pub const RL_RET_CODE_PF_FREQ_SLOPE_1INVAL_IN: u32 = 46;
pub const RL_RET_CODE_PF_TX_START_INVAL_IN: u32 = 47;
pub const RL_RET_CODE_PF_NUM_ADC_SMAP_INVAL_IN: u32 = 48;
pub const RL_RET_CODE_PF_DFE_SAMP_RATE_INVAL_IN: u32 = 49;
pub const RL_RET_CODE_PF_HPF1_CF_INVAL_IN: u32 = 50;
pub const RL_RET_CODE_PF_HPF2_CF_INVAL_IN: u32 = 51;
pub const RL_RET_CODE_PF_RX_GAIN_INVAL_IN: u32 = 52;
pub const RL_RET_CODE_RESERVED2: u32 = 53;
pub const RL_RET_CODE_RESERVED3: u32 = 54;
pub const RL_RET_CODE_RESERVED4: u32 = 55;
pub const RL_RET_CODE_RESERVED5: u32 = 56;
pub const RL_RET_CODE_RESERVED6: u32 = 57;
pub const RL_RET_CODE_RESERVED7: u32 = 58;
pub const RL_RET_CODE_CHIRP_START_INVAL_IN: u32 = 59;
pub const RL_RET_CODE_CHIRP_END_INVAL_IN: u32 = 60;
pub const RL_RET_CODE_CHIRP_END_1INVAL_IN: u32 = 61;
pub const RL_RET_CODE_CHIRP_PF_IND_INVAL_IN: u32 = 62;
pub const RL_RET_CODE_CHIRP_PF_IND_1INVAL_IN: u32 = 63;
pub const RL_RET_CODE_CHIRP_START_FREQ_INVAL_IN: u32 = 64;
pub const RL_RET_CODE_CHIRP_SLOPE_INVAL_IN: u32 = 65;
pub const RL_RET_CODE_CHIRP_SLOPE_1INVAL_IN: u32 = 66;
pub const RL_RET_CODE_CHIRP_IDLE_TIME_INVAL_IN: u32 = 67;
pub const RL_RET_CODE_CHIRP_ADC_START_INVAL_IN: u32 = 68;
pub const RL_RET_CODE_CHIRP_ADC_START_1INVAL_IN: u32 = 69;
pub const RL_RET_CODE_CHIRP_TX_ENA_INVAL_IN: u32 = 70;
pub const RL_RET_CODE_CHIRP_TX_ENA_1INVAL_IN: u32 = 71;
pub const RL_RET_CODE_FRAME_CHIRP_STR_INVAL_IN: u32 = 72;
pub const RL_RET_CODE_FRAME_CHIRP_END_INVAL_IN: u32 = 73;
pub const RL_RET_CODE_FRAME_CHIRP_END_1INVAL_IN: u32 = 74;
pub const RL_RET_CODE_FRAME_CHIRP_END_2INVAL_IN: u32 = 75;
pub const RL_RET_CODE_FRAME_CHIRP_PF_INVAL_IN: u32 = 76;
pub const RL_RET_CODE_FRAME_CHIRP_LOOPS_INVAL_IN: u32 = 77;
pub const RL_RET_CODE_RESERVED8: u32 = 78;
pub const RL_RET_CODE_FRAME_PERIOD_INVAL_IN: u32 = 79;
pub const RL_RET_CODE_FRAME_PERIOD_1INVAL_IN: u32 = 80;
pub const RL_RET_CODE_FRAME_TRIG_SEL_INVAL_IN: u32 = 81;
pub const RL_RET_CODE_FRAME_TRIG_DELAY_INVAL_IN: u32 = 82;
pub const RL_RET_CODE_FRAME_IS_ONGOING: u32 = 83;
pub const RL_RET_CODE_AFRAME_NUM_SUBF_INVAL_IN: u32 = 84;
pub const RL_RET_CODE_AFRAME_FORCE_PF_INVAL_IN: u32 = 85;
pub const RL_RET_CODE_AFRAME_PF_IND_INVAL_IN: u32 = 86;
pub const RL_RET_CODE_AFRAME_PF_IND_1INVAL_IN: u32 = 87;
pub const RL_RET_CODE_AFRAME_CHIRP_STR_INVAL_IN: u32 = 88;
pub const RL_RET_CODE_AFRAME_NCHIRP_INVAL_IN: u32 = 89;
pub const RL_RET_CODE_AFRAME_NCHIRP_1INVAL_IN: u32 = 90;
pub const RL_RET_CODE_AFRAME_CHIRP_PF_INVAL_IN: u32 = 91;
pub const RL_RET_CODE_AFRAME_CHIRP_LOOPS_INVAL_IN: u32 = 92;
pub const RL_RET_CODE_AFRAME_BURST_PERIOD_INVAL_IN: u32 = 93;
pub const RL_RET_CODE_AFRAME_BURST_PER_1INVAL_IN: u32 = 94;
pub const RL_RET_CODE_AFRAME_BURST_STIND_INVAL_IN: u32 = 95;
pub const RL_RET_CODE_AFRAME_BURST_SIND_1INVAL_IN: u32 = 96;
pub const RL_RET_CODE_AFRAME_NUM_BURSTS_INVAL_IN: u32 = 97;
pub const RL_RET_CODE_AFRAME_BURST_LOOPS_INVAL_IN: u32 = 98;
pub const RL_RET_CODE_AFRAME_SF_PERIOD_INVAL_IN: u32 = 99;
pub const RL_RET_CODE_AFRAME_SF_PERIOD_1INVAL_IN: u32 = 100;
pub const RL_RET_CODE_RESERVED9: u32 = 101;
pub const RL_RET_CODE_AFRAME_TRIG_SEL_INVAL_IN: u32 = 102;
pub const RL_RET_CODE_AFRAME_TRIG_DELAY_INVAL_IN: u32 = 103;
pub const RL_RET_CODE_AFRAME_IS_ONGOING: u32 = 104;
pub const RL_RET_CODE_TS_POS_VECY_INVAL_IN: u32 = 105;
pub const RL_RET_CODE_RESERVED10: u32 = 106;
pub const RL_RET_CODE_TS_VEL_VECXYZ_INVAL_IN: u32 = 107;
pub const RL_RET_CODE_TS_SIG_LEVEL_INVAL_IN: u32 = 108;
pub const RL_RET_CODE_TS_RX_ANT_POS_INVAL_IN: u32 = 109;
pub const RL_RET_CODE_RESERVED11: u32 = 110;
pub const RL_RET_CODE_PROG_FILT_STARTINDX_INVALID: u32 = 111;
pub const RL_RET_CODE_PROG_FILT_PROFILE_INVALID: u32 = 112;
pub const RL_RET_CODE_PROG_FILT_UNSUPPORTED_DEV: u32 = 113;
pub const RL_RET_CODE_PERCHIRPPHSHIFT_UNSUPPORTED_DEV: u32 = 114;
pub const RL_RET_CODE_PERCHIRPPHSHIFT_STIND: u32 = 115;
pub const RL_RET_CODE_PERCHIRPPHSHIFT_ENIND: u32 = 116;
pub const RL_RET_CODE_PERCHIRPPHSHIFT_WRONG_STIND: u32 = 117;
pub const RL_RET_CODE_RF_INIT_NOT_DONE: u32 = 118;
pub const RL_RET_CODE_FREQ_LIMIT_OUT_RANGE: u32 = 119;
pub const RL_RET_CODE_CAL_MON_TIME_INVALID: u32 = 120;
pub const RL_RET_CODE_RUN_CAL_PERIOD_INVALID: u32 = 121;
pub const RL_RET_CODE_CONT_STREAM_MODE_EN: u32 = 122;
pub const RL_RET_CODE_RX_GAIN_BOOT_CAL_NOT_DONE: u32 = 123;
pub const RL_RET_CODE_LO_DIST_BOOT_CAL_NOT_DONE: u32 = 124;
pub const RL_RET_CODE_TX_PWR_BOOT_CAL_NOT_DONE: u32 = 125;
pub const RL_RET_CODE_PROG_FILTR_UNSUPPORTED_DFEMODE: u32 = 126;
pub const RL_RET_CODE_ADC_BITS_FULL_SCALE_REDUC_INVAL: u32 = 127;
pub const RL_RET_CODE_CAL_MON_NUM_CASC_DEV_INVALID: u32 = 128;
pub const RL_RET_CODE_RF_FREQBAND_INVALID: u32 = 130;
pub const RL_RET_CODE_INVAL_LOOPBACK_TYPE: u32 = 132;
pub const RL_RET_CODE_INVAL_LOOPBACK_BURST_IND: u32 = 133;
pub const RL_RET_CODE_INVAL_LOOPBACK_CONFIG: u32 = 134;
pub const RL_RET_CODE_DYN_CHIRP_INVAL_SEG: u32 = 135;
pub const RL_RET_CODE_DYN_PERCHIRP_PHSHFT_INVA_SEG: u32 = 136;
pub const RL_RET_CODE_INVALID_CAL_CHUNK_ID: u32 = 137;
pub const RL_RET_CODE_INVALID_CAL_CHUNK_DATA: u32 = 138;
pub const RL_RET_CODE_RX02_RF_TURN_OFF_TIME_INVALID: u32 = 139;
pub const RL_RET_CODE_RX13_RF_TURN_OFF_TIME_INVALID: u32 = 140;
pub const RL_RET_CODE_RX02_BB_TURN_OFF_TIME_INVALID: u32 = 141;
pub const RL_RET_CODE_RX13_BB_TURN_OFF_TIME_INVALID: u32 = 142;
pub const RL_RET_CODE_RX02_RF_PREENABLE_TIME_INVALID: u32 = 143;
pub const RL_RET_CODE_RX13_RF_PREENABLE_TIME_INVALID: u32 = 144;
pub const RL_RET_CODE_RX02_BB_PREENABLE_TIME_INVALID: u32 = 145;
pub const RL_RET_CODE_RX13_BB_PREENABLE_TIME_INVALID: u32 = 146;
pub const RL_RET_CODE_RX02_RF_TURN_ON_TIME_INVALID: u32 = 147;
pub const RL_RET_CODE_RX13_RF_TURN_ON_TIME_INVALID: u32 = 148;
pub const RL_RET_CODE_RX02_BB_TURN_ON_TIME_INVALID: u32 = 149;
pub const RL_RET_CODE_RX13_BB_TURN_ON_TIME_INVALID: u32 = 150;
pub const RL_RET_CODE_RX_LO_TURN_OFF_TIME_INVALID: u32 = 151;
pub const RL_RET_CODE_TX_LO_TURN_OFF_TIME_INVALID: u32 = 152;
pub const RL_RET_CODE_RX_LO_TURN_ON_TIME_INVALID: u32 = 153;
pub const RL_RET_CODE_TX_LO_TURN_ON_TIME_INVALID: u32 = 154;
pub const RL_RET_CODE_SUBFRAME_TRIGGER_INVALID: u32 = 155;
pub const RL_RET_CODE_REGULAR_ADC_MODE_INVALID: u32 = 156;
pub const RL_RET_CODE_CHIRP_ROW_SELECT_INVAL_IN: u32 = 159;
pub const RL_RET_CODE_DEVICE_NOT_ASILB_TYPE: u32 = 250;
pub const RL_RET_CODE_FRAME_ONGOING: u32 = 251;
pub const RL_RET_CODE_INVLD_REPO_MODE: u32 = 252;
pub const RL_RET_CODE_INVLD_PROFILE_ID: u32 = 253;
pub const RL_RET_CODE_INVLD_PROFILE: u32 = 254;
pub const RL_RET_CODE_INVLD_EXTSIG_SETLTIME: u32 = 255;
pub const RL_RET_CODE_INVLD_NO_RX_ENABLED: u32 = 256;
pub const RL_RET_CODE_INVLD_TX0_NOT_ENABLED: u32 = 257;
pub const RL_RET_CODE_INVLD_TX1_NOT_ENABLED: u32 = 258;
pub const RL_RET_CODE_INVLD_TX2_NOT_ENABLED: u32 = 259;
pub const RL_RET_CODE_MON_INVALID_RF_BIT_MASK: u32 = 260;
pub const RL_RET_CODE_RESERVED12: u32 = 261;
pub const RL_RET_CODE_RESERVED13: u32 = 262;
pub const RL_RET_CODE_MON_TX_EN_CHK_FAIL: u32 = 263;
pub const RL_RET_CODE_MON_RX_CH_EN_CHK_FAIL: u32 = 264;
pub const RL_RET_CODE_MON_TX_CH_PS_LB: u32 = 265;
pub const RL_RET_CODE_INVLD_SAT_MON_SEL: u32 = 266;
pub const RL_RET_CODE_INVLD_SAT_MON_PRI_SLICE_DUR: u32 = 267;
pub const RL_RET_CODE_INVLD_SAT_MON_NUM_SLICES: u32 = 268;
pub const RL_RET_CODE_INVLD_SIG_IMG_SLICENUM: u32 = 269;
pub const RL_RET_CODE_INVLD_SIG_IMG_NUMSAMPPERSLICE: u32 = 270;
pub const RL_RET_CODE_INVLD_SYNTH_L1_LIN: u32 = 271;
pub const RL_RET_CODE_INVLD_SYNTH_L2_LIN: u32 = 272;
pub const RL_RET_CODE_INVLD_SYNTH_N_LIN: u32 = 273;
pub const RL_RET_CODE_INVLD_SYNTH_MON_START_TIME: u32 = 274;
pub const RL_RET_CODE_INVLD_SYNTH_MON_LIN_RAM_ADDR: u32 = 275;
pub const RL_RET_CODE_LDO_BYPASSED: u32 = 279;
pub const RL_RET_CODE_INVLD_SIG_IMG_BAND_MONTR: u32 = 280;
pub const RL_RET_CODE_ANALOG_MONITOR_NOT_SUPPORTED: u32 = 281;
pub const RL_RET_CODE_ISSUE_TO_ENABLE_CASCASE_MODE: u32 = 282;
pub const RL_RET_CODE_RX_SAT_MON_NOT_SUPPORTED: u32 = 283;
pub const RL_RET_CODE_CHIRP_FAIL: u32 = 290;
pub const RL_RET_CODE_PD_PWR_LVL: u32 = 291;
pub const RL_RET_CODE_ADC_PWR_LVL: u32 = 292;
pub const RL_RET_CODE_NOISE_FIG_LOW: u32 = 293;
pub const RL_RET_CODE_PD_CDS_ON_FAIL: u32 = 294;
pub const RL_RET_CODE_PGA_GAIN_FAIL: u32 = 295;
pub const RL_RET_CODE_20G_MONITOR_NOT_SUPPORTED: u32 = 296;
pub const RL_RET_CODE_MONITOR_CONFIG_MODE_INVALID: u32 = 297;
pub const RL_RET_CODE_LIVE_NONLIVE_TOGETHER_INVALID: u32 = 298;
pub const RL_RET_CODE_INVLD_MON_START_FREQ: u32 = 319;
pub const RL_RET_CODE_INVLD_STATE_TRANS_CMD: u32 = 325;
pub const RL_RET_CODE_API_NOT_SUPPORTED_DEVICE: u32 = 330;
pub const RL_RET_CODE_RX_CHAN_EN_OOR: u32 = 1001;
pub const RL_RET_CODE_NUM_ADC_BITS_OOR: u32 = 1002;
pub const RL_RET_CODE_ADC_OUT_FMT_OOR: u32 = 1003;
pub const RL_RET_CODE_IQ_SWAP_SEL_OOR: u32 = 1004;
pub const RL_RET_CODE_CHAN_INTERLEAVE_OOR: u32 = 1005;
pub const RL_RET_CODE_DATA_INTF_SEL_OOR: u32 = 1006;
pub const RL_RET_CODE_DATA_FMT_PKT0_INVALID: u32 = 1007;
pub const RL_RET_CODE_DATA_FMT_PKT1_INVALID: u32 = 1008;
pub const RL_RET_CODE_LANE_ENABLE_OOR: u32 = 1009;
pub const RL_RET_CODE_LANE_ENABLE_INVALID: u32 = 1010;
pub const RL_RET_CODE_LANE_CLK_CFG_OOR: u32 = 1011;
pub const RL_RET_CODE_LANE_CLK_CFG_INVALID: u32 = 1012;
pub const RL_RET_CODE_DATA_RATE_OOR: u32 = 1013;
pub const RL_RET_CODE_LANE_FMT_MAP_OOR: u32 = 1014;
pub const RL_RET_CODE_LANE_PARAM_CFG_OOR: u32 = 1015;
pub const RL_RET_CODE_CONT_STREAM_MODE_OOR: u32 = 1016;
pub const RL_RET_CODE_CONT_STREAM_MODE_INVALID: u32 = 1017;
pub const RL_RET_CODE_LANE0_POS_POL_OOR: u32 = 1018;
pub const RL_RET_CODE_LANE1_POS_POL_OOR: u32 = 1019;
pub const RL_RET_CODE_LANE2_POS_POL_OOR: u32 = 1020;
pub const RL_RET_CODE_LANE3_POS_POL_OOR: u32 = 1021;
pub const RL_RET_CODE_CLOCK_POS_OOR: u32 = 1022;
pub const RL_RET_CODE_HALF_WORDS_PER_CHIRP_OOR: u32 = 1023;
pub const RL_RET_CODE_NUM_SUBFRAMES_OOR: u32 = 1024;
pub const RL_RET_CODE_SF1_TOT_NUM_CHIRPS_OOR: u32 = 1025;
pub const RL_RET_CODE_SF1_NUM_ADC_SAMP_OOR: u32 = 1026;
pub const RL_RET_CODE_SF1_NUM_CHIRPS_OOR: u32 = 1027;
pub const RL_RET_CODE_SF2_TOT_NUM_CHIRPS_OOR: u32 = 1028;
pub const RL_RET_CODE_SF2_NUM_ADC_SAMP_OOR: u32 = 1029;
pub const RL_RET_CODE_SF2_NUM_CHIRPS_OOR: u32 = 1030;
pub const RL_RET_CODE_SF3_TOT_NUM_CHIRPS_OOR: u32 = 1031;
pub const RL_RET_CODE_SF3_NUM_ADC_SAMP_OOR: u32 = 1032;
pub const RL_RET_CODE_SF3_NUM_CHIRPS_OOR: u32 = 1033;
pub const RL_RET_CODE_SF4_TOT_NUM_CHIRPS_OOR: u32 = 1034;
pub const RL_RET_CODE_SF4_NUM_ADC_SAMP_OOR: u32 = 1035;
pub const RL_RET_CODE_SF4_NUM_CHIRPS_OOR: u32 = 1036;
pub const RL_RET_CODE_MCUCLOCK_CTRL_OOR: u32 = 1040;
pub const RL_RET_CODE_MCUCLOCK_SRC_OOR: u32 = 1041;
pub const RL_RET_CODE_PMICCLOCK_CTRL_OOR: u32 = 1042;
pub const RL_RET_CODE_PMICCLOCK_SRC_OOR: u32 = 1043;
pub const RL_RET_CODE_PMICMODE_SELECT_OOR: u32 = 1044;
pub const RL_RET_CODE_PMICFREQ_SLOPE_OOR: u32 = 1045;
pub const RL_RET_CODE_PMICCLK_DITHER_EN_OOR: u32 = 1046;
pub const RL_RET_CODE_TESTPATTERN_EN_OOR: u32 = 1047;
pub const RL_RET_CODE_LFAULTTEST_UNSUPPORTED_OOR: u32 = 1048;
pub const RL_API_NRESP_LFAULTTEST_UNSUPPORTED_OOR: u32 = 1051;
pub const RL_DISABLE_LOGGING: u32 = 1;
pub const RL_OSI_RET_CODE_OK: u32 = 0;
pub const RL_IF_RET_CODE_OK: u32 = 0;
pub const RL_MAX_SIZE_MSG: u32 = 256;
pub const RL_DEVICE_MAP_NATIVE: u32 = 0;
pub const RL_DEVICE_MAP_CASCADED_1: u32 = 1;
pub const RL_DEVICE_MAP_CASCADED_2: u32 = 2;
pub const RL_DEVICE_MAP_CASCADED_3: u32 = 4;
pub const RL_DEVICE_MAP_CASCADED_4: u32 = 8;
pub const RL_DEVICE_MAP_CASCADED_ALL: u32 = 15;
pub const RL_DEVICE_INDEX_INTERNAL_BSS: u32 = 0;
pub const RL_DEVICE_INDEX_INTERNAL_DSS_MSS: u32 = 1;
pub const RL_DEVICE_INDEX_INTERNAL_HOST: u32 = 2;
pub const RL_DEVICE_MAP_INTERNAL_BSS: u32 = 1;
pub const RL_DEVICE_MAP_INTERNAL_DSS_MSS: u32 = 2;
pub const RL_DEVICE_MAP_INTERNAL_HOST: u32 = 4;
pub const RL_DEVICE_CONNECTED_MAX: u32 = 4;
pub const RL_CRC_TYPE_16BIT_CCITT: u32 = 0;
pub const RL_CRC_TYPE_32BIT: u32 = 1;
pub const RL_CRC_TYPE_64BIT_ISO: u32 = 2;
pub const RL_CRC_TYPE_NO_CRC: u32 = 3;
pub const RL_PLATFORM_HOST: u32 = 0;
pub const RL_PLATFORM_MSS: u32 = 1;
pub const RL_PLATFORM_DSS: u32 = 2;
pub const RL_AR_DEVICETYPE_12XX: u32 = 0;
pub const RL_AR_DEVICETYPE_14XX: u32 = 1;
pub const RL_AR_DEVICETYPE_16XX: u32 = 2;
pub const RL_AR_DEVICETYPE_18XX: u32 = 3;
pub const RL_AR_DEVICETYPE_68XX: u32 = 4;
pub const RL_SENSOR_ANALOGTEST_ONE: u32 = 0;
pub const RL_SENSOR_ANALOGTEST_TWO: u32 = 1;
pub const RL_SENSOR_ANALOGTEST_THREE: u32 = 2;
pub const RL_SENSOR_ANALOGTEST_FOUR: u32 = 3;
pub const RL_SENSOR_ANAMUX: u32 = 4;
pub const RL_SENSOR_VSENSE: u32 = 5;
pub const RL_MAX_GPADC_SENSORS: u32 = 6;
pub const SYNC_PATTERN_LEN: u32 = 4;
pub const RHCP_HEADER_LEN: u32 = 12;
pub const RL_CRC_LEN_MAX: u32 = 8;
pub const RL_CMD_PL_LEN_MAX: u32 = 232;
pub const RL_DEV_I_FIRST: u32 = 0;
pub const RL_DEV_Q_FIRST: u32 = 1;
pub const RL_DEV_IQSWAP_MAX: u32 = 2;
pub const RL_DEV_CH_INTERLEAVED: u32 = 0;
pub const RL_DEV_CH_NON_INTERLEAVED: u32 = 1;
pub const RL_DEV_CH_INTERLEAVE_MAX: u32 = 2;
pub const RL_MAX_TST_SRC_OBJECTS: u32 = 2;
pub const RL_MAX_CALIB_DATA_CHUNK: u32 = 3;
pub const RL_RX_CNT: u32 = 4;
pub const RL_TX_CNT: u32 = 3;
pub const RL_CHANNEL_DISABLE: u32 = 0;
pub const RL_CHANNEL_ENABLE: u32 = 1;
pub const RL_FRAME_TRIGGER_STOP: u32 = 0;
pub const RL_FRAME_TRIGGER_START: u32 = 1;
pub const RL_MAX_SUBFRAMES: u32 = 4;
pub const RL_MAX_PROFILES_CNT: u32 = 4;
pub const RL_RX_NOISE_FIGURE_LOW: u32 = 0;
pub const RL_RX_NOISE_FIGURE_HIGH: u32 = 1;
pub const RL_RX_NOISE_FIGURE_MAX: u32 = 2;
pub const RL_ADC_DATA_12_BIT: u32 = 0;
pub const RL_ADC_DATA_14_BIT: u32 = 1;
pub const RL_ADC_DATA_16_BIT: u32 = 2;
pub const RL_ADC_DATA_BIT_MAX: u32 = 3;
pub const RL_ADC_FORMAT_REAL: u32 = 0;
pub const RL_ADC_FORMAT_COMPLEX_1X: u32 = 1;
pub const RL_ADC_FORMAT_COMPLEX_2X: u32 = 2;
pub const RL_ADC_FORMAT_PSEUDO_REAL: u32 = 3;
pub const RL_ADC_FORMAT_MAX: u32 = 4;
pub const RL_ADC_MODE_REGULAR: u32 = 0;
pub const RL_ADC_MODE_LOW_POWER: u32 = 1;
pub const RL_ADC_MODE_MAX: u32 = 2;
pub const RL_RX_BB_BW_AUTO: u32 = 0;
pub const RL_RX_BB_BW_350_KHz: u32 = 1;
pub const RL_RX_BB_BW_10_MHz: u32 = 2;
pub const RL_RX_BB_BW_15_MHz: u32 = 3;
pub const RL_RX_BB_BW_MAX: u32 = 4;
pub const RL_RX_HPF1_175_KHz: u32 = 0;
pub const RL_RX_HPF1_235_KHz: u32 = 1;
pub const RL_RX_HPF1_350_KHz: u32 = 2;
pub const RL_RX_HPF1_700_KHz: u32 = 3;
pub const RL_RX_HPF1_MAX: u32 = 4;
pub const RL_RX_HPF2_350_KHz: u32 = 0;
pub const RL_RX_HPF2_700_KHz: u32 = 1;
pub const RL_RX_HPF2_1p4_MHz: u32 = 2;
pub const RL_RX_HPF2_2p8_MHz: u32 = 3;
pub const RL_RX_HPF2_5p0_MHz: u32 = 4;
pub const RL_RX_HPF2_7p5_MHz: u32 = 5;
pub const RL_RX_HPF2_10_MHz: u32 = 6;
pub const RL_RX_HPF2_15_MHz: u32 = 7;
pub const RL_RX_HPF2_MAX: u32 = 8;
pub const RL_RX_GAIN_30_dB: u32 = 30;
pub const RL_RX_GAIN_36_dB: u32 = 36;
pub const RL_RX_GAIN_44_dB: u32 = 44;
pub const RL_RX_GAIN_50_dB: u32 = 50;
pub const RL_FRAME_SYNC_MODE_SINGLE_CHIP: u32 = 0;
pub const RL_FRAME_SYNC_MODE_MULT_CHIP_MASTER: u32 = 1;
pub const RL_FRAME_SYNC_MODE_MULT_CHIP_SLAVE: u32 = 2;
pub const RL_FRAME_SYNC_MODE_MAX: u32 = 3;
pub const RL_FRAMESTRT_API_TRIGGER: u32 = 1;
pub const RL_FRAMESTRT_SYNCIN_TRIGGER: u32 = 2;
pub const RL_RXANA_COMPLEX: u32 = 0;
pub const RL_RXANA_REAL: u32 = 1;
pub const RL_RXANA_MODES_MAX: u32 = 2;
pub const RL_MAX_NUM_OF_TEMP10_RANGES: u32 = 19;
pub const RL_MON_RF_FREQ_CNT: u32 = 3;
pub const RL_NUM_MON_SLICES_MAX: u32 = 127;
pub const RL_MAX_SB_IN_MSG: u32 = 32;
pub const RL_SBC_ID_INDEX: u32 = 0;
pub const RL_SBC_ID_SIZE: u32 = 2;
pub const RL_SBC_LEN_INDEX: u32 = 2;
pub const RL_SBC_LEN_SIZE: u32 = 2;
pub const RL_SBC_PL_INDEX: u32 = 4;
pub const RL_MIN_SBC_LEN: u32 = 4;
pub const RL_RF_RESP_ERROR_MSG: u32 = 0;
pub const RL_RF_RESERVED0_MSG: u32 = 1;
pub const RL_RF_RESERVED1_MSG: u32 = 2;
pub const RL_RF_RESERVED2_MSG: u32 = 3;
pub const RL_RF_STATIC_CONF_SET_MSG: u32 = 4;
pub const RL_RF_STATIC_CONF_GET_MSG: u32 = 5;
pub const RL_RF_INIT_MSG: u32 = 6;
pub const RL_RF_RESERVED3_MSG: u32 = 7;
pub const RL_RF_DYNAMIC_CONF_SET_MSG: u32 = 8;
pub const RL_RF_DYNAMIC_CONF_GET_MSG: u32 = 9;
pub const RL_RF_FRAME_TRIG_MSG: u32 = 10;
pub const RL_RF_RESERVED4_MSG: u32 = 11;
pub const RL_RF_ADVANCED_FEATURES_SET_MSG: u32 = 12;
pub const RL_RF_ADVANCED_FEATURES_GET_MSG: u32 = 13;
pub const RL_RF_MONITORING_CONF_SET_MSG: u32 = 14;
pub const RL_RF_MONITORING_CONF_GET_MSG: u32 = 15;
pub const RL_RF_RESERVED5_MSG: u32 = 16;
pub const RL_RF_STATUS_GET_MSG: u32 = 17;
pub const RL_RF_RESERVED6_MSG: u32 = 18;
pub const RL_RF_MONITORING_REPO_GET_MSG: u32 = 19;
pub const RL_RF_RESERVED7_MSG: u32 = 20;
pub const RL_RF_RESERVED8_MSG: u32 = 21;
pub const RL_RF_MISC_CONF_SET_MSG: u32 = 22;
pub const RL_RF_MISC_CONF_GET_MSG: u32 = 23;
pub const RL_RF_ASYNC_EVENT_MSG: u32 = 128;
pub const RL_RF_ASYNC_EVENT_1_MSG: u32 = 129;
pub const RL_DSP_RESERVED0_MSG: u32 = 256;
pub const RL_DSP_RESERVED1_MSG: u32 = 257;
pub const RL_DSP_CONFIG_SET_MSG: u32 = 258;
pub const RL_DSP_CONFIG_GET_MSG: u32 = 259;
pub const RL_DSP_RESERVED2_MSG: u32 = 260;
pub const RL_DSP_RESERVED3_MSG: u32 = 261;
pub const RL_DSP_CONFIG_APPLY_MSG: u32 = 262;
pub const RL_DSP_STATUS_GET_MSG: u32 = 263;
pub const RL_DSP_ASYNC_EVENT_MSG: u32 = 384;
pub const RL_DEV_POWERUP_MSG: u32 = 512;
pub const RL_DEV_RESERVED1_MSG: u32 = 513;
pub const RL_DEV_CONFIG_SET_MSG: u32 = 514;
pub const RL_DEV_CONFIG_GET_MSG: u32 = 515;
pub const RL_DEV_FILE_DOWNLOAD_MSG: u32 = 516;
pub const RL_DEV_RESERVED2_MSG: u32 = 517;
pub const RL_DEV_CONFIG_APPLY_MSG: u32 = 518;
pub const RL_DEV_STATUS_GET_MSG: u32 = 519;
pub const RL_DEV_MONITORING_CONF_SET_MSG: u32 = 520;
pub const RL_DEV_MONITORING_CONF_GET_MSG: u32 = 521;
pub const RL_DEV_RESERVED3_MSG: u32 = 522;
pub const RL_DEV_MONITORING_REPORT_GET_MSG: u32 = 523;
pub const RL_DEV_INTERNAL_CONF_SET_MSG: u32 = 524;
pub const RL_DEV_INTERNAL_CONF_GET_MSG: u32 = 525;
pub const RL_DEV_ASYNC_EVENT_MSG: u32 = 640;
pub const RL_MMWL_ASYNC_EVENT_MSG: u32 = 896;
pub const RL_RF_RESP_ERROR_SB: u32 = 0;
pub const RL_RF_RESP_MAX: u32 = 1;
pub const RL_RF_CHAN_CONF_SB: u32 = 0;
pub const RL_RF_RESERVED_SB: u32 = 1;
pub const RL_RF_ADCOUT_CONF_SB: u32 = 2;
pub const RL_RF_LOWPOWERMODE_CONF_SB: u32 = 3;
pub const RL_RF_DYNAMICPOWERSAVE_CONF_SB: u32 = 4;
pub const RL_RF_HIGHSPEEDINTFCLK_CONF_SET_SB: u32 = 5;
pub const RL_RF_DEVICE_CFG_SB: u32 = 6;
pub const RL_RF_RADAR_MISC_CTL_SB: u32 = 7;
pub const RL_RF_CAL_MON_FREQ_LIMIT_SB: u32 = 8;
pub const RL_RF_INIT_CALIB_CONF_SB: u32 = 9;
pub const RL_RF_TX_FREQ_PWR_LIMIT_SB: u32 = 10;
pub const RL_RF_CAL_DATA_RD_WR_SB: u32 = 11;
pub const RL_RF_PH_SHIFT_CAL_DATA_RD_WR_SB: u32 = 12;
pub const RL_RF_APLL_SYNTH_BW_CTL_SB: u32 = 13;
pub const RL_RF_STAT_CONF_SB_MAX: u32 = 14;
pub const RL_RF_RF_INIT_SB: u32 = 0;
pub const RL_RF_INIT_SB_MAX: u32 = 1;
pub const RL_RF_PROFILE_CONF_SB: u32 = 0;
pub const RL_RF_CHIRP_CONF_SB: u32 = 1;
pub const RL_RF_FRAME_CONF_SB: u32 = 2;
pub const RL_RF_CONT_STREAMING_MODE_CONF_SB: u32 = 3;
pub const RL_RF_CONT_STREAMING_MODE_EN_SB: u32 = 4;
pub const RL_RF_FRAME_CONF_ADVANCED_SB: u32 = 5;
pub const RL_RF_PERCHIRPPHASESHIFT_CONF_SB: u32 = 6;
pub const RL_RF_PROG_FILT_COEFF_RAM_SET_SB: u32 = 7;
pub const RL_RF_PROG_FILT_CONF_SET_SB: u32 = 8;
pub const RL_RF_CALIB_MON_TIME_UNIT_SB: u32 = 9;
pub const RL_RF_RUN_TIME_CALIB_CONF_TRIG_SB: u32 = 10;
pub const RL_RF_INTER_RX_GAIN_PH_FREQ_CTRL_SB: u32 = 11;
pub const RL_RF_RX_GAIN_TEMPLUT_CONF_SB: u32 = 12;
pub const RL_RF_TX_GAIN_TEMPLUT_CONF_SB: u32 = 13;
pub const RL_RF_LB_BURST_CFG_SET_SB: u32 = 14;
pub const RL_RF_DYN_CHIRP_CFG_SET_SB: u32 = 15;
pub const RL_RF_DYN_PERCHIRP_PHSHFT_CFG_SET_SB: u32 = 16;
pub const RL_RF_DYN_CHIRP_CFG_EN_SB: u32 = 17;
pub const RL_RF_INTERCHIRP_BLOCK_CTRL_SB: u32 = 18;
pub const RL_RF_SUBFRAME_START_SB: u32 = 19;
pub const RL_RF_RESERVED0: u32 = 20;
pub const RL_RF_DYNAMIC_CONF_SB_MAX: u32 = 21;
pub const RL_RF_FRAMESTARTSTOP_CONF_SB: u32 = 0;
pub const RL_RF_FRAME_TRIG_SB_MAX: u32 = 1;
pub const RL_RF_BPM_COMMON_CONF_SB: u32 = 0;
pub const RL_RF_BPM_CHIRP_CONF_SB: u32 = 1;
pub const RL_RF_POWER_SAVE_MODE_CONF_SB: u32 = 2;
pub const RL_RF_ADV_FEATURES_SB_MAX: u32 = 3;
pub const RL_RF_MONITORING_CONF_SB: u32 = 0;
pub const RL_RF_MONIT_CONF_SB_MAX: u32 = 1;
pub const RL_RF_RFVERSION_SB: u32 = 0;
pub const RL_RF_RFCPUFAULT_STATUS_SB: u32 = 1;
pub const RL_RF_RFESMFAULT_STATUS_SB: u32 = 2;
pub const RL_RF_DIEID_STATUS_SB: u32 = 3;
pub const RL_RF_BOOTUP_BIST_STATUS_SB: u32 = 4;
pub const RL_RF_STATUS_SB_MAX: u32 = 5;
pub const RL_RF_MONITORING_REPO_GET_SB: u32 = 0;
pub const RL_RF_MONITORING_REPO_GET_SB_MAX: u32 = 1;
pub const RL_RF_DIG_MON_EN_SB: u32 = 0;
pub const RL_RF_DIG_MON_PERIODIC_CONF_SB: u32 = 1;
pub const RL_RF_ANA_MON_EN_SB: u32 = 2;
pub const RL_RF_TEMP_MON_CONF_SB: u32 = 3;
pub const RL_RF_RX_GAIN_PHASE_MON_CONF_SB: u32 = 4;
pub const RL_RF_RX_NOISE_MON_CONF_SB: u32 = 5;
pub const RL_RF_RX_IFSTAGE_MON_CONF_SB: u32 = 6;
pub const RL_RF_TX0_POW_MON_CONF_SB: u32 = 7;
pub const RL_RF_TX1_POW_MON_CONF_SB: u32 = 8;
pub const RL_RF_TX2_POW_MON_CONF_SB: u32 = 9;
pub const RL_RF_TX0_BALLBREAK_MON_CONF_SB: u32 = 10;
pub const RL_RF_TX1_BALLBREAK_MON_CONF_SB: u32 = 11;
pub const RL_RF_TX2_BALLBREAK_MON_CONF_SB: u32 = 12;
pub const RL_RF_TX_GAIN_PHASE_MISMATCH_MON_CONF_SB: u32 = 13;
pub const RL_RF_TX0_BPM_MON_CONF_SB: u32 = 14;
pub const RL_RF_TX1_BPM_MON_CONF_SB: u32 = 15;
pub const RL_RF_TX2_BPM_MON_CONF_SB: u32 = 16;
pub const RL_RF_SYNTH_FREQ_MON_CONF_SB: u32 = 17;
pub const RL_RF_EXT_ANA_SIGNALS_MON_CONF_SB: u32 = 18;
pub const RL_RF_TX0_INT_ANA_SIGNALS_MON_CONF_SB: u32 = 19;
pub const RL_RF_TX1_INT_ANA_SIGNALS_MON_CONF_SB: u32 = 20;
pub const RL_RF_TX2_INT_ANA_SIGNALS_MON_CONF_SB: u32 = 21;
pub const RL_RF_RX_INT_ANA_SIGNALS_MON_CONF_SB: u32 = 22;
pub const RL_RF_PMCLKLO_INT_ANA_SIGNALS_MON_CONF_SB: u32 = 23;
pub const RL_RF_GPADC_INT_ANA_SIGNALS_MON_CONF_SB: u32 = 24;
pub const RL_RF_PLL_CONTROL_VOLT_MON_CONF_SB: u32 = 25;
pub const RL_RF_DUAL_CLOCK_COMP_MON_CONF_SB: u32 = 26;
pub const RL_RF_RX_SATURATION_MON_CONF_SB: u32 = 27;
pub const RL_RF_RX_SIGIMG_MON_CONF_SB: u32 = 28;
pub const RL_RF_RX_MIXER_IN_POWR_CONF_SB: u32 = 29;
pub const RL_RF_SYNTH_LIN_MON_CONF_SB: u32 = 30;
pub const RL_RF_FAULT_INJECTION_CONF_SB: u32 = 31;
pub const RL_RF_ORBIT_ENABLE_SB: u32 = 0;
pub const RL_RF_ORBIT_TEST_API_SB: u32 = 1;
pub const RL_RF_TEST_SOURCE_CONFIG_SET_SB: u32 = 2;
pub const RL_RF_TEST_SOURCE_ENABLE_SET_SB: u32 = 3;
pub const RL_RF_DEBUG_API_SB: u32 = 4;
pub const RL_RF_REG_CONFIG_SET_SB: u32 = 5;
pub const RL_RF_TRIGGER_CALIB_MON_SB: u32 = 6;
pub const RL_RF_CALIB_DISABLE_SB: u32 = 7;
pub const RL_RF_MISC_CONF_SET_RESERVED_01: u32 = 8;
pub const RL_RF_MISC_CONF_SET_RESERVED_02: u32 = 9;
pub const RL_RF_CHAR_CONF_DYNAMIC_SET_SB: u32 = 10;
pub const RL_RF_TEMP_SENS_TRIM_SET_SB: u32 = 11;
pub const RL_RF_LDOBYPASS_SET_SB: u32 = 12;
pub const RL_RF_PALOOPBACK_CFG_SET_SB: u32 = 13;
pub const RL_RF_PSLOOPBACK_CFG_SET_SB: u32 = 14;
pub const RL_RF_IFLOOPBACK_CFG_SET_SB: u32 = 15;
pub const RL_RF_GPADC_CONF_SET_SB: u32 = 16;
pub const RL_RF_PD_TRIM_1GHZ_SET_SB: u32 = 17;
pub const RL_RF_MEAS_TX_POWER_SET_SB: u32 = 18;
pub const RL_RF_MEAS_PD_POWER_SET_SB: u32 = 19;
pub const RL_RF_MISC_CONF_SET_SB_MAX: u32 = 20;
pub const RL_RF_MISC_CONF_GET_RESERVED1: u32 = 0;
pub const RL_RF_MISC_CONF_GET_RESERVED2: u32 = 1;
pub const RL_RF_TEST_SOURCE_CONFIG_GET_SB: u32 = 2;
pub const RL_RF_TEST_SOURCE_ENABLE_GET_SB: u32 = 3;
pub const RL_RF_MISC_CONF_GET_RESERVED3: u32 = 4;
pub const RL_RF_REG_CONFIG_GET_SB: u32 = 5;
pub const RL_RF_MISC_CONF_GET_RESERVED4: u32 = 6;
pub const RL_RF_MISC_CONF_GET_RESERVED5: u32 = 7;
pub const RL_RF_MISC_CONF_GET_RESERVED6: u32 = 8;
pub const RL_RF_CHAR_CONF_STATIC_GET_SB: u32 = 9;
pub const RL_RF_CHAR_CONF_DYNAMIC_GET_SB: u32 = 10;
pub const RL_RF_MISC_CONF_GET_RESERVED7: u32 = 11;
pub const RL_RF_MISC_CONF_GET_SB_MAX: u32 = 12;
pub const RL_RF_AE_RESERVED1: u32 = 0;
pub const RL_RF_AE_RESERVED2: u32 = 1;
pub const RL_RF_AE_CPUFAULT_SB: u32 = 2;
pub const RL_RF_AE_ESMFAULT_SB: u32 = 3;
pub const RL_RF_AE_INITCALIBSTATUS_SB: u32 = 4;
pub const RL_RF_AE_RESERVED3: u32 = 5;
pub const RL_RF_AE_RESERVED4: u32 = 6;
pub const RL_RF_AE_RESERVED5: u32 = 7;
pub const RL_RF_AE_RESERVED6: u32 = 8;
pub const RL_RF_AE_RESERVED7: u32 = 9;
pub const RL_RF_AE_RESERVED8: u32 = 10;
pub const RL_RF_AE_FRAME_TRIGGER_RDY_SB: u32 = 11;
pub const RL_RF_AE_GPADC_MEAS_DATA_SB: u32 = 12;
pub const RL_RF_AE_RESERVED9: u32 = 13;
pub const RL_RF_AE_RESERVED10: u32 = 14;
pub const RL_RF_AE_FRAME_END_SB: u32 = 15;
pub const RL_RF_AE_ANALOG_FAULT_SB: u32 = 16;
pub const RL_RF_AE_MON_TIMING_FAIL_REPORT_SB: u32 = 17;
pub const RL_RF_AE_RUN_TIME_CALIB_REPORT_SB: u32 = 18;
pub const RL_RF_AE_DIG_LATENTFAULT_REPORT_SB: u32 = 19;
pub const RL_RF_AE_MON_DFE_STATISTICS_SB: u32 = 20;
pub const RL_RF_AE_MON_REPORT_HEADER_SB: u32 = 21;
pub const RL_RF_AE_MON_DIG_PERIODIC_REPORT_SB: u32 = 22;
pub const RL_RF_AE_MON_TEMPERATURE_REPORT_SB: u32 = 23;
pub const RL_RF_AE_MON_RX_GAIN_PHASE_REPORT: u32 = 24;
pub const RL_RF_AE_MON_RX_NOISE_FIG_REPORT: u32 = 25;
pub const RL_RF_AE_MON_RX_IF_STAGE_REPORT: u32 = 26;
pub const RL_RF_AE_MON_TX0_POWER_REPORT: u32 = 27;
pub const RL_RF_AE_MON_TX1_POWER_REPORT: u32 = 28;
pub const RL_RF_AE_MON_TX2_POWER_REPORT: u32 = 29;
pub const RL_RF_AE_MON_TX0_BALLBREAK_REPORT: u32 = 30;
pub const RL_RF_AE_MON_TX1_BALLBREAK_REPORT: u32 = 31;
pub const RL_RF_AE_MON_TX2_BALLBREAK_REPORT: u32 = 0;
pub const RL_RF_AE_MON_TX_GAIN_MISMATCH_REPORT: u32 = 1;
pub const RL_RF_AE_MON_TX0_BPM_REPORT: u32 = 2;
pub const RL_RF_AE_MON_TX1_BPM_REPORT: u32 = 3;
pub const RL_RF_AE_MON_TX2_BPM_REPORT: u32 = 4;
pub const RL_RF_AE_MON_SYNTHESIZER_FREQ_REPORT: u32 = 5;
pub const RL_RF_AE_MON_EXT_ANALOG_SIG_REPORT: u32 = 6;
pub const RL_RF_AE_MON_TX0_INT_ANA_SIG_REPORT: u32 = 7;
pub const RL_RF_AE_MON_TX1_INT_ANA_SIG_REPORT: u32 = 8;
pub const RL_RF_AE_MON_TX2_INT_ANA_SIG_REPORT: u32 = 9;
pub const RL_RF_AE_MON_RX_INT_ANALOG_SIG_REPORT: u32 = 10;
pub const RL_RF_AE_MON_PMCLKLO_INT_ANA_SIG_REPORT: u32 = 11;
pub const RL_RF_AE_MON_GPADC_INT_ANA_SIG_REPORT: u32 = 12;
pub const RL_RF_AE_MON_PLL_CONTROL_VOLT_REPORT: u32 = 13;
pub const RL_RF_AE_MON_DCC_CLK_FREQ_REPORT: u32 = 14;
pub const RL_RF_AE_MON_RESERVED0: u32 = 15;
pub const RL_RF_AE_MON_RESERVED1: u32 = 16;
pub const RL_RF_AE_MON_RX_MIXER_IN_PWR_REPORT: u32 = 17;
pub const RL_RF_AE_MON_RESERVED2: u32 = 18;
pub const RL_RF_AE_MON_SYNTH_FREQ_NONLIVE_REPORT: u32 = 19;
pub const RL_RF_AE_SB_MAX: u32 = 20;
pub const RL_MMWL_AE_MISMATCH_REPORT: u32 = 0;
pub const RL_MMWL_AE_INTERNALERR_REPORT: u32 = 1;
pub const RL_SYS_RF_POWERUP_SB: u32 = 0;
pub const RL_SYS_NUM_OF_RF_POWERUP_SBC: u32 = 1;
pub const RL_SYS_FILE_DWLD_SB: u32 = 0;
pub const RL_SYS_NUM_OF_FILE_DWLD_SBC: u32 = 1;
pub const RL_DEV_MCUCLOCK_CONF_SET_SB: u32 = 0;
pub const RL_DEV_RX_DATA_FORMAT_CONF_SET_SB: u32 = 1;
pub const RL_DEV_RX_DATA_PATH_CONF_SET_SB: u32 = 2;
pub const RL_DEV_DATA_PATH_LANEEN_SET_SB: u32 = 3;
pub const RL_DEV_DATA_PATH_CLOCK_SET_SB: u32 = 4;
pub const RL_DEV_DATA_PATH_CFG_SET_SB: u32 = 5;
pub const RL_DEV_RX_CONTSTREAMING_MODE_CONF_SET_SB: u32 = 6;
pub const RL_DEV_CSI2_CFG_SET_SB: u32 = 7;
pub const RL_DEV_PMICCLOCK_CONF_SET_SB: u32 = 8;
pub const RL_DEV_PERIODICTESTS_CONF_SB: u32 = 9;
pub const RL_DEV_LATENTFAULT_TEST_CONF_SB: u32 = 10;
pub const RL_DEV_TESTPATTERN_GEN_SET_SB: u32 = 11;
pub const RL_DEV_MISC_CFG_SET_SB: u32 = 12;
pub const RL_DEV_CONFIG_SB_MAX: u32 = 13;
pub const RL_SYS_CONFIG_APPLY_SB: u32 = 0;
pub const RL_ADV_FRAME_DATA_CONFIG_SB: u32 = 1;
pub const RL_SYS_CONFIG_APPLY_SB_MAX: u32 = 2;
pub const RL_SYS_VERSION_SB: u32 = 0;
pub const RL_SYS_CPUFAULT_STATUS_SB: u32 = 1;
pub const RL_SYS_ESMFAULT_STATUS_SB: u32 = 2;
pub const RL_SYS_FRAME_CONFIG_GET_SB: u32 = 3;
pub const RL_SYS_ADV_FRAME_CONFIG_GET_SB: u32 = 4;
pub const RL_SYS_NUM_OF_STATUS_SBC: u32 = 5;
pub const RL_DEV_AE_MSSPOWERUPDONE_SB: u32 = 0;
pub const RL_DEV_AE_RFPOWERUPDONE_SB: u32 = 1;
pub const RL_DEV_AE_MSS_CPUFAULT_SB: u32 = 2;
pub const RL_DEV_AE_MSS_ESMFAULT_SB: u32 = 3;
pub const RL_DEV_AE_RESERVED0: u32 = 4;
pub const RL_DEV_AE_MSS_BOOTERRSTATUS_SB: u32 = 5;
pub const RL_DEV_AE_MSS_LATENTFLT_TEST_REPORT_SB: u32 = 6;
pub const RL_DEV_AE_MSS_PERIODIC_TEST_STATUS_SB: u32 = 7;
pub const RL_DEV_AE_MSS_RF_ERROR_STATUS_SB: u32 = 8;
pub const RL_DEV_AE_MSS_VMON_ERROR_STATUS_SB: u32 = 9;
pub const RL_DEV_AE_MSS_ADC_DATA_SB: u32 = 10;
pub const RL_DEV_AE_SB_MAX: u32 = 11;
pub const RL_SYS_AE_DEV_CPUFAULT_SB: u32 = 0;
pub const RL_SYS_AE_DEV_ESMFAULT_SB: u32 = 1;
pub const RL_SYS_NUM_OF_AE_DEVFAULT_REPO_SBC: u32 = 2;
pub const RL_RF_DFE_STATISTICS_REPORT_GET_SB: u32 = 0;
pub const RL_DEV_MEM_REGISTER_SB: u32 = 0;
pub const RL_DEV_NUM_OF_INTERN_CONF_SBC: u32 = 1;
pub const RL_SYS_NRESP_INVLD_OPCODE: u32 = 1;
pub const RL_SYS_NRESP_INVLD_MSGID: u32 = 2;
pub const RL_SYS_NRESP_INVLD_NUM_SB: u32 = 3;
pub const RL_SYS_NRESP_INVLD_SB_ID: u32 = 4;
pub const RL_SYS_NRESP_INVLD_SB_LEN: u32 = 5;
pub const RL_SYS_NRESP_SB_GET_ERROR: u32 = 6;
pub const RL_SYS_NRESP_SB_SET_ERROR: u32 = 7;
pub const RL_SYS_NRESP_SB_SET_INVL_DATA: u32 = 8;
pub const RL_SYS_NRESP_CRC_FAILED: u32 = 9;
pub const RL_SYS_NRESP_FILETYPE_MISMATCHED: u32 = 10;
pub const RL_SYS_NRESP_REG_WRITE_FAILED: u32 = 11;
pub const RL_SYS_NRESP_ERROR_RESRVD: u32 = 65535;
pub type __u_char = cty::c_uchar;
pub type __u_short = cty::c_ushort;
pub type __u_int = cty::c_uint;
pub type __u_long = cty::c_ulong;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_longlong;
pub type __uint64_t = cty::c_ulonglong;
pub type __quad_t = cty::c_longlong;
pub type __u_quad_t = cty::c_ulonglong;
pub type __intmax_t = cty::c_longlong;
pub type __uintmax_t = cty::c_ulonglong;
pub type __dev_t = __u_quad_t;
pub type __uid_t = cty::c_uint;
pub type __gid_t = cty::c_uint;
pub type __ino_t = cty::c_ulong;
pub type __ino64_t = __u_quad_t;
pub type __mode_t = cty::c_uint;
pub type __nlink_t = cty::c_uint;
pub type __off_t = cty::c_long;
pub type __off64_t = __quad_t;
pub type __pid_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [cty::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = cty::c_long;
pub type __rlim_t = cty::c_ulong;
pub type __rlim64_t = __u_quad_t;
pub type __id_t = cty::c_uint;
pub type __time_t = cty::c_long;
pub type __useconds_t = cty::c_uint;
pub type __suseconds_t = cty::c_long;
pub type __daddr_t = cty::c_int;
pub type __key_t = cty::c_int;
pub type __clockid_t = cty::c_int;
pub type __timer_t = *mut cty::c_void;
pub type __blksize_t = cty::c_long;
pub type __blkcnt_t = cty::c_long;
pub type __blkcnt64_t = __quad_t;
pub type __fsblkcnt_t = cty::c_ulong;
pub type __fsblkcnt64_t = __u_quad_t;
pub type __fsfilcnt_t = cty::c_ulong;
pub type __fsfilcnt64_t = __u_quad_t;
pub type __fsword_t = cty::c_int;
pub type __ssize_t = cty::c_int;
pub type __syscall_slong_t = cty::c_long;
pub type __syscall_ulong_t = cty::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut cty::c_char;
pub type __intptr_t = cty::c_int;
pub type __socklen_t = cty::c_uint;
pub type __sig_atomic_t = cty::c_int;
pub type int_least8_t = cty::c_schar;
pub type int_least16_t = cty::c_short;
pub type int_least32_t = cty::c_int;
pub type int_least64_t = cty::c_longlong;
pub type uint_least8_t = cty::c_uchar;
pub type uint_least16_t = cty::c_ushort;
pub type uint_least32_t = cty::c_uint;
pub type uint_least64_t = cty::c_ulonglong;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_int;
pub type int_fast32_t = cty::c_int;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_uint;
pub type uint_fast32_t = cty::c_uint;
pub type uint_fast64_t = cty::c_ulonglong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = cty::c_uint;
pub type wchar_t = cty::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn memcpy(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __n: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __n: cty::c_uint,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __c: cty::c_int,
        __n: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memset(__s: *mut cty::c_void, __c: cty::c_int, __n: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const cty::c_void,
        __s2: *const cty::c_void,
        __n: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memchr(__s: *const cty::c_void, __c: cty::c_int, __n: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_uint,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_uint,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const cty::c_char, __s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __n: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const cty::c_char, __s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_uint,
    ) -> cty::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const cty::c_ushort,
    pub __ctype_tolower: *const cty::c_int,
    pub __ctype_toupper: *const cty::c_int,
    pub __names: [*const cty::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::core::mem::size_of::<__locale_struct>(),
        116usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<__locale_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
impl Default for __locale_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __l: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strndup(__string: *const cty::c_char, __n: cty::c_uint) -> *mut cty::c_char;
}
extern "C" {
    pub fn strchr(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const cty::c_char, __reject: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strspn(__s: *const cty::c_char, __accept: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strpbrk(__s: *const cty::c_char, __accept: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const cty::c_char, __needle: *const cty::c_char)
        -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut cty::c_char, __delim: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut cty::c_char,
        __delim: *const cty::c_char,
        __save_ptr: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut cty::c_char,
        __delim: *const cty::c_char,
        __save_ptr: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlen(__s: *const cty::c_char) -> cty::c_uint;
}
extern "C" {
    pub fn strnlen(__string: *const cty::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: cty::c_int,
        __buf: *mut cty::c_char,
        __buflen: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: cty::c_int, __l: locale_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn bcmp(__s1: *const cty::c_void, __s2: *const cty::c_void, __n: size_t) -> cty::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const cty::c_void, __dest: *mut cty::c_void, __n: size_t);
}
extern "C" {
    pub fn bzero(__s: *mut cty::c_void, __n: cty::c_uint);
}
extern "C" {
    pub fn index(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn rindex(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn ffs(__i: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ffsl(__l: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn ffsll(__ll: cty::c_longlong) -> cty::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const cty::c_char, __s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __n: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __loc: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut cty::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut cty::c_char,
        __delim: *const cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strsignal(__sig: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_uint,
    ) -> *mut cty::c_char;
}
#[doc = " TYPE-DEFINE STRUCT/ENUM/UNION DEFINITIONS"]
#[doc = ""]
#[doc = " Standard C data types typedef"]
pub type rlUInt8_t = cty::c_uchar;
pub type rlUInt16_t = cty::c_ushort;
pub type rlUInt32_t = cty::c_uint;
pub type rlUInt64_t = cty::c_ulonglong;
pub type rlInt64_t = cty::c_longlong;
pub type rlInt8_t = cty::c_char;
pub type rlSInt8_t = cty::c_schar;
pub type rlInt16_t = cty::c_short;
pub type rlInt32_t = cty::c_int;
pub type rlVoid_t = cty::c_void;
#[doc = " \\brief"]
#[doc = " Communication Interface Handle"]
pub type rlComIfHdl_t = *mut cty::c_void;
#[doc = " \\brief"]
#[doc = " OS Message Queue Object Handle"]
pub type rlOsiMsgQHdl_t = *mut cty::c_void;
#[doc = " \\brief"]
#[doc = " OS Semaphore Object Handle"]
pub type rlOsiSemHdl_t = *mut cty::c_void;
#[doc = " \\brief"]
#[doc = " OS Mutex Object Handle"]
pub type rlOsiMutexHdl_t = *mut cty::c_void;
#[doc = " \\brief"]
#[doc = " OS Time data type"]
pub type rlOsiTime_t = rlUInt32_t;
#[doc = " \\brief"]
#[doc = " mmWaveLink API return type"]
pub type rlReturnVal_t = rlInt32_t;
#[doc = " \\brief"]
#[doc = " mmWaveLink Support CRC type"]
pub type rlCrcType_t = rlUInt8_t;
#[doc = " \\brief"]
#[doc = " mmWaveLink Spawn Task Function"]
pub type RL_P_OSI_SPAWN_ENTRY =
    ::core::option::Option<unsafe extern "C" fn(pValue: *const cty::c_void)>;
#[doc = " \\brief"]
#[doc = " mmWaveLink Event Handler callback"]
pub type RL_P_EVENT_HANDLER =
    ::core::option::Option<unsafe extern "C" fn(deviceIndex: rlUInt8_t, pValue: *mut cty::c_void)>;
#[doc = " \\brief"]
#[doc = " Communication interface(SPI, MailBox, UART etc) callback functions"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlComIfCbs {
    #[doc = " @fn rlComIfHdl_t (*rlComIfOpen)(rlUInt8_t deviceIndex, rlUInt32_t flags)"]
    #[doc = ""]
    #[doc = "...@brief Open Communication interface"]
    #[doc = "   @param[in] deviceIndex - Communication Interface to Open"]
    #[doc = "   @param[in] flags - Flags to configure the interface"]
    #[doc = ""]
    #[doc = "   @return rlComIfHdl_t Handle to access the communication interface"]
    #[doc = ""]
    #[doc = "   Open Communication interface"]
    pub rlComIfOpen: ::core::option::Option<
        unsafe extern "C" fn(deviceIndex: rlUInt8_t, flags: rlUInt32_t) -> rlComIfHdl_t,
    >,
    #[doc = " @fn rlInt32_t (*rlComIfRead)(rlComIfHdl_t fd, rlUInt8_t *pBuff, rlUInt16_t len)"]
    #[doc = ""]
    #[doc = "   @brief Read Data from Communication interface"]
    #[doc = "   @param[in] fd - Handle to access the communication interface"]
    #[doc = "   @param[out] pBuff - Buffer to store data from communication interface"]
    #[doc = "   @param[in] len - Read size in bytes"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Length of received data"]
    #[doc = ""]
    #[doc = "   Read Data from Communication interface"]
    pub rlComIfRead: ::core::option::Option<
        unsafe extern "C" fn(fd: rlComIfHdl_t, pBuff: *mut rlUInt8_t, len: rlUInt16_t) -> rlInt32_t,
    >,
    #[doc = " @fn rlInt32_t (*rlComIfWrite)(rlComIfHdl_t fd, rlUInt8_t *pBuff, rlUInt16_t len)"]
    #[doc = ""]
    #[doc = "   @brief Write Data over Communication interface"]
    #[doc = "   @param[in] fd - Handle to access the communication interface"]
    #[doc = "   @param[in] pBuff - Buffer containing data to write over communication interface"]
    #[doc = "   @param[in] len - write size in bytes"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Length of data sent"]
    #[doc = ""]
    #[doc = "   Write Data over Communication interface"]
    pub rlComIfWrite: ::core::option::Option<
        unsafe extern "C" fn(fd: rlComIfHdl_t, pBuff: *mut rlUInt8_t, len: rlUInt16_t) -> rlInt32_t,
    >,
    #[doc = " @fn rlInt32_t (*rlComIfClose)(rlComIfHdl_t fd)"]
    #[doc = ""]
    #[doc = "   @brief Close the Communication interface"]
    #[doc = "   @param[in] fd - Handle to access the communication interface"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   Close the Communication interface"]
    pub rlComIfClose: ::core::option::Option<unsafe extern "C" fn(fd: rlComIfHdl_t) -> rlInt32_t>,
}
#[test]
fn bindgen_test_layout_rlComIfCbs() {
    assert_eq!(
        ::core::mem::size_of::<rlComIfCbs>(),
        16usize,
        concat!("Size of: ", stringify!(rlComIfCbs))
    );
    assert_eq!(
        ::core::mem::align_of::<rlComIfCbs>(),
        4usize,
        concat!("Alignment of ", stringify!(rlComIfCbs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlComIfCbs>())).rlComIfOpen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlComIfCbs),
            "::",
            stringify!(rlComIfOpen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlComIfCbs>())).rlComIfRead as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlComIfCbs),
            "::",
            stringify!(rlComIfRead)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlComIfCbs>())).rlComIfWrite as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlComIfCbs),
            "::",
            stringify!(rlComIfWrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlComIfCbs>())).rlComIfClose as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlComIfCbs),
            "::",
            stringify!(rlComIfClose)
        )
    );
}
pub type rlComIfCbs_t = rlComIfCbs;
#[doc = " \\brief"]
#[doc = " OS mutex callback functions"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlOsiMutexCbs {
    #[doc = " @fn rlInt32_t (*rlOsiMutexCreate)(rlOsiMutexHdl_t* mutexHdl, rlInt8_t* name)"]
    #[doc = ""]
    #[doc = "   @brief Create Mutex Object"]
    #[doc = "   @param[in] name      - Name to associate with Mutex Object"]
    #[doc = "   @param[out] mutexHdl - Pointer to Mutex object"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   Create Mutex Object"]
    pub rlOsiMutexCreate: ::core::option::Option<
        unsafe extern "C" fn(mutexHdl: *mut rlOsiMutexHdl_t, name: *mut rlInt8_t) -> rlInt32_t,
    >,
    #[doc = " @fn rlInt32_t (*rlOsiMutexLock)(rlOsiMutexHdl_t* mutexHdl, rlOsiTime_t timeout)"]
    #[doc = ""]
    #[doc = "   @brief Lock Mutex Object"]
    #[doc = "   @param[in] mutexHdl - Pointer to Mutex object"]
    #[doc = "   @param[in] timeout  - Maximum Time to wait for Mutex Lock"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   OSI Lock Mutex Object."]
    #[doc = "   mmWaveLink requires this Mutex object to be locked to avoid any parallel API"]
    #[doc = "   call for the same device instance. In one of the case when mmWaveLink is"]
    #[doc = "   underway for a command-response and device sends Async-event message in between,"]
    #[doc = "   so at this instance mmWaveLink will try to lock the same Mutex again. Expectation"]
    #[doc = "   is that command-response sequence should complete first and that flow unlocks this Mutex"]
    #[doc = "   and then only at other context mmWaveLink will cater the Async-event (HostIrq) request."]
    #[doc = "   mmWaveLink passes timeout as max value, where it expects to lock the Mutex for max period."]
    #[doc = "   Any non-zero return value will be treated as error and mmWaveLink will generate"]
    #[doc = "   async-event message [SBID RL_RET_CODE_RADAR_OSIF_ERROR] with payload of error code (-10)."]
    #[doc = "   This error async-event will be generated only in the interrupt context while catering any"]
    #[doc = "   AWR device's async-event message whereas during the CMD-RSP flow that API will return with"]
    #[doc = "   error code (-10)."]
    pub rlOsiMutexLock: ::core::option::Option<
        unsafe extern "C" fn(mutexHdl: *mut rlOsiMutexHdl_t, timeout: rlOsiTime_t) -> rlInt32_t,
    >,
    #[doc = " @fn rlInt32_t (*rlOsiMutexUnLock)(rlOsiMutexHdl_t* mutexHdl)"]
    #[doc = ""]
    #[doc = "   @brief Unlock Mutex Object"]
    #[doc = "   @param[in] mutexHdl - Pointer to Mutex object"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   Unlock Mutex Object. Any non-zero return value will be treated as error and mmWaveLink"]
    #[doc = "   will return its own error code (-10)."]
    pub rlOsiMutexUnLock:
        ::core::option::Option<unsafe extern "C" fn(mutexHdl: *mut rlOsiMutexHdl_t) -> rlInt32_t>,
    #[doc = " @fn rlInt32_t (*rlOsiMutexDelete)(rlOsiMutexHdl_t* mutexHdl)"]
    #[doc = ""]
    #[doc = "   @brief Destroy Mutex Object"]
    #[doc = "   @param[in] mutexHdl - Pointer to Mutex object"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   Destroy Mutex Object"]
    pub rlOsiMutexDelete:
        ::core::option::Option<unsafe extern "C" fn(mutexHdl: *mut rlOsiMutexHdl_t) -> rlInt32_t>,
}
#[test]
fn bindgen_test_layout_rlOsiMutexCbs() {
    assert_eq!(
        ::core::mem::size_of::<rlOsiMutexCbs>(),
        16usize,
        concat!("Size of: ", stringify!(rlOsiMutexCbs))
    );
    assert_eq!(
        ::core::mem::align_of::<rlOsiMutexCbs>(),
        4usize,
        concat!("Alignment of ", stringify!(rlOsiMutexCbs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlOsiMutexCbs>())).rlOsiMutexCreate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlOsiMutexCbs),
            "::",
            stringify!(rlOsiMutexCreate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlOsiMutexCbs>())).rlOsiMutexLock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlOsiMutexCbs),
            "::",
            stringify!(rlOsiMutexLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlOsiMutexCbs>())).rlOsiMutexUnLock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlOsiMutexCbs),
            "::",
            stringify!(rlOsiMutexUnLock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlOsiMutexCbs>())).rlOsiMutexDelete as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlOsiMutexCbs),
            "::",
            stringify!(rlOsiMutexDelete)
        )
    );
}
pub type rlOsiMutexCbs_t = rlOsiMutexCbs;
#[doc = " \\brief"]
#[doc = " OS semaphore callback functions"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlOsiSemCbs {
    #[doc = " @fn rlInt32_t (*rlOsiSemCreate)(rlOsiSemHdl_t* semHdl, rlInt8_t* name)"]
    #[doc = ""]
    #[doc = "   @brief Create Semaphore Object"]
    #[doc = "   @param[in] name      - Name to associate with Sem Object"]
    #[doc = "   @param[out] semHdl   - Pointer to Sem object"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   Create Semaphore Object"]
    pub rlOsiSemCreate: ::core::option::Option<
        unsafe extern "C" fn(semHdl: *mut rlOsiSemHdl_t, name: *mut rlInt8_t) -> rlInt32_t,
    >,
    #[doc = " @fn rlInt32_t (*rlOsiSemWait)(rlOsiSemHdl_t* semHdl, rlOsiTime_t timeout)"]
    #[doc = ""]
    #[doc = "   @brief Wait for Semaphore"]
    #[doc = "   @param[in] semHdl   - Pointer to Sem object"]
    #[doc = "   @param[in] timeout  - Maximum Time to wait for Semaphore"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   Wait for Semaphore"]
    pub rlOsiSemWait: ::core::option::Option<
        unsafe extern "C" fn(semHdl: *mut rlOsiSemHdl_t, timeout: rlOsiTime_t) -> rlInt32_t,
    >,
    #[doc = " @fn rlInt32_t (*rlOsiSemSignal)(rlOsiSemHdl_t* semHdl)"]
    #[doc = ""]
    #[doc = "   @brief Release Semaphore"]
    #[doc = "   @param[in] semHdl - Pointer to Sem object"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   Release Semaphore"]
    pub rlOsiSemSignal:
        ::core::option::Option<unsafe extern "C" fn(semHdl: *mut rlOsiSemHdl_t) -> rlInt32_t>,
    #[doc = " @fn rlInt32_t (*rlOsiSemDelete)(rlOsiSemHdl_t* semHdl)"]
    #[doc = ""]
    #[doc = "   @brief Destroy Semaphore Object"]
    #[doc = "   @param[in] semHdl - Pointer to Sem object"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   Destroy Semaphore Object"]
    pub rlOsiSemDelete:
        ::core::option::Option<unsafe extern "C" fn(semHdl: *mut rlOsiSemHdl_t) -> rlInt32_t>,
}
#[test]
fn bindgen_test_layout_rlOsiSemCbs() {
    assert_eq!(
        ::core::mem::size_of::<rlOsiSemCbs>(),
        16usize,
        concat!("Size of: ", stringify!(rlOsiSemCbs))
    );
    assert_eq!(
        ::core::mem::align_of::<rlOsiSemCbs>(),
        4usize,
        concat!("Alignment of ", stringify!(rlOsiSemCbs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlOsiSemCbs>())).rlOsiSemCreate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlOsiSemCbs),
            "::",
            stringify!(rlOsiSemCreate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlOsiSemCbs>())).rlOsiSemWait as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlOsiSemCbs),
            "::",
            stringify!(rlOsiSemWait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlOsiSemCbs>())).rlOsiSemSignal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlOsiSemCbs),
            "::",
            stringify!(rlOsiSemSignal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlOsiSemCbs>())).rlOsiSemDelete as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlOsiSemCbs),
            "::",
            stringify!(rlOsiSemDelete)
        )
    );
}
pub type rlOsiSemCbs_t = rlOsiSemCbs;
#[doc = " \\brief"]
#[doc = " OS message queue/Spawn callback functions"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlOsiMsgQCbs {
    #[doc = " @fn rlInt32_t (*rlOsiSpawn)(RL_P_OSI_SPAWN_ENTRY pEntry, void* pValue, rlUInt32_t flags)"]
    #[doc = ""]
    #[doc = "   @brief Calls a function in a different context"]
    #[doc = "   @param[in] pEntry - Pointer to Entry Function"]
    #[doc = "   @param[in] pValue - Pointer to data passed to function"]
    #[doc = "   @param[in] flags  - Flag to indicate preference"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   Calls a function in a different context. mmWaveLink Driver Interrupt handler function"]
    #[doc = "   invokes this interface to switch context so that Interrupt Service Routine is executed"]
    #[doc = "   immediately. mmWaveLink uses this callback function to invoke 'rlDriverMsgReadSpawnCtx'"]
    #[doc = "   funtion to read the async-event message in different interrupt context. Host should"]
    #[doc = "   able to handle the error code generated by 'rlDriverMsgReadSpawnCtx' spawned function."]
    pub rlOsiSpawn: ::core::option::Option<
        unsafe extern "C" fn(
            pEntry: RL_P_OSI_SPAWN_ENTRY,
            pValue: *const cty::c_void,
            flags: rlUInt32_t,
        ) -> rlInt32_t,
    >,
}
#[test]
fn bindgen_test_layout_rlOsiMsgQCbs() {
    assert_eq!(
        ::core::mem::size_of::<rlOsiMsgQCbs>(),
        4usize,
        concat!("Size of: ", stringify!(rlOsiMsgQCbs))
    );
    assert_eq!(
        ::core::mem::align_of::<rlOsiMsgQCbs>(),
        4usize,
        concat!("Alignment of ", stringify!(rlOsiMsgQCbs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlOsiMsgQCbs>())).rlOsiSpawn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlOsiMsgQCbs),
            "::",
            stringify!(rlOsiSpawn)
        )
    );
}
pub type rlOsiMsgQCbs_t = rlOsiMsgQCbs;
#[doc = " \\brief"]
#[doc = " OS services callback functions"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlOsiCbs {
    #[doc = " \\brief"]
    #[doc = " Mutex callback functions."]
    pub mutex: rlOsiMutexCbs_t,
    #[doc = " \\brief"]
    #[doc = " Semaphore callback functions."]
    pub sem: rlOsiSemCbs_t,
    #[doc = " \\brief"]
    #[doc = " OS message queue/Spawn callback functions."]
    pub queue: rlOsiMsgQCbs_t,
}
#[test]
fn bindgen_test_layout_rlOsiCbs() {
    assert_eq!(
        ::core::mem::size_of::<rlOsiCbs>(),
        36usize,
        concat!("Size of: ", stringify!(rlOsiCbs))
    );
    assert_eq!(
        ::core::mem::align_of::<rlOsiCbs>(),
        4usize,
        concat!("Alignment of ", stringify!(rlOsiCbs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlOsiCbs>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlOsiCbs),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlOsiCbs>())).sem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlOsiCbs),
            "::",
            stringify!(sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlOsiCbs>())).queue as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rlOsiCbs),
            "::",
            stringify!(queue)
        )
    );
}
pub type rlOsiCbs_t = rlOsiCbs;
#[doc = " \\brief"]
#[doc = " mmWaveLink Asynchronous event callback function"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlEventCbs {
    #[doc = " @fn void (*rlAsyncEvent)(rlUInt8_t devIndex, rlUInt16_t sbId, rlUInt16_t sbLen,"]
    #[doc = "                            rlUInt8_t *payload)"]
    #[doc = ""]
    #[doc = "   @brief Reports Asynchronous events from mmwave radar device such as"]
    #[doc = "   device status, exceptions etc"]
    #[doc = "   @param[in] devIndex - Device Index to identify source of event"]
    #[doc = "   @param[in] subId -  Sub-block Id"]
    #[doc = "   @param[in] subLen -  Sub-block data length"]
    #[doc = "   @param[in] payload - Sub-block data starting memory address"]
    #[doc = ""]
    #[doc = "   Reports Asynchronous events from mmwave radar device such as"]
    #[doc = "   device status, exceptions etc"]
    pub rlAsyncEvent: ::core::option::Option<
        unsafe extern "C" fn(
            devIndex: rlUInt8_t,
            subId: rlUInt16_t,
            subLen: rlUInt16_t,
            payload: *mut rlUInt8_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_rlEventCbs() {
    assert_eq!(
        ::core::mem::size_of::<rlEventCbs>(),
        4usize,
        concat!("Size of: ", stringify!(rlEventCbs))
    );
    assert_eq!(
        ::core::mem::align_of::<rlEventCbs>(),
        4usize,
        concat!("Alignment of ", stringify!(rlEventCbs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlEventCbs>())).rlAsyncEvent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlEventCbs),
            "::",
            stringify!(rlAsyncEvent)
        )
    );
}
pub type rlEventCbs_t = rlEventCbs;
#[doc = " \\brief"]
#[doc = " mmWaveLink Timer callback functions"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlTimerCbs {
    pub rlDelay: ::core::option::Option<unsafe extern "C" fn(delay: rlUInt32_t) -> rlInt32_t>,
}
#[test]
fn bindgen_test_layout_rlTimerCbs() {
    assert_eq!(
        ::core::mem::size_of::<rlTimerCbs>(),
        4usize,
        concat!("Size of: ", stringify!(rlTimerCbs))
    );
    assert_eq!(
        ::core::mem::align_of::<rlTimerCbs>(),
        4usize,
        concat!("Alignment of ", stringify!(rlTimerCbs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTimerCbs>())).rlDelay as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTimerCbs),
            "::",
            stringify!(rlDelay)
        )
    );
}
pub type rlTimerCbs_t = rlTimerCbs;
#[doc = " \\brief"]
#[doc = " mmWaveLink callback functions for Command parser"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlCmdParserCbs {
    pub rlCmdParser: ::core::option::Option<
        unsafe extern "C" fn(rxMsgClass: rlUInt8_t, inVal: rlInt32_t) -> rlInt32_t,
    >,
    pub rlPostCnysStep:
        ::core::option::Option<unsafe extern "C" fn(devIndex: rlUInt8_t) -> rlInt32_t>,
}
#[test]
fn bindgen_test_layout_rlCmdParserCbs() {
    assert_eq!(
        ::core::mem::size_of::<rlCmdParserCbs>(),
        8usize,
        concat!("Size of: ", stringify!(rlCmdParserCbs))
    );
    assert_eq!(
        ::core::mem::align_of::<rlCmdParserCbs>(),
        4usize,
        concat!("Alignment of ", stringify!(rlCmdParserCbs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCmdParserCbs>())).rlCmdParser as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCmdParserCbs),
            "::",
            stringify!(rlCmdParser)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCmdParserCbs>())).rlPostCnysStep as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCmdParserCbs),
            "::",
            stringify!(rlPostCnysStep)
        )
    );
}
pub type rlCmdParserCbs_t = rlCmdParserCbs;
#[doc = " \\brief"]
#[doc = " mmWaveLink CRC callback function"]
#[doc = " @note : Device SPI protocol Limitation for AWR1243: The CRC length of the message"]
#[doc = " or Async-event shall be multiple of 4 bytes to enable reliable retry recovery"]
#[doc = " mechanism in case of any checksum failure in a message."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlCrcCbs {
    #[doc = " @fn rlInt32_t (*rlComputeCRC)(rlUInt8_t* data, rlUInt32_t dataLen, rlUInt8_t crcType,"]
    #[doc = "                  rlUInt8_t* crc)"]
    #[doc = ""]
    #[doc = "   @brief Compute CRC on the input message"]
    #[doc = "   @param[in] data - input message"]
    #[doc = "   @param[in] dataLen - size of input message in bytes"]
    #[doc = "   @param[in] crcType  - CRC type (0:RL_CRC_TYPE_16BIT_CCITT, 1:RL_CRC_TYPE_32BIT,"]
    #[doc = "                         2:RL_CRC_TYPE_64BIT_ISO)"]
    #[doc = "   @param[out] crc   - Computed CRC"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   Compute CRC on the input message"]
    pub rlComputeCRC: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut rlUInt8_t,
            dataLen: rlUInt32_t,
            crcType: rlUInt8_t,
            crc: *mut rlUInt8_t,
        ) -> rlInt32_t,
    >,
}
#[test]
fn bindgen_test_layout_rlCrcCbs() {
    assert_eq!(
        ::core::mem::size_of::<rlCrcCbs>(),
        4usize,
        concat!("Size of: ", stringify!(rlCrcCbs))
    );
    assert_eq!(
        ::core::mem::align_of::<rlCrcCbs>(),
        4usize,
        concat!("Alignment of ", stringify!(rlCrcCbs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCrcCbs>())).rlComputeCRC as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCrcCbs),
            "::",
            stringify!(rlComputeCRC)
        )
    );
}
pub type rlCrcCbs_t = rlCrcCbs;
#[doc = " \\brief"]
#[doc = " mmWaveLink Device Control, Interrupt callback functions"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDeviceCtrlCbs {
    #[doc = " @fn rlInt32_t (*rlDeviceEnable)(rlUInt8_t deviceIndex)"]
    #[doc = ""]
    #[doc = "   @brief Bring mmWave radar device out of Reset"]
    #[doc = "   @param[in] deviceIndex -  Index of the device to be enabled"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   Bring mmWave radar device out of Reset. Implement this function to assert the nReset"]
    #[doc = "   Pin in mmWave device. Optionally It might require to assert Sense on Power(SOP) Pins"]
    pub rlDeviceEnable:
        ::core::option::Option<unsafe extern "C" fn(deviceIndex: rlUInt8_t) -> rlInt32_t>,
    #[doc = " @fn rlInt32_t (*rlDeviceDisable)(rlUInt8_t deviceIndex)"]
    #[doc = ""]
    #[doc = "   @brief Power off mmWave radar device"]
    #[doc = "   @param[in] deviceIndex -  Index of the device to be disbaled"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   Power off mmWave radar device. Implement this function to de-assert the Reset"]
    #[doc = "   Pin in mmWave device"]
    pub rlDeviceDisable:
        ::core::option::Option<unsafe extern "C" fn(deviceIndex: rlUInt8_t) -> rlInt32_t>,
    #[doc = " @fn void (*rlDeviceMaskHostIrq)(rlComIfHdl_t fd)"]
    #[doc = ""]
    #[doc = "   @brief Masks Host Interrupt"]
    #[doc = "   @param[in] fd -  Handle of the device for which interrupt need to be masked"]
    #[doc = ""]
    #[doc = "   Masks Host Interrupt. If GPIO Interrupt is Level Triggered,"]
    #[doc = "   host need to mask the interrupt until the interrupt is serviced"]
    pub rlDeviceMaskHostIrq: ::core::option::Option<unsafe extern "C" fn(fd: rlComIfHdl_t)>,
    #[doc = " @fn void (*rlDeviceUnMaskHostIrq)(rlComIfHdl_t fd)"]
    #[doc = ""]
    #[doc = "   @brief Unmask Host Interrupt"]
    #[doc = "   @param[in] fd -  Handle of the device for which interrupt need to be unmasked"]
    #[doc = ""]
    #[doc = "   Unmask Host Interrupt. If GPIO Interrupt is Level Triggered,"]
    #[doc = "   host need to unmask the interrupt once interrupt is processed"]
    pub rlDeviceUnMaskHostIrq: ::core::option::Option<unsafe extern "C" fn(fd: rlComIfHdl_t)>,
    #[doc = " @fn rlInt32_t (*rlDeviceWaitIrqStatus)(rlComIfHdl_t fd, rlUInt8_t highLow)"]
    #[doc = ""]
    #[doc = "   @brief Polls Host Interrupt Status"]
    #[doc = "   @param[in] fd -  Handle of the device for which interrupt need to be polled"]
    #[doc = "   @param[in] highLow - Wait for IRQ Level(high/low)"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t IRQ Line Low - 0, IRQ Line High - 1"]
    #[doc = ""]
    #[doc = "   mmWave Radar device asserts host IRQ pin to get Host attention. After receiving host"]
    #[doc = "   interrupt, host polls Host Interrupt Status, Low on Host IRQ indicate that mmWave device"]
    #[doc = "   has written data on communication Interface. This callback should Wait for the IRQ status."]
    #[doc = "   The function waits for the IRQ Level(low/high) based on second argument returns once the"]
    #[doc = "   IRQ Level occurs. If HostIRQ is not toggled within timeout (less than ackTimeout), it"]
    #[doc = "   should return '-1' value so that it won't be blocked for infinite duration."]
    pub rlDeviceWaitIrqStatus: ::core::option::Option<
        unsafe extern "C" fn(fd: rlComIfHdl_t, highLow: rlUInt8_t) -> rlInt32_t,
    >,
    #[doc = " @fn rlUInt16_t (*rlCommIfAssertIrq)(rlUInt8_t highLow)"]
    #[doc = ""]
    #[doc = "   @brief It assert/de-assert Host IRQ hig/low on MSS to Host for SPI communication"]
    #[doc = "   @param[in] highLow - High/low value for Host IRQ"]
    #[doc = ""]
    #[doc = "   @return rlUInt16_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   It assert/de-assert Host IRQ hig/low on MSS to Host for SPI communication"]
    pub rlCommIfAssertIrq:
        ::core::option::Option<unsafe extern "C" fn(highLow: rlUInt8_t) -> rlUInt16_t>,
    #[doc = " @fn rlInt32_t (*rlRegisterInterruptHandler)(rlUInt8_t deviceIndex,"]
    #[doc = "                                               RL_P_EVENT_HANDLER pHandler, void* pValue)"]
    #[doc = ""]
    #[doc = "   @brief Register Host Interrupt Handler"]
    #[doc = "   @param[in] deviceIndex - Device Index to identify source of Host Interrupt"]
    #[doc = "   @param[in] pHandler - Interrupt Handler routine"]
    #[doc = "   @param[in] pValue   - To Pass any additional data"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success - 0, Failure - Error code"]
    #[doc = ""]
    #[doc = "   Register Host Interrupt Handler. The Application should store this function handler"]
    #[doc = "   and invoke when it receives host Interrupt. The application need to enable GPIO interrupt"]
    #[doc = "   in this callback. Event Handler Callback doesn't process the interrupt in the same context"]
    #[doc = "   so it is safe to call this handler from ISR directly."]
    pub rlRegisterInterruptHandler: ::core::option::Option<
        unsafe extern "C" fn(
            deviceIndex: rlUInt8_t,
            pHandler: RL_P_EVENT_HANDLER,
            pValue: *mut cty::c_void,
        ) -> rlInt32_t,
    >,
}
#[test]
fn bindgen_test_layout_rlDeviceCtrlCbs() {
    assert_eq!(
        ::core::mem::size_of::<rlDeviceCtrlCbs>(),
        28usize,
        concat!("Size of: ", stringify!(rlDeviceCtrlCbs))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDeviceCtrlCbs>(),
        4usize,
        concat!("Alignment of ", stringify!(rlDeviceCtrlCbs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDeviceCtrlCbs>())).rlDeviceEnable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDeviceCtrlCbs),
            "::",
            stringify!(rlDeviceEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDeviceCtrlCbs>())).rlDeviceDisable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDeviceCtrlCbs),
            "::",
            stringify!(rlDeviceDisable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDeviceCtrlCbs>())).rlDeviceMaskHostIrq as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDeviceCtrlCbs),
            "::",
            stringify!(rlDeviceMaskHostIrq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDeviceCtrlCbs>())).rlDeviceUnMaskHostIrq as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDeviceCtrlCbs),
            "::",
            stringify!(rlDeviceUnMaskHostIrq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDeviceCtrlCbs>())).rlDeviceWaitIrqStatus as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDeviceCtrlCbs),
            "::",
            stringify!(rlDeviceWaitIrqStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDeviceCtrlCbs>())).rlCommIfAssertIrq as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDeviceCtrlCbs),
            "::",
            stringify!(rlCommIfAssertIrq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDeviceCtrlCbs>())).rlRegisterInterruptHandler as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDeviceCtrlCbs),
            "::",
            stringify!(rlRegisterInterruptHandler)
        )
    );
}
pub type rlDeviceCtrlCbs_t = rlDeviceCtrlCbs;
#[doc = " \\brief"]
#[doc = " mmWaveLink print function prototype"]
pub type rlPrintFptr =
    ::core::option::Option<unsafe extern "C" fn(format: *const rlInt8_t, ...) -> rlInt32_t>;
#[doc = " \\brief"]
#[doc = " mmWaveLink debug callback structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDbgCb {
    #[doc = " @fn rlInt32_t (*rlPrint)(const rlInt8_t* format, ...)"]
    #[doc = ""]
    #[doc = "   @brief Print input message as per the format in the input arguments"]
    #[doc = "   @param[in] format  - Format of message and arguments to be printed"]
    #[doc = "   @param[in] ...     - Multiple input arguments to be printed"]
    #[doc = ""]
    #[doc = "   @return rlInt32_t Success- Length of the message written in user's output console in bytes"]
    #[doc = "                     Failure- Negative value"]
    #[doc = ""]
    #[doc = "   Print input message as per the format in the input arguments"]
    pub rlPrint: rlPrintFptr,
    #[doc = " @brief User needs to set debug level such as error, warning, debug, verbose"]
    pub dbgLevel: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlDbgCb() {
    assert_eq!(
        ::core::mem::size_of::<rlDbgCb>(),
        8usize,
        concat!("Size of: ", stringify!(rlDbgCb))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDbgCb>(),
        4usize,
        concat!("Alignment of ", stringify!(rlDbgCb))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDbgCb>())).rlPrint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDbgCb),
            "::",
            stringify!(rlPrint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDbgCb>())).dbgLevel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDbgCb),
            "::",
            stringify!(dbgLevel)
        )
    );
}
pub type rlDbgCb_t = rlDbgCb;
#[doc = " \\brief"]
#[doc = " mmWaveLink client callback structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlClientCbs {
    #[doc = " @brief  Comunication Interface Callback"]
    pub comIfCb: rlComIfCbs_t,
    #[doc = " @brief  Operating System Callback"]
    pub osiCb: rlOsiCbs_t,
    #[doc = " @brief  Event Callback, required to receive notification"]
    pub eventCb: rlEventCbs_t,
    #[doc = " @brief  Device Control Callback"]
    pub devCtrlCb: rlDeviceCtrlCbs_t,
    #[doc = " @brief  Timer Callback, required when ACK is enabled"]
    pub timerCb: rlTimerCbs_t,
    #[doc = " @brief Call back for parsing the Command received at MSS from the Host"]
    #[doc = "TI Internal Use only"]
    pub cmdParserCb: rlCmdParserCbs_t,
    #[doc = " @brief  CRC Callback, required when CRC is enabled"]
    pub crcCb: rlCrcCbs_t,
    #[doc = " @brief  CRC Types rlCrcType_t 16/32/64"]
    pub crcType: rlCrcType_t,
    #[doc = " @brief  ACK wait timeout in Milliseconds, 0 - No ACK"]
    #[doc = "Configuration of the timeout should consider interrupt"]
    #[doc = "latency in the processor."]
    pub ackTimeout: rlUInt32_t,
    #[doc = " @brief  0x0: mmWaveLink runs on Ext Host, \\n"]
    #[doc = "0x1: mmWaveLink runs on MSS, \\n"]
    #[doc = "0x2: mmWaveLink runs on DSS  \\n"]
    pub platform: rlUInt8_t,
    #[doc = " @brief  xWR1243 + HOST = 0x0, xWR1443 MSS = 0x1, xWR1642 MSS/DSS = 0x2, \\n"]
    #[doc = "xWR1843 MSS/DSS = 0x3, xWR6843 MSS/DSS = 0x4 \\n"]
    pub arDevType: rlUInt8_t,
    #[doc = " @brief  Debug Callback, required to receive Debug information"]
    pub dbgCb: rlDbgCb_t,
}
#[test]
fn bindgen_test_layout_rlClientCbs() {
    assert_eq!(
        ::core::mem::size_of::<rlClientCbs>(),
        120usize,
        concat!("Size of: ", stringify!(rlClientCbs))
    );
    assert_eq!(
        ::core::mem::align_of::<rlClientCbs>(),
        4usize,
        concat!("Alignment of ", stringify!(rlClientCbs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlClientCbs>())).comIfCb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlClientCbs),
            "::",
            stringify!(comIfCb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlClientCbs>())).osiCb as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlClientCbs),
            "::",
            stringify!(osiCb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlClientCbs>())).eventCb as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rlClientCbs),
            "::",
            stringify!(eventCb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlClientCbs>())).devCtrlCb as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rlClientCbs),
            "::",
            stringify!(devCtrlCb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlClientCbs>())).timerCb as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rlClientCbs),
            "::",
            stringify!(timerCb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlClientCbs>())).cmdParserCb as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rlClientCbs),
            "::",
            stringify!(cmdParserCb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlClientCbs>())).crcCb as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rlClientCbs),
            "::",
            stringify!(crcCb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlClientCbs>())).crcType as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(rlClientCbs),
            "::",
            stringify!(crcType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlClientCbs>())).ackTimeout as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rlClientCbs),
            "::",
            stringify!(ackTimeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlClientCbs>())).platform as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(rlClientCbs),
            "::",
            stringify!(platform)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlClientCbs>())).arDevType as *const _ as usize },
        109usize,
        concat!(
            "Offset of field: ",
            stringify!(rlClientCbs),
            "::",
            stringify!(arDevType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlClientCbs>())).dbgCb as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rlClientCbs),
            "::",
            stringify!(dbgCb)
        )
    );
}
pub type rlClientCbs_t = rlClientCbs;
#[doc = " \\brief"]
#[doc = " mmWaveLink Init Complete data structure for event RL_DEV_AE_MSSPOWERUPDONE_SB"]
#[doc = " @note : The functional APIs shall be sent to radar device only after receiving"]
#[doc = "         RL_DEV_AE_MSSPOWERUPDONE_SB Async-event after power cycle."]
#[doc = "         In case of boot over SPI then functional APIs shall be sent to radar device only after"]
#[doc = "         receiving AWR_AE_MSS_BOOTERRORSTATUS_SB Async-event."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlInitComplete {
    #[doc = " @brief  masterSS powerup time, 1LSB = 5ns"]
    pub powerUpTime: rlUInt32_t,
    #[doc = " @brief  masterSS Bootup Status over SPI, 0 - PASS, 1- Fail \\n"]
    #[doc = "Bit   Error-description                                    \\n"]
    #[doc = "0     certificate authentication failure                   \\n"]
    #[doc = "1     certificate parser failure                           \\n"]
    #[doc = "2     Rprc image1 authentication failure                   \\n"]
    #[doc = "3     Rprc image2 authentication failure                   \\n"]
    #[doc = "4     Rprc image3 authentication failure                   \\n"]
    #[doc = "5     Rprc header not found                                \\n"]
    #[doc = "6     Meta header not found                                \\n"]
    #[doc = "7     S/W anti roll back check failure                     \\n"]
    #[doc = "8     Efuse integrity failure                              \\n"]
    #[doc = "9     certificate field validity failure                   \\n"]
    #[doc = "10    certificate field invalid authentication key index   \\n"]
    #[doc = "11    certificate field invalid hash type                  \\n"]
    #[doc = "12    certificate field invalid subsystem                  \\n"]
    #[doc = "13    certificate field invalid decrypt key index          \\n"]
    #[doc = "14    certificate field check efuse mismatch               \\n"]
    #[doc = "15    certificate field check 1 efuse mismatch             \\n"]
    #[doc = "16    certificate field check 2 efuse mismatch             \\n"]
    #[doc = "17    certificate field invalid subsystem bank allocation  \\n"]
    #[doc = "18    certificate field invalid total banks allocation     \\n"]
    #[doc = "19    Rprc parser file length mismatch                     \\n"]
    #[doc = "20    Rprc parser MSS file offset mismatch                 \\n"]
    #[doc = "21    Rprc parser BSS file offset mismatch                 \\n"]
    #[doc = "22    Rprc parser DSS file offset mismatch                 \\n"]
    #[doc = "23    certificate field invalid decrypt key                \\n"]
    #[doc = "24    certificate field invalid authentication key         \\n"]
    #[doc = "25    HS device certificate not present                    \\n"]
    #[doc = "26    Error in 2K image                                    \\n"]
    #[doc = "27    Shared memory allocation failed                      \\n"]
    #[doc = "28    MSS image not found                                  \\n"]
    #[doc = "29    Meta header num files error                          \\n"]
    #[doc = "30    Meta header CRC failure                              \\n"]
    #[doc = "31    Rprc image authentication failure                    \\n"]
    pub powerUpStatus1: rlUInt32_t,
    #[doc = " @brief  masterSS Bootup Status over SPI, 0 - PASS, 1- Fail \\n"]
    #[doc = "Bit   Error-description                                    \\n"]
    #[doc = "0     Rprc parser config file offset mismatch              \\n"]
    #[doc = "1     Boot extension extraction failure                    \\n"]
    #[doc = "2     Device user ID bad size                              \\n"]
    #[doc = "3     Key derived function bad size                        \\n"]
    #[doc = "4     HMAC bad size                                        \\n"]
    #[doc = "5     AES initialization vector bad size                   \\n"]
    #[doc = "6     Secure dev TI key erase failure                      \\n"]
    #[doc = "7     SOP5 SFlash not found                                \\n"]
    #[doc = "16    XTAL clock detection failure                         \\n"]
    #[doc = "17    Continue bootup on XTAL                              \\n"]
    #[doc = "18    DSP powerup timeout error                            \\n"]
    #[doc = "19    MSS LBIST failure                                    \\n"]
    #[doc = "20    DSP LBIST PBIST failure                              \\n"]
    #[doc = "21    PBIST single port memory failure                     \\n"]
    #[doc = "22    PBIST two port memory failure                        \\n"]
    #[doc = "23    Memory init failure                                  \\n"]
    #[doc = "24    MSS ROM PBIST CRC computation failure                \\n"]
    #[doc = "25    VMON error detected                                  \\n"]
    #[doc = "31    ESM NERROR detected                                  \\n"]
    pub powerUpStatus2: rlUInt32_t,
    #[doc = " @brief  masterSS Boot Test Status, 0 - PASS, 1 - FAIL \\n"]
    #[doc = "Bit      Status Information                      \\n"]
    #[doc = "0        MibSPI self-test                        \\n"]
    #[doc = "1        DMA self-test                           \\n"]
    #[doc = "2        RESERVED                                \\n"]
    #[doc = "3        RTI self-test                           \\n"]
    #[doc = "4        ESM self-test                           \\n"]
    #[doc = "5        EDMA self-test                          \\n"]
    #[doc = "6        CRC self-test                           \\n"]
    #[doc = "7        VIM self-test                           \\n"]
    #[doc = "8        MPU self-test                           \\n"]
    #[doc = "9        Mailbox self-test                       \\n"]
    #[doc = "10       RESERVED                                \\n"]
    #[doc = "11       RESERVED                                \\n"]
    #[doc = "12       RESERVED                                \\n"]
    #[doc = "13       MibSPI single bit error test            \\n"]
    #[doc = "14       MibSPI double bit error test            \\n"]
    #[doc = "15       DMA Parity error test                   \\n"]
    #[doc = "16       TCMA Single bit error test              \\n"]
    #[doc = "17       TCMB Single bit error test              \\n"]
    #[doc = "18       RESERVED                                \\n"]
    #[doc = "19       RESERVED                                \\n"]
    #[doc = "20       RESERVED                                \\n"]
    #[doc = "21       RESERVED                                \\n"]
    #[doc = "22       VIM lockstep test                       \\n"]
    #[doc = "23       CCM R4 lockstep test                    \\n"]
    #[doc = "24       DMA MPU region test                     \\n"]
    #[doc = "25       MSS Mailbox single bit error test       \\n"]
    #[doc = "26       MSS Mailbox double bit error test       \\n"]
    #[doc = "27       BSS Mailbox single bit error test       \\n"]
    #[doc = "28       BSS Mailbox double bit error test       \\n"]
    #[doc = "29       EDMA MPU test                           \\n"]
    #[doc = "30       EDMA parity test                        \\n"]
    #[doc = "31       RESERVED                                \\n"]
    pub bootTestStatus1: rlUInt32_t,
    #[doc = " @brief  masterSS Boot Test Status, 0 - PASS, 1 - FAIL \\n"]
    #[doc = "Bit      Status Information                      \\n"]
    #[doc = "0        RESERVED                                \\n"]
    #[doc = "1        RESERVED                                \\n"]
    #[doc = "2        PCR test                                \\n"]
    #[doc = "3        VIM RAM parity test                     \\n"]
    #[doc = "4        SCI boot time test                      \\n"]
    #[doc = "31:5     RESERVED                                \\n"]
    pub bootTestStatus2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlInitComplete() {
    assert_eq!(
        ::core::mem::size_of::<rlInitComplete>(),
        20usize,
        concat!("Size of: ", stringify!(rlInitComplete))
    );
    assert_eq!(
        ::core::mem::align_of::<rlInitComplete>(),
        4usize,
        concat!("Alignment of ", stringify!(rlInitComplete))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlInitComplete>())).powerUpTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInitComplete),
            "::",
            stringify!(powerUpTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlInitComplete>())).powerUpStatus1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInitComplete),
            "::",
            stringify!(powerUpStatus1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlInitComplete>())).powerUpStatus2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInitComplete),
            "::",
            stringify!(powerUpStatus2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlInitComplete>())).bootTestStatus1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInitComplete),
            "::",
            stringify!(bootTestStatus1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlInitComplete>())).bootTestStatus2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInitComplete),
            "::",
            stringify!(bootTestStatus2)
        )
    );
}
pub type rlInitComplete_t = rlInitComplete;
#[doc = " \\brief"]
#[doc = " mmWaveLink RF Start Complete data structure for event RL_DEV_AE_RFPOWERUPDONE_SB"]
#[doc = " @note : Bootup digital monitoring status are not applicable for QM devices"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlStartComplete {
    #[doc = " @brief  radarSS Boot Status, 1 - PASS, 0 - FAIL  \\n"]
    #[doc = "Bit Status Information                   \\n"]
    #[doc = "0    ROM CRC check                       \\n"]
    #[doc = "1    CR4 and VIM lockstep test           \\n"]
    #[doc = "2    RESERVED                            \\n"]
    #[doc = "3    VIM test (Not supported in 1st Gen devices, refer latest release note) \\n"]
    #[doc = "4    STC test of diagnostic              \\n"]
    #[doc = "5    CR4 STC                             \\n"]
    #[doc = "6    CRC test                            \\n"]
    #[doc = "7    RAMPGEN memory ECC test             \\n"]
    #[doc = "8    DFE Parity test (RESERVED in xWR6x43 devices) \\n"]
    #[doc = "9    DFE memory ECC                      \\n"]
    #[doc = "10   RAMPGEN lockstep test               \\n"]
    #[doc = "11   FRC lockstep test                   \\n"]
    #[doc = "12   DFE memory PBIST                    \\n"]
    #[doc = "13   RAMPGEN memory PBIST                \\n"]
    #[doc = "14   PBIST test                          \\n"]
    #[doc = "15   WDT test                            \\n"]
    #[doc = "16   ESM test                            \\n"]
    #[doc = "17   DFE STC                             \\n"]
    #[doc = "18   RESERVED                            \\n"]
    #[doc = "19   ATCM, BTCM ECC test                 \\n"]
    #[doc = "20   ATCM, BTCM parity test              \\n"]
    #[doc = "21   RESERVED                            \\n"]
    #[doc = "22   RESERVED                            \\n"]
    #[doc = "23   RESERVED                            \\n"]
    #[doc = "24   FFT test                            \\n"]
    #[doc = "25   RTI test                            \\n"]
    #[doc = "26   PCR test                            \\n"]
    #[doc = "27-31 RESERVED"]
    pub status: rlUInt32_t,
    #[doc = " @brief  radarSS powerup time, 1LSB = 5ns"]
    pub powerUpTime: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlStartComplete() {
    assert_eq!(
        ::core::mem::size_of::<rlStartComplete>(),
        16usize,
        concat!("Size of: ", stringify!(rlStartComplete))
    );
    assert_eq!(
        ::core::mem::align_of::<rlStartComplete>(),
        4usize,
        concat!("Alignment of ", stringify!(rlStartComplete))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlStartComplete>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlStartComplete),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlStartComplete>())).powerUpTime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlStartComplete),
            "::",
            stringify!(powerUpTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlStartComplete>())).reserved0 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlStartComplete),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlStartComplete>())).reserved1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlStartComplete),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlStartComplete_t = rlStartComplete;
#[doc = " \\brief"]
#[doc = " Structure to hold the MSS ESM Fault data structure for event RL_DEV_AE_MSS_ESMFAULT_SB"]
#[doc = " @note : The FRC lockstep fatal error(BSS module error) is connected to MSS ESM Group 1 lines,"]
#[doc = "         This fatal error must be handled in Host in AWR1243 device (MSS or DSS in xWR1642,"]
#[doc = "         xWR1843 and xWR6843 devices)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMssEsmFault {
    #[doc = " @brief  Bits Definition (0 -- No Error , 1 -- ESM Error)"]
    #[doc = "0  NERROR in sync \\n"]
    #[doc = "1  RESERVED \\n"]
    #[doc = "2  DMA MPU Region tests \\n"]
    #[doc = "3  DMA Parity error \\n"]
    #[doc = "4  RESERVED \\n"]
    #[doc = "5  RESERVED \\n"]
    #[doc = "6  DSS CSI parity error \\n"]
    #[doc = "7  TPCC parity error \\n"]
    #[doc = "8  CBUF ECC single bit error \\n"]
    #[doc = "9  CBUF ECC double bit error \\n"]
    #[doc = "10 RESERVED \\n"]
    #[doc = "11 RESERVED \\n"]
    #[doc = "12 RESERVED \\n"]
    #[doc = "13 Error response from the Peripheral when a DMA transfer is done \\n"]
    #[doc = "14 RESERVED \\n"]
    #[doc = "15 VIM RAM double bit errors \\n"]
    #[doc = "16 RESERVED \\n"]
    #[doc = "17 MibSPI double bit error test \\n"]
    #[doc = "18 DSS TPTC0 read MPU error \\n"]
    #[doc = "19 RESERVED \\n"]
    #[doc = "20 VIM RAM single bit errors \\n"]
    #[doc = "21 RESERVED \\n"]
    #[doc = "22 FRC Lockstep error \\n"]
    #[doc = "23 RESERVED \\n"]
    #[doc = "24 RESERVED \\n"]
    #[doc = "25 MibSPI single bit error test \\n"]
    #[doc = "26 TCMB0 RAM single bit errors \\n"]
    #[doc = "27 STC error \\n"]
    #[doc = "28 TCMB1 RAM single bit errors \\n"]
    #[doc = "29 DSS TPTC0 write MPU error \\n"]
    #[doc = "30 DCC compare error \\n"]
    #[doc = "31 CR4F self-test error.(test of error path by error forcing)  \\n"]
    pub esmGrp1Err: rlUInt32_t,
    #[doc = " @brief  Bits Definition \\n"]
    #[doc = "0  TCMA RAM single bit errors \\n"]
    #[doc = "1  RESERVED \\n"]
    #[doc = "2  RESERVED \\n"]
    #[doc = "3  DSS TPTC1 read MPU error \\n"]
    #[doc = "4  DSS TPTC1 write MPU error \\n"]
    #[doc = "5  RESERVED \\n"]
    #[doc = "6  Access error interrupt from FFT ACC \\n"]
    #[doc = "7  VIM Self-Test Error \\n"]
    #[doc = "8  RESERVED \\n"]
    #[doc = "9  RESERVED \\n"]
    #[doc = "10 RESERVED \\n"]
    #[doc = "11 RESERVED \\n"]
    #[doc = "12 RESERVED \\n"]
    #[doc = "13 RESERVED \\n"]
    #[doc = "14 RESERVED \\n"]
    #[doc = "15 RESERVED \\n"]
    #[doc = "16 RESERVED \\n"]
    #[doc = "17 RESERVED \\n"]
    #[doc = "18 RESERVED \\n"]
    #[doc = "19 RESERVED \\n"]
    #[doc = "20 RESERVED \\n"]
    #[doc = "21 RESERVED \\n"]
    #[doc = "22 RESERVED \\n"]
    #[doc = "23 RESERVED \\n"]
    #[doc = "24 RESERVED \\n"]
    #[doc = "25 radarSS to MSS ESM G2 Trigger \\n"]
    #[doc = "26 radarSS Mailbox single bit errors \\n"]
    #[doc = "27 radarSS Mailbox double bit errors \\n"]
    #[doc = "28 MSS Mailbox single bit errors \\n"]
    #[doc = "29 MSS Mailbox double bit errors \\n"]
    #[doc = "30 RESERVED \\n"]
    #[doc = "31 RESERVED \\n"]
    pub esmGrp2Err: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMssEsmFault() {
    assert_eq!(
        ::core::mem::size_of::<rlMssEsmFault>(),
        16usize,
        concat!("Size of: ", stringify!(rlMssEsmFault))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMssEsmFault>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMssEsmFault))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMssEsmFault>())).esmGrp1Err as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssEsmFault),
            "::",
            stringify!(esmGrp1Err)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMssEsmFault>())).esmGrp2Err as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssEsmFault),
            "::",
            stringify!(esmGrp2Err)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMssEsmFault>())).reserved0 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssEsmFault),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMssEsmFault>())).reserved1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssEsmFault),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlMssEsmFault_t = rlMssEsmFault;
#[doc = " \\brief"]
#[doc = " Structure to hold the MSS Boot error status data strucutre when booted over SPI"]
#[doc = " for event RL_DEV_AE_MSS_BOOTERRSTATUS_SB"]
#[doc = " @note : The functional APIs shall be sent to radar device only after receiving"]
#[doc = "         RL_DEV_AE_MSS_BOOTERRSTATUS_SB Async-event after boot over SPI (Flash is not connected)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMssBootErrStatus {
    #[doc = " @brief  masterSS powerup time, 1LSB = 5ns"]
    pub powerUpTime: rlUInt32_t,
    #[doc = " @brief  masterSS Bootup Status over SPI, 0 - PASS, 1- Fail \\n"]
    #[doc = "Bit   Error-description                                    \\n"]
    #[doc = "0     certificate authentication failure                   \\n"]
    #[doc = "1     certificate parser failure                           \\n"]
    #[doc = "2     Rprc image1 authentication failure                   \\n"]
    #[doc = "3     Rprc image2 authentication failure                   \\n"]
    #[doc = "4     Rprc image3 authentication failure                   \\n"]
    #[doc = "5     Rprc header not found                                \\n"]
    #[doc = "6     Meta header not found                                \\n"]
    #[doc = "7     S/W anti roll back check failure                     \\n"]
    #[doc = "8     Efuse integrity failure                              \\n"]
    #[doc = "9     certificate field validity failure                   \\n"]
    #[doc = "10    certificate field invalid authentication key index   \\n"]
    #[doc = "11    certificate field invalid hash type                  \\n"]
    #[doc = "12    certificate field invalid subsystem                  \\n"]
    #[doc = "13    certificate field invalid decrypt key index          \\n"]
    #[doc = "14    certificate field check efuse mismatch               \\n"]
    #[doc = "15    certificate field check 1 efuse mismatch             \\n"]
    #[doc = "16    certificate field check 2 efuse mismatch             \\n"]
    #[doc = "17    certificate field invalid subsystem bank allocation  \\n"]
    #[doc = "18    certificate field invalid total banks allocation     \\n"]
    #[doc = "19    Rprc parser file length mismatch                     \\n"]
    #[doc = "20    Rprc parser MSS file offset mismatch                 \\n"]
    #[doc = "21    Rprc parser BSS file offset mismatch                 \\n"]
    #[doc = "22    Rprc parser DSS file offset mismatch                 \\n"]
    #[doc = "23    certificate field invalid decrypt key                \\n"]
    #[doc = "24    certificate field invalid authentication key         \\n"]
    #[doc = "25    HS device certificate not present                    \\n"]
    #[doc = "26    Error in 2K image                                    \\n"]
    #[doc = "27    Shared memory allocation failed                      \\n"]
    #[doc = "28    MSS image not found                                  \\n"]
    #[doc = "29    Meta header num files error                          \\n"]
    #[doc = "30    Meta header CRC failure                              \\n"]
    #[doc = "31    Rprc image authentication failure                    \\n"]
    pub powerUpStatus1: rlUInt32_t,
    #[doc = " @brief  masterSS Bootup Status over SPI, 0 - PASS, 1- Fail \\n"]
    #[doc = "Bit   Error-description                                    \\n"]
    #[doc = "0     Rprc parser config file offset mismatch              \\n"]
    #[doc = "1     Boot extension extraction failure                    \\n"]
    #[doc = "2     Device user ID bad size                              \\n"]
    #[doc = "3     Key derived function bad size                        \\n"]
    #[doc = "4     HMAC bad size                                        \\n"]
    #[doc = "5     AES initialization vector bad size                   \\n"]
    #[doc = "6     Secure dev TI key erase failure                      \\n"]
    #[doc = "7     SOP5 SFlash not found                                \\n"]
    #[doc = "16    XTAL clock detection failure                         \\n"]
    #[doc = "17    Continue bootup on XTAL                              \\n"]
    #[doc = "18    DSP powerup timeout error                            \\n"]
    #[doc = "19    MSS LBIST failure                                    \\n"]
    #[doc = "20    DSP LBIST PBIST failure                              \\n"]
    #[doc = "21    PBIST single port memory failure                     \\n"]
    #[doc = "22    PBIST two port memory failure                        \\n"]
    #[doc = "23    Memory init failure                                  \\n"]
    #[doc = "24    MSS ROM PBIST CRC computation failure                \\n"]
    #[doc = "25    VMON error detected                                  \\n"]
    #[doc = "31    ESM NERROR detected                                  \\n"]
    pub powerUpStatus2: rlUInt32_t,
    #[doc = " @brief  masterSS Boot Test Status, 0 - PASS, 1 - FAIL \\n"]
    #[doc = "Bit      Status Information                      \\n"]
    #[doc = "0        MibSPI self-test                        \\n"]
    #[doc = "1        DMA self-test                           \\n"]
    #[doc = "2        RESERVED                                \\n"]
    #[doc = "3        RTI self-test                           \\n"]
    #[doc = "4        ESM self-test                           \\n"]
    #[doc = "5        EDMA self-test                          \\n"]
    #[doc = "6        CRC self-test                           \\n"]
    #[doc = "7        VIM self-test                           \\n"]
    #[doc = "8        MPU self-test                           \\n"]
    #[doc = "9        Mailbox self-test                       \\n"]
    #[doc = "10       RESERVED                                \\n"]
    #[doc = "11       RESERVED                                \\n"]
    #[doc = "12       RESERVED                                \\n"]
    #[doc = "13       MibSPI single bit error test            \\n"]
    #[doc = "14       MibSPI double bit error test            \\n"]
    #[doc = "15       DMA Parity error test                   \\n"]
    #[doc = "16       TCMA Single bit error test              \\n"]
    #[doc = "17       TCMB Single bit error test              \\n"]
    #[doc = "18       RESERVED                                \\n"]
    #[doc = "19       RESERVED                                \\n"]
    #[doc = "20       RESERVED                                \\n"]
    #[doc = "21       RESERVED                                \\n"]
    #[doc = "22       VIM lockstep test                       \\n"]
    #[doc = "23       CCM R4 lockstep test                    \\n"]
    #[doc = "24       DMA MPU region test                     \\n"]
    #[doc = "25       MSS Mailbox single bit error test       \\n"]
    #[doc = "26       MSS Mailbox double bit error test       \\n"]
    #[doc = "27       BSS Mailbox single bit error test       \\n"]
    #[doc = "28       BSS Mailbox double bit error test       \\n"]
    #[doc = "29       EDMA MPU test                           \\n"]
    #[doc = "30       EDMA parity test                        \\n"]
    #[doc = "31       RESERVED                                \\n"]
    pub bootTestStatus1: rlUInt32_t,
    #[doc = " @brief  masterSS Boot Test Status, 0 - PASS, 1 - FAIL \\n"]
    #[doc = "Bit      Status Information                      \\n"]
    #[doc = "0        RESERVED                                \\n"]
    #[doc = "1        RESERVED                                \\n"]
    #[doc = "2        PCR test                                \\n"]
    #[doc = "3        VIM RAM parity test                     \\n"]
    #[doc = "4        SCI boot time test                      \\n"]
    #[doc = "31:5     RESERVED                                \\n"]
    pub bootTestStatus2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMssBootErrStatus() {
    assert_eq!(
        ::core::mem::size_of::<rlMssBootErrStatus>(),
        20usize,
        concat!("Size of: ", stringify!(rlMssBootErrStatus))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMssBootErrStatus>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMssBootErrStatus))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMssBootErrStatus>())).powerUpTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssBootErrStatus),
            "::",
            stringify!(powerUpTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMssBootErrStatus>())).powerUpStatus1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssBootErrStatus),
            "::",
            stringify!(powerUpStatus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMssBootErrStatus>())).powerUpStatus2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssBootErrStatus),
            "::",
            stringify!(powerUpStatus2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMssBootErrStatus>())).bootTestStatus1 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssBootErrStatus),
            "::",
            stringify!(bootTestStatus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMssBootErrStatus>())).bootTestStatus2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssBootErrStatus),
            "::",
            stringify!(bootTestStatus2)
        )
    );
}
pub type rlMssBootErrStatus_t = rlMssBootErrStatus;
#[doc = " \\brief"]
#[doc = " Structure to hold the test status report of the latent fault tests data strucutre"]
#[doc = " for event RL_DEV_AE_MSS_LATENTFLT_TEST_REPORT_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMssLatentFaultReport {
    #[doc = " @brief  1 - PASS, 0 - FAIL \\n"]
    #[doc = "Bits   Definition \\n"]
    #[doc = "0      RESERVED \\n"]
    #[doc = "1      DMA self-test \\n"]
    #[doc = "2      RESERVED \\n"]
    #[doc = "3      RTI self-test \\n"]
    #[doc = "4      RESERVED \\n"]
    #[doc = "5      EDMA self-test \\n"]
    #[doc = "6      CRC self-test \\n"]
    #[doc = "7      VIM self-test \\n"]
    #[doc = "8      RESERVED \\n"]
    #[doc = "9      Mailbox self-test \\n"]
    #[doc = "10     RESERVED \\n"]
    #[doc = "11     RESERVED \\n"]
    #[doc = "12     Generating NERROR \\n"]
    #[doc = "13     MibSPI single bit error test \\n"]
    #[doc = "14     MibSPI double bit error test \\n"]
    #[doc = "15     DMA Parity error \\n"]
    #[doc = "16     TCMA RAM single bit errors (Not supported, refer latest release note) \\n"]
    #[doc = "17     TCMB RAM single bit errors (Not supported, refer latest release note) \\n"]
    #[doc = "18     TCMA RAM double bit errors (Not supported, refer latest release note) \\n"]
    #[doc = "19     TCMB RAM double bit errors (Not supported, refer latest release note) \\n"]
    #[doc = "20     TCMA RAM parity errors (Not supported, refer latest release note) \\n"]
    #[doc = "21     TCMB RAM parity errors (Not supported, refer latest release note) \\n"]
    #[doc = "22     RESERVED \\n"]
    #[doc = "23     RESERVED \\n"]
    #[doc = "24     DMA MPU Region tests \\n"]
    #[doc = "25     MSS Mailbox single bit errors \\n"]
    #[doc = "26     MSS Mailbox double bit errors \\n"]
    #[doc = "27     radarSS Mailbox single bit errors \\n"]
    #[doc = "28     radarSS Mailbox double bit errors \\n"]
    #[doc = "29     EDMA MPU test \\n"]
    #[doc = "30     EDMA parity test \\n"]
    #[doc = "31     CSI2 parity test \\n"]
    pub testStatusFlg1: rlUInt32_t,
    #[doc = " @brief  1 - PASS, 0 - FAIL \\n"]
    #[doc = "Bits   Definition \\n"]
    #[doc = "0      RESERVED \\n"]
    #[doc = "1      RESERVED \\n"]
    #[doc = "2      RESERVED \\n"]
    #[doc = "3      VIM RAM parity test \\n"]
    #[doc = "4      SCI boot time test \\n"]
    #[doc = "31:5   RESERVED \\n"]
    pub testStatusFlg2: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMssLatentFaultReport() {
    assert_eq!(
        ::core::mem::size_of::<rlMssLatentFaultReport>(),
        12usize,
        concat!("Size of: ", stringify!(rlMssLatentFaultReport))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMssLatentFaultReport>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMssLatentFaultReport))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMssLatentFaultReport>())).testStatusFlg1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssLatentFaultReport),
            "::",
            stringify!(testStatusFlg1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMssLatentFaultReport>())).testStatusFlg2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssLatentFaultReport),
            "::",
            stringify!(testStatusFlg2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMssLatentFaultReport>())).reserved as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssLatentFaultReport),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlMssLatentFaultReport_t = rlMssLatentFaultReport;
#[doc = " \\brief"]
#[doc = " Structure to hold data strucutre for test status of the periodic tests"]
#[doc = " for event RL_DEV_AE_MSS_PERIODIC_TEST_STATUS_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMssPeriodicTestStatus {
    #[doc = " @brief  1 - PASS, 0 - FAIL \\n"]
    #[doc = "Bits Definition \\n"]
    #[doc = "0    Periodic read back of static registers \\n"]
    #[doc = "1    ESM self-test \\n"]
    #[doc = "31:2 RESERVED \\n"]
    pub testStatusFlg: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMssPeriodicTestStatus() {
    assert_eq!(
        ::core::mem::size_of::<rlMssPeriodicTestStatus>(),
        8usize,
        concat!("Size of: ", stringify!(rlMssPeriodicTestStatus))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMssPeriodicTestStatus>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMssPeriodicTestStatus))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMssPeriodicTestStatus>())).testStatusFlg as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssPeriodicTestStatus),
            "::",
            stringify!(testStatusFlg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMssPeriodicTestStatus>())).reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssPeriodicTestStatus),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlMssPeriodicTestStatus_t = rlMssPeriodicTestStatus;
#[doc = " \\brief"]
#[doc = " Structure to hold data strucutre for RF-error status send by MSS"]
#[doc = " for event RL_DEV_AE_MSS_RF_ERROR_STATUS_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMssRfErrStatus {
    #[doc = " @brief  Value    Definition \\n"]
    #[doc = "0     No fault \\n"]
    #[doc = "1     radarSS FW assert \\n"]
    #[doc = "2     radarSS FW abort \\n"]
    #[doc = "3     radarSS ESM GROUP1 ERROR \\n"]
    #[doc = "4     radarSS ESM GROUP2 ERROR \\n"]
    #[doc = "6:5   RESERVED \\n"]
    #[doc = "7     BSS monitoring failure in Mode 1(Quiet mode) \\n"]
    #[doc = "31:8  RESERVED \\n"]
    pub errStatusFlg: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMssRfErrStatus() {
    assert_eq!(
        ::core::mem::size_of::<rlMssRfErrStatus>(),
        8usize,
        concat!("Size of: ", stringify!(rlMssRfErrStatus))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMssRfErrStatus>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMssRfErrStatus))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMssRfErrStatus>())).errStatusFlg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssRfErrStatus),
            "::",
            stringify!(errStatusFlg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMssRfErrStatus>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMssRfErrStatus),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlMssRfErrStatus_t = rlMssRfErrStatus;
#[doc = " \\brief"]
#[doc = " Structure to hold the BSS ESM Fault data strucutre for event RL_RF_AE_ESMFAULT_SB"]
#[doc = " @note : The Programmable filter Parity error and double bit ECC errors are fatal errors but"]
#[doc = "         connected to ESM Group 1 lines, these shuld be treated as fatal errors on the Host ."]
#[doc = "         (MSS or DSS in xWR1642, xWR1843 and xWR6843 devices)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlBssEsmFault {
    #[doc = " @brief  Bits Definition   (0 -- No Error , 1 -- ESM Error)"]
    #[doc = "0   Ramp gen sub block error \\n"]
    #[doc = "1   RESERVED \\n"]
    #[doc = "2   GPADC RAM sub block error \\n"]
    #[doc = "3   VIM RAM sub block error \\n"]
    #[doc = "4   DFE self test error (RESERVED in xWR6x43 devices) \\n"]
    #[doc = "5   VIM self test error \\n"]
    #[doc = "6   B0 TCM sub block error \\n"]
    #[doc = "7   B1 TCM sub block error \\n"]
    #[doc = "8   CCMR4 selftest error \\n"]
    #[doc = "9   ATCM sub block error \\n"]
    #[doc = "10  Ramp gen self test error \\n"]
    #[doc = "11  Ramp gen parity self test error \\n"]
    #[doc = "12  Sequence extinguisher self test error \\n"]
    #[doc = "13  Sequence extinguisher sub block error \\n"]
    #[doc = "14  Programmable Filter Fatal Parity error (RESERVED in xWR6x43 devices) \\n"]
    #[doc = "15  AGC RAM sub block error \\n"]
    #[doc = "16  B1 TCM parity check error \\n"]
    #[doc = "17  B0 TCM parity check error \\n"]
    #[doc = "18  ATCM parity check error \\n"]
    #[doc = "19  Mailbox MSS to BSS sub block error \\n"]
    #[doc = "20  Mailbox BSS to MSS sub block error \\n"]
    #[doc = "24:21  RESERVED \\n"]
    #[doc = "25  Programmable Filter Fatal DB ECC error \\n"]
    #[doc = "31:26  RESERVED \\n"]
    pub esmGrp1Err: rlUInt32_t,
    #[doc = " @brief  Bits Definition \\n"]
    #[doc = "0   DFE STC error \\n"]
    #[doc = "1   CR4 STC error \\n"]
    #[doc = "2   CCMR4 comparator error \\n"]
    #[doc = "3   B0TCM DB error \\n"]
    #[doc = "4   B1TCM DB error \\n"]
    #[doc = "5   ATCM DB error \\n"]
    #[doc = "6   DCC error \\n"]
    #[doc = "7   Sequence extinguisher error \\n"]
    #[doc = "8   Synthesizer frequency monitoring error \\n"]
    #[doc = "9   DFE parity error \\n"]
    #[doc = "10  Ramp gen DB error \\n"]
    #[doc = "11  Bubble correctin fail \\n"]
    #[doc = "12  Ramp gen lockstep error \\n"]
    #[doc = "13  RTI reset error \\n"]
    #[doc = "14  GPADC RAM DB error \\n"]
    #[doc = "15  VIM comparator error \\n"]
    #[doc = "16  CR4 live clock error \\n"]
    #[doc = "17  Watch dog timer NMI error \\n"]
    #[doc = "18  VIM RAM DB error \\n"]
    #[doc = "19  Ramp gen parity error \\n"]
    #[doc = "20  Sequence extinguisher DB error \\n"]
    #[doc = "21  DMA MPU error \\n"]
    #[doc = "22  AGC RAM DB error \\n"]
    #[doc = "23  CRC comparator error \\n"]
    #[doc = "24  Wakeup status error \\n"]
    #[doc = "25  Short circuit error \\n"]
    #[doc = "26  B1 TCM parity error \\n"]
    #[doc = "27  B0 TCM parity error \\n"]
    #[doc = "28  ATCM parity error \\n"]
    #[doc = "29  Mailbox MSS to BSS DB error \\n"]
    #[doc = "30  Mailbox BSS to MSS DB error \\n"]
    #[doc = "31  CCC error \\n"]
    pub esmGrp2Err: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlBssEsmFault() {
    assert_eq!(
        ::core::mem::size_of::<rlBssEsmFault>(),
        8usize,
        concat!("Size of: ", stringify!(rlBssEsmFault))
    );
    assert_eq!(
        ::core::mem::align_of::<rlBssEsmFault>(),
        4usize,
        concat!("Alignment of ", stringify!(rlBssEsmFault))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlBssEsmFault>())).esmGrp1Err as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlBssEsmFault),
            "::",
            stringify!(esmGrp1Err)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlBssEsmFault>())).esmGrp2Err as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlBssEsmFault),
            "::",
            stringify!(esmGrp2Err)
        )
    );
}
pub type rlBssEsmFault_t = rlBssEsmFault;
#[doc = " \\brief"]
#[doc = "  This sub block indicates fault in analog supplies or LDO short circuit condition. Once a fault"]
#[doc = "  is detected the functionality cannot be resumed from then on and the sensor needs to be"]
#[doc = "  re-started. This Async Event is generated with SB-ID RL_DEV_AE_MSS_VMON_ERROR_STATUS_SB."]
#[doc = "  @note : This API Async Event is not supported."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlVmonErrStatus {
    #[doc = " @brief  Value  Definition          \\n"]
    #[doc = "          0     NO FAULT            \\n"]
    #[doc = "          1     ANALOG_SUPPLY_FAULT \\n"]
    #[doc = "      Others    RESERVED            \\n"]
    pub faultType: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  Fault signature \\n"]
    #[doc = "         Bit  Definition \\n"]
    #[doc = "          0   VDDIN under voltage indication \\n"]
    #[doc = "          1   VDDIN over voltage indication  \\n"]
    #[doc = "          2   VIN_18CLK supply fault         \\n"]
    #[doc = "          3   VIOIN supply fault (Unable to resolve between 1.8V and 3.3V) \\n"]
    #[doc = "          4   VIN_SRAM under voltage indication \\n"]
    #[doc = "          5   VIOIN_18 supply fault             \\n"]
    #[doc = "          6   APLL_VCO_LDO short circuit        \\n"]
    #[doc = "        31:7  RESERVED"]
    pub faultSig: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlVmonErrStatus() {
    assert_eq!(
        ::core::mem::size_of::<rlVmonErrStatus>(),
        12usize,
        concat!("Size of: ", stringify!(rlVmonErrStatus))
    );
    assert_eq!(
        ::core::mem::align_of::<rlVmonErrStatus>(),
        4usize,
        concat!("Alignment of ", stringify!(rlVmonErrStatus))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlVmonErrStatus>())).faultType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlVmonErrStatus),
            "::",
            stringify!(faultType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlVmonErrStatus>())).reserved0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlVmonErrStatus),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlVmonErrStatus>())).reserved1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlVmonErrStatus),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlVmonErrStatus>())).faultSig as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlVmonErrStatus),
            "::",
            stringify!(faultSig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlVmonErrStatus>())).reserved2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlVmonErrStatus),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type rlVmonErrStatus_t = rlVmonErrStatus;
#[doc = " \\brief"]
#[doc = "  This async event is in response to the command (RL_DEV_CONFIG_SET_MSG:"]
#[doc = "  RL_DEV_RX_DATA_PATH_CONF_SET_SB) which indicates ADC data needs to be transferred over"]
#[doc = "  SPI. This async event contains the ADC data followed by more such async events for"]
#[doc = "  additional data. SB-ID : RL_DEV_AE_MSS_ADC_DATA_SB"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rlRcvAdcData {
    #[doc = " @brief  Number of remaining chunks expected. (Remaining length / 220 bytes)"]
    pub remChunks: rlUInt16_t,
    #[doc = " @brief  ADC data captured by the MMIC. Variable length [4-220] Bytes."]
    pub adcData: [rlSInt8_t; 220usize],
}
#[test]
fn bindgen_test_layout_rlRcvAdcData() {
    assert_eq!(
        ::core::mem::size_of::<rlRcvAdcData>(),
        222usize,
        concat!("Size of: ", stringify!(rlRcvAdcData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRcvAdcData>(),
        2usize,
        concat!("Alignment of ", stringify!(rlRcvAdcData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRcvAdcData>())).remChunks as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRcvAdcData),
            "::",
            stringify!(remChunks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRcvAdcData>())).adcData as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRcvAdcData),
            "::",
            stringify!(adcData)
        )
    );
}
impl Default for rlRcvAdcData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlRcvAdcData_t = rlRcvAdcData;
#[doc = " \\brief"]
#[doc = " mmWaveLink RF Init Complete data structure for event RL_RF_AE_INITCALIBSTATUS_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfInitComplete {
    #[doc = " @brief  RF Calibration Status, bit value: 1 - SUCCESS, 0 - FAILURE \\n"]
    #[doc = "Bit Calibration \\n"]
    #[doc = "0   RESERVED \\n"]
    #[doc = "1   APLL tuning \\n"]
    #[doc = "2   SYNTH VCO1 tuning \\n"]
    #[doc = "3   SYNTH VCO2 tuning \\n"]
    #[doc = "4   LODIST calibration \\n"]
    #[doc = "5   RX ADC DC offset calibration \\n"]
    #[doc = "6   HPF cutoff calibration \\n"]
    #[doc = "7   LPF cutoff calibration \\n"]
    #[doc = "8   Peak detector calibration \\n"]
    #[doc = "9   TX Power calibration \\n"]
    #[doc = "10  RX gain calibration \\n"]
    #[doc = "11  TX Phase calibration \\n"]
    #[doc = "12  RX IQMM calibration \\n"]
    #[doc = "31:13   [Reserved] \\n"]
    #[doc = "@note : CALIBRATION_STATUS should be checked only if CALIBRATION_ENABLE \\n"]
    #[doc = "bit is set to 1. \\n"]
    pub calibStatus: rlUInt32_t,
    #[doc = " @brief  this field is set only for updated calibration. It has same bit definition as \\n"]
    #[doc = "CALIBRATION_STATUS  \\n"]
    pub calibUpdate: rlUInt32_t,
    #[doc = " @brief Measured temperature, based on average of temperature sensors near all enabled TX \\n"]
    #[doc = "and RX channels at the time of calibration. \\n"]
    #[doc = "1 LSB = 1o Celsius \\n"]
    pub temperature: rlUInt16_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  This field indicates when the calibration updates were performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon exceeding allotted bit \\n"]
    #[doc = "width) \\n"]
    pub timeStamp: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRfInitComplete() {
    assert_eq!(
        ::core::mem::size_of::<rlRfInitComplete>(),
        20usize,
        concat!("Size of: ", stringify!(rlRfInitComplete))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfInitComplete>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRfInitComplete))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfInitComplete>())).calibStatus as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfInitComplete),
            "::",
            stringify!(calibStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfInitComplete>())).calibUpdate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfInitComplete),
            "::",
            stringify!(calibUpdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfInitComplete>())).temperature as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfInitComplete),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfInitComplete>())).reserved0 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfInitComplete),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfInitComplete>())).timeStamp as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfInitComplete),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfInitComplete>())).reserved1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfInitComplete),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlRfInitComplete_t = rlRfInitComplete;
#[doc = " \\brief"]
#[doc = " mmWaveLink RF Run time calibration report for event RL_RF_AE_RUN_TIME_CALIB_REPORT_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfRunTimeCalibReport {
    #[doc = " @brief  1 = calibration is passed, 0 = calibration is failed or not enabled/performed at \\n"]
    #[doc = "least once. \\n"]
    #[doc = "Bit: Calibration \\n"]
    #[doc = "0: [Reserved] \\n"]
    #[doc = "1: APLL tuning \\n"]
    #[doc = "2: SYNTH VCO1 tuning \\n"]
    #[doc = "3: SYNTH VCO2 tuning \\n"]
    #[doc = "4: LODIST calibration \\n"]
    #[doc = "5: [Reserved] \\n"]
    #[doc = "6: [Reserved] \\n"]
    #[doc = "7: [Reserved] \\n"]
    #[doc = "8: PD calibration \\n"]
    #[doc = "9: TX Power calibration \\n"]
    #[doc = "10: RX gain calibration \\n"]
    #[doc = "11: [Reserved] \\n"]
    #[doc = "12: [Reserved] \\n"]
    #[doc = "31:13: [Reserved] \\n"]
    pub calibErrorFlag: rlUInt32_t,
    #[doc = " @brief  Whether each calibration resulted in a reconfiguration of RF is indicated by a \\n"]
    #[doc = "value of 1 in the respective bit in this field. It has bit definition as \\n"]
    #[doc = "above \\n"]
    pub calibUpdateStatus: rlUInt32_t,
    #[doc = " @brief  Measured temperature, based on average of temperature sensors near all enabled \\n"]
    #[doc = "TX and RX channels at the time of calibration. \\n"]
    #[doc = "Note that this temperature will be updated only when a run-time calibration is"]
    #[doc = "executed due to a change in temperature by more than 10 deg C. \\n"]
    #[doc = "1 LSB = 1 degree Celsius \\n"]
    pub temperature: rlInt16_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  This field indicates when the calibration updates were performed. \\n"]
    #[doc = "1 LSB = 1 millisecond \\n"]
    #[doc = "(the stamp rolls over upon exceeding allotted bit width)  \\n"]
    pub timeStamp: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRfRunTimeCalibReport() {
    assert_eq!(
        ::core::mem::size_of::<rlRfRunTimeCalibReport>(),
        20usize,
        concat!("Size of: ", stringify!(rlRfRunTimeCalibReport))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfRunTimeCalibReport>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRfRunTimeCalibReport))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfRunTimeCalibReport>())).calibErrorFlag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfRunTimeCalibReport),
            "::",
            stringify!(calibErrorFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfRunTimeCalibReport>())).calibUpdateStatus as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfRunTimeCalibReport),
            "::",
            stringify!(calibUpdateStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfRunTimeCalibReport>())).temperature as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfRunTimeCalibReport),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfRunTimeCalibReport>())).reserved0 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfRunTimeCalibReport),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfRunTimeCalibReport>())).timeStamp as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfRunTimeCalibReport),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfRunTimeCalibReport>())).reserved1 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfRunTimeCalibReport),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlRfRunTimeCalibReport_t = rlRfRunTimeCalibReport;
#[doc = " \\brief"]
#[doc = " API APLL closed loop cal Status Get Sub block structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfApllCalDone {
    pub apllClCalStatus: rlUInt16_t,
    #[doc = " @brief  Tolerance"]
    pub cccTolerance: rlUInt16_t,
    #[doc = " @brief  Window"]
    pub cccCount0: rlUInt16_t,
    #[doc = " @brief  Measured 0.1/3 MHz Unit"]
    pub measFreqCount: rlUInt16_t,
    #[doc = " @brief  Expected"]
    pub cccCount1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRfApllCalDone() {
    assert_eq!(
        ::core::mem::size_of::<rlRfApllCalDone>(),
        12usize,
        concat!("Size of: ", stringify!(rlRfApllCalDone))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfApllCalDone>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRfApllCalDone))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfApllCalDone>())).apllClCalStatus as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfApllCalDone),
            "::",
            stringify!(apllClCalStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfApllCalDone>())).cccTolerance as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfApllCalDone),
            "::",
            stringify!(cccTolerance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfApllCalDone>())).cccCount0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfApllCalDone),
            "::",
            stringify!(cccCount0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfApllCalDone>())).measFreqCount as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfApllCalDone),
            "::",
            stringify!(measFreqCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfApllCalDone>())).cccCount1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfApllCalDone),
            "::",
            stringify!(cccCount1)
        )
    );
}
pub type rlRfApllCalDone_t = rlRfApllCalDone;
#[doc = " \\brief"]
#[doc = " Structure to hold the MSS/radarSS CPU Fault data strucutre for"]
#[doc = " event RL_DEV_AE_MSS_CPUFAULT_SB and RL_RF_AE_CPUFAULT_SB"]
#[doc = " @note : All the Monitoring Async events will be sent out periodically at calibMonTimeUnit"]
#[doc = "         frame rate (FTTI). The RadarSS/BSS has a queue to hold max 8 transmit API messages"]
#[doc = "         (AEs or Responses), the host shall service all the AEs before start of the next FTTI"]
#[doc = "         epoch to avoid RadarSS Queue full CPU fault fatal error."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlCpuFault {
    #[doc = " @brief  0x0    RF Processor Undefined Instruction Abort \\n"]
    #[doc = "0x1    RF Processor Instruction pre-fetch Abort \\n"]
    #[doc = "0x2    RF Processor Data Access Abort \\n"]
    #[doc = "0x3    RF Processor Firmware Fatal Error \\n"]
    #[doc = "0x4 - 0xFF Reserved \\n"]
    pub faultType: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Valid only in case of FAULT type is 0x3, provides the source \\n"]
    #[doc = "line number at which fatal error occurred. \\n"]
    pub lineNum: rlUInt16_t,
    #[doc = " @brief  The instruction PC address at which Fault occurred"]
    pub faultLR: rlUInt32_t,
    #[doc = " @brief  The return address of the function from which fault function \\n"]
    #[doc = "has been called (Call stack LR) \\n"]
    pub faultPrevLR: rlUInt32_t,
    #[doc = " @brief  The CPSR register value at which fault occurred"]
    pub faultSpsr: rlUInt32_t,
    #[doc = " @brief  The SP register value at which fault occurred"]
    pub faultSp: rlUInt32_t,
    #[doc = " @brief  The address access at which Fault occurred (valid only for fault \\n"]
    #[doc = "type 0x0 to 0x2) \\n"]
    pub faultAddr: rlUInt32_t,
    #[doc = " @brief  The status of Error (Error Cause type - valid only for \\n"]
    #[doc = "fault type 0x0 to 0x2) \\n"]
    #[doc = "0x000  BACKGROUND_ERR \\n"]
    #[doc = "0x001  ALIGNMENT_ERR \\n"]
    #[doc = "0x002  DEBUG_EVENT \\n"]
    #[doc = "0x00D  PERMISSION_ERR \\n"]
    #[doc = "0x008  SYNCH_EXTER_ERR \\n"]
    #[doc = "0x406  ASYNCH_EXTER_ERR \\n"]
    #[doc = "0x409  SYNCH_ECC_ERR \\n"]
    #[doc = "0x408  ASYNCH_ECC_ERR \\n"]
    pub faultErrStatus: rlUInt16_t,
    #[doc = " @brief  The Source of the Error (Error Source type- valid only for fault type 0x0 to 0x2)\\n"]
    #[doc = "0x0  ERR_SOURCE_AXI_MASTER \\n"]
    #[doc = "0x1  ERR_SOURCE_ATCM \\n"]
    #[doc = "0x2  ERR_SOURCE_BTCM  \\n"]
    pub faultErrSrc: rlUInt8_t,
    #[doc = " @brief  The AXI Error type (Error Source type - valid only for fault type 0x0 to 0x2) \\n"]
    #[doc = "0x0  AXI_DECOD_ERR \\n"]
    #[doc = "0x1  AXI_SLAVE_ERR  \\n"]
    pub faultAxiErrType: rlUInt8_t,
    #[doc = " @brief  The Error Access type (Error Access type- valid only for fault type 0x0 to 0x2) \\n"]
    #[doc = "0x0  READ_ERR \\n"]
    #[doc = "0x1  WRITE_ERR \\n"]
    pub faultAccType: rlUInt8_t,
    #[doc = " @brief  The Error Recovery type (Error Recovery type - Valid only for fault \\n"]
    #[doc = "type 0x0 to 0x2) \\n"]
    #[doc = "0x0  UNRECOVERY \\n"]
    #[doc = "0x1  RECOVERY  \\n"]
    pub faultRecovType: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlCpuFault() {
    assert_eq!(
        ::core::mem::size_of::<rlCpuFault>(),
        32usize,
        concat!("Size of: ", stringify!(rlCpuFault))
    );
    assert_eq!(
        ::core::mem::align_of::<rlCpuFault>(),
        4usize,
        concat!("Alignment of ", stringify!(rlCpuFault))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCpuFault>())).faultType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCpuFault),
            "::",
            stringify!(faultType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCpuFault>())).reserved0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCpuFault),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCpuFault>())).lineNum as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCpuFault),
            "::",
            stringify!(lineNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCpuFault>())).faultLR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCpuFault),
            "::",
            stringify!(faultLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCpuFault>())).faultPrevLR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCpuFault),
            "::",
            stringify!(faultPrevLR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCpuFault>())).faultSpsr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCpuFault),
            "::",
            stringify!(faultSpsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCpuFault>())).faultSp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCpuFault),
            "::",
            stringify!(faultSp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCpuFault>())).faultAddr as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCpuFault),
            "::",
            stringify!(faultAddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCpuFault>())).faultErrStatus as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCpuFault),
            "::",
            stringify!(faultErrStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCpuFault>())).faultErrSrc as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCpuFault),
            "::",
            stringify!(faultErrSrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCpuFault>())).faultAxiErrType as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCpuFault),
            "::",
            stringify!(faultAxiErrType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCpuFault>())).faultAccType as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCpuFault),
            "::",
            stringify!(faultAccType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCpuFault>())).faultRecovType as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCpuFault),
            "::",
            stringify!(faultRecovType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCpuFault>())).reserved1 as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCpuFault),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlCpuFault_t = rlCpuFault;
#[doc = " \\brief"]
#[doc = " mmWaveLink firmware version structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlFwVersionParam {
    #[doc = " @brief  HW variant number"]
    pub hwVarient: rlUInt8_t,
    #[doc = " @brief  HW version major number"]
    pub hwMajor: rlUInt8_t,
    #[doc = " @brief  HW version minor number"]
    pub hwMinor: rlUInt8_t,
    #[doc = " @brief  FW version major number"]
    pub fwMajor: rlUInt8_t,
    #[doc = " @brief  FW version major number"]
    pub fwMinor: rlUInt8_t,
    #[doc = " @brief  FW version build number"]
    pub fwBuild: rlUInt8_t,
    #[doc = " @brief  FW version debug number"]
    pub fwDebug: rlUInt8_t,
    #[doc = " @brief  FW Release Year"]
    pub fwYear: rlUInt8_t,
    #[doc = " @brief  FW Release Month"]
    pub fwMonth: rlUInt8_t,
    #[doc = " @brief  FW Release Day"]
    pub fwDay: rlUInt8_t,
    #[doc = " @brief  Patch version major number"]
    pub patchMajor: rlUInt8_t,
    #[doc = " @brief  Patch version minor number"]
    pub patchMinor: rlUInt8_t,
    #[doc = " @brief  Patch Release Year"]
    pub patchYear: rlUInt8_t,
    #[doc = " @brief  Patch Release Month"]
    pub patchMonth: rlUInt8_t,
    #[doc = " @brief  Patch Release Day"]
    pub patchDay: rlUInt8_t,
    #[doc = " @brief  Debug and build version"]
    #[doc = "         b3:0   Debug version"]
    #[doc = "         b7:4   Build version"]
    pub patchBuildDebug: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlFwVersionParam() {
    assert_eq!(
        ::core::mem::size_of::<rlFwVersionParam>(),
        16usize,
        concat!("Size of: ", stringify!(rlFwVersionParam))
    );
    assert_eq!(
        ::core::mem::align_of::<rlFwVersionParam>(),
        1usize,
        concat!("Alignment of ", stringify!(rlFwVersionParam))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).hwVarient as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(hwVarient)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).hwMajor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(hwMajor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).hwMinor as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(hwMinor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).fwMajor as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(fwMajor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).fwMinor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(fwMinor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).fwBuild as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(fwBuild)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).fwDebug as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(fwDebug)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).fwYear as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(fwYear)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).fwMonth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(fwMonth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).fwDay as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(fwDay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).patchMajor as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(patchMajor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).patchMinor as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(patchMinor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).patchYear as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(patchYear)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).patchMonth as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(patchMonth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFwVersionParam>())).patchDay as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(patchDay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlFwVersionParam>())).patchBuildDebug as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFwVersionParam),
            "::",
            stringify!(patchBuildDebug)
        )
    );
}
pub type rlFwVersionParam_t = rlFwVersionParam;
#[doc = " \\brief"]
#[doc = " mmwavelink software version structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlSwVersionParam {
    #[doc = " @brief  SW version major number"]
    pub major: rlUInt8_t,
    #[doc = " @brief  SW version minor number"]
    pub minor: rlUInt8_t,
    #[doc = " @brief  SW version buid number"]
    pub build: rlUInt8_t,
    #[doc = " @brief  SW version debug number"]
    pub debug: rlUInt8_t,
    #[doc = " @brief  Software Release Year"]
    pub year: rlUInt8_t,
    #[doc = " @brief  Software Release Month"]
    pub month: rlUInt8_t,
    #[doc = " @brief  Software Release Day"]
    pub day: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlSwVersionParam() {
    assert_eq!(
        ::core::mem::size_of::<rlSwVersionParam>(),
        8usize,
        concat!("Size of: ", stringify!(rlSwVersionParam))
    );
    assert_eq!(
        ::core::mem::align_of::<rlSwVersionParam>(),
        1usize,
        concat!("Alignment of ", stringify!(rlSwVersionParam))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSwVersionParam>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSwVersionParam),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSwVersionParam>())).minor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSwVersionParam),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSwVersionParam>())).build as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSwVersionParam),
            "::",
            stringify!(build)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSwVersionParam>())).debug as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSwVersionParam),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSwVersionParam>())).year as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSwVersionParam),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSwVersionParam>())).month as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSwVersionParam),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSwVersionParam>())).day as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSwVersionParam),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSwVersionParam>())).reserved as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSwVersionParam),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlSwVersionParam_t = rlSwVersionParam;
#[doc = " \\brief"]
#[doc = " mmwavelink version structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlVersion {
    #[doc = " @brief  Master Sub System version"]
    pub master: rlFwVersionParam_t,
    #[doc = " @brief  RF Sub System version"]
    pub rf: rlFwVersionParam_t,
    #[doc = " @brief  mmWaveLink version"]
    pub mmWaveLink: rlSwVersionParam_t,
}
#[test]
fn bindgen_test_layout_rlVersion() {
    assert_eq!(
        ::core::mem::size_of::<rlVersion>(),
        40usize,
        concat!("Size of: ", stringify!(rlVersion))
    );
    assert_eq!(
        ::core::mem::align_of::<rlVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(rlVersion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlVersion>())).master as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlVersion),
            "::",
            stringify!(master)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlVersion>())).rf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlVersion),
            "::",
            stringify!(rf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlVersion>())).mmWaveLink as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rlVersion),
            "::",
            stringify!(mmWaveLink)
        )
    );
}
pub type rlVersion_t = rlVersion;
#[doc = " \\brief"]
#[doc = " GPADC measurement data for sensors"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlGpAdcData {
    #[doc = " @brief  Min value of GP ADC data"]
    pub min: rlUInt16_t,
    #[doc = " @brief  Max value of GP ADC data"]
    pub max: rlUInt16_t,
    #[doc = " @brief  Avg value of GP ADC data"]
    pub avg: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlGpAdcData() {
    assert_eq!(
        ::core::mem::size_of::<rlGpAdcData>(),
        6usize,
        concat!("Size of: ", stringify!(rlGpAdcData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlGpAdcData>(),
        2usize,
        concat!("Alignment of ", stringify!(rlGpAdcData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlGpAdcData>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlGpAdcData),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlGpAdcData>())).max as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlGpAdcData),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlGpAdcData>())).avg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlGpAdcData),
            "::",
            stringify!(avg)
        )
    );
}
pub type rlGpAdcData_t = rlGpAdcData;
#[doc = " \\brief"]
#[doc = " Sensors GPADC measurement data for event RL_RF_AE_GPADC_MEAS_DATA_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRecvdGpAdcData {
    #[doc = " @brief  collected all GP ADC data"]
    pub sensor: [rlGpAdcData_t; 6usize],
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: [rlUInt16_t; 4usize],
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: [rlUInt32_t; 7usize],
}
#[test]
fn bindgen_test_layout_rlRecvdGpAdcData() {
    assert_eq!(
        ::core::mem::size_of::<rlRecvdGpAdcData>(),
        72usize,
        concat!("Size of: ", stringify!(rlRecvdGpAdcData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRecvdGpAdcData>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRecvdGpAdcData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRecvdGpAdcData>())).sensor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRecvdGpAdcData),
            "::",
            stringify!(sensor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRecvdGpAdcData>())).reserved0 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRecvdGpAdcData),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRecvdGpAdcData>())).reserved1 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRecvdGpAdcData),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlRecvdGpAdcData_t = rlRecvdGpAdcData;
#[doc = " \\brief"]
#[doc = " Analog fault strucure for event RL_RF_AE_ANALOG_FAULT_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlAnalogFaultReportData {
    #[doc = " @brief  Indicates the analog fault type"]
    #[doc = "         Value   Definition"]
    #[doc = "           0     No fault"]
    #[doc = "           1     Analog supply fault"]
    #[doc = "         Others  RESERVED"]
    pub faultType: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  Indicates which analog supply is in fault"]
    #[doc = "         Bit    Definition"]
    #[doc = "          0     1.8V BB Analog supply fault"]
    #[doc = "          1     1.3V/1.0V RF supply fault"]
    #[doc = "          2     Synth VCO LDO short circuit detected"]
    #[doc = "          3     PA LDO short circuit detected"]
    #[doc = "          31:4  RESERVED"]
    pub faultSig: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlAnalogFaultReportData() {
    assert_eq!(
        ::core::mem::size_of::<rlAnalogFaultReportData>(),
        12usize,
        concat!("Size of: ", stringify!(rlAnalogFaultReportData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlAnalogFaultReportData>(),
        4usize,
        concat!("Alignment of ", stringify!(rlAnalogFaultReportData))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAnalogFaultReportData>())).faultType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnalogFaultReportData),
            "::",
            stringify!(faultType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAnalogFaultReportData>())).reserved0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnalogFaultReportData),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAnalogFaultReportData>())).reserved1 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnalogFaultReportData),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAnalogFaultReportData>())).faultSig as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnalogFaultReportData),
            "::",
            stringify!(faultSig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAnalogFaultReportData>())).reserved2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnalogFaultReportData),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type rlAnalogFaultReportData_t = rlAnalogFaultReportData;
#[doc = " \\brief"]
#[doc = " Calibration monitoring timing error data for event RL_RF_AE_MON_TIMING_FAIL_REPORT_SB"]
#[doc = " @note : In QM devices (non safety), Periodic Digital and Analog Monitoring are not supported."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlCalMonTimingErrorReportData {
    #[doc = " @brief  [b0] 1 = Total monitoring time does not fit in one CALIB_MON_TIME_UNIT when one \\n"]
    #[doc = "time calibration is enabled, \\n"]
    #[doc = "0 = No failure \\n"]
    #[doc = "[b1] 1 = Total monitoring and calibration time don't fit in one calibMonTimeUnit \\n"]
    #[doc = "when periodic calibration is enabled, \\n"]
    #[doc = "0 = No failure \\n"]
    #[doc = "[b2] 1 = Runtime timing violation: Monitoring functions or calibrations could \\n"]
    #[doc = "not be completed in one calibMonTimeUnit, \\n"]
    #[doc = "0 = No failure \\n"]
    #[doc = "[b3-b15] RESERVED  \\n"]
    pub timingFailCode: rlUInt16_t,
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlCalMonTimingErrorReportData() {
    assert_eq!(
        ::core::mem::size_of::<rlCalMonTimingErrorReportData>(),
        4usize,
        concat!("Size of: ", stringify!(rlCalMonTimingErrorReportData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlCalMonTimingErrorReportData>(),
        2usize,
        concat!("Alignment of ", stringify!(rlCalMonTimingErrorReportData))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlCalMonTimingErrorReportData>())).timingFailCode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCalMonTimingErrorReportData),
            "::",
            stringify!(timingFailCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlCalMonTimingErrorReportData>())).reserved as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCalMonTimingErrorReportData),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlCalMonTimingErrorReportData_t = rlCalMonTimingErrorReportData;
#[doc = " \\brief"]
#[doc = " Latent fault digital monitoring status data for event RL_RF_AE_DIG_LATENTFAULT_REPORT_AE_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDigLatentFaultReportData {
    #[doc = " @brief  1 - PASS, 0 - FAIL \\n"]
    #[doc = "Bit     Definition \\n"]
    #[doc = "0       RESERVED \\n"]
    #[doc = "1       CR4_VIM_LOCKSTEP_MONITORING \\n"]
    #[doc = "2       RESERVED \\n"]
    #[doc = "3       VIM_MONITORING \\n"]
    #[doc = "4       RESERVED \\n"]
    #[doc = "5       RESERVED \\n"]
    #[doc = "6       CRC_MONITORING \\n"]
    #[doc = "7       RAMPGEN_ECC_MONITORING (Not supported in 1st Gen devices, refer latest"]
    #[doc = "release note) \\n"]
    #[doc = "8       DFE_PARITY_MONITORNG (RESERVED in xWR6x43 devices) \\n"]
    #[doc = "9       DFE_ECC_MONITORING \\n"]
    #[doc = "10      RAMPGEN_LOCKSTEP_MONITORING \\n"]
    #[doc = "11      FRC_LOCKSTEP_MONITORING \\n"]
    #[doc = "12      RESERVED \\n"]
    #[doc = "13      RESERVED \\n"]
    #[doc = "14      RESERVED \\n"]
    #[doc = "15      RESERVED \\n"]
    #[doc = "16      ESM_MONITORING \\n"]
    #[doc = "17      DFE_STC_MONITORING \\n"]
    #[doc = "18      RESERVED \\n"]
    #[doc = "19      ATCM_BTCM_ECC_MONITORING  \\n"]
    #[doc = "20      ATCM_BTCM_PARITY_MONITORING \\n"]
    #[doc = "21      RESERVED \\n"]
    #[doc = "22      RESERVED \\n"]
    #[doc = "23      RESERVED \\n"]
    #[doc = "24      FFT_MONITORING \\n"]
    #[doc = "25      RTI_MONITORING \\n"]
    #[doc = "31:26   RESERVED  \\n"]
    pub digMonLatentFault: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlDigLatentFaultReportData() {
    assert_eq!(
        ::core::mem::size_of::<rlDigLatentFaultReportData>(),
        4usize,
        concat!("Size of: ", stringify!(rlDigLatentFaultReportData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDigLatentFaultReportData>(),
        4usize,
        concat!("Alignment of ", stringify!(rlDigLatentFaultReportData))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDigLatentFaultReportData>())).digMonLatentFault as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDigLatentFaultReportData),
            "::",
            stringify!(digMonLatentFault)
        )
    );
}
pub type rlDigLatentFaultReportData_t = rlDigLatentFaultReportData;
#[doc = " \\brief"]
#[doc = " The report header includes common information across all enabled monitors"]
#[doc = " like current FTTI number and current temperature. event: RL_RF_AE_MON_REPORT_HEADER_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonReportHdrData {
    #[doc = " @brief  FTTI free running counter value, incremented every CAL_MON_TIME_UNIT"]
    pub fttiCount: rlUInt32_t,
    #[doc = " @brief  Average temperature at which was monitoring performed \\n"]
    #[doc = "         1 LSB = 1 deg C"]
    pub avgTemp: rlUInt16_t,
    #[doc = " @brief  Reserved for future use \\n"]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonReportHdrData() {
    assert_eq!(
        ::core::mem::size_of::<rlMonReportHdrData>(),
        12usize,
        concat!("Size of: ", stringify!(rlMonReportHdrData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonReportHdrData>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonReportHdrData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonReportHdrData>())).fttiCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonReportHdrData),
            "::",
            stringify!(fttiCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonReportHdrData>())).avgTemp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonReportHdrData),
            "::",
            stringify!(avgTemp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonReportHdrData>())).reserved0 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonReportHdrData),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonReportHdrData>())).reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonReportHdrData),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlMonReportHdrData_t = rlMonReportHdrData;
#[doc = " \\brief"]
#[doc = " This async event is sent periodically to indicate the status of periodic"]
#[doc = " digital monitoring tests.Event: RL_RF_AE_MON_DIG_PERIODIC_REPORT_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDigPeriodicReportData {
    #[doc = " @brief  1 - PASS, 0 - FAIL \\n"]
    #[doc = "Bit    Monitoring type \\n"]
    #[doc = "[0]    PERIODIC_CONFG_REGISTER_READ \\n"]
    #[doc = "[1]    RESERVED \\n"]
    #[doc = "[2]    DFE_STC \\n"]
    #[doc = "[3]    FRAME_TIMING_MONITORING \\n"]
    #[doc = "[31:4] RESERVED  \\n"]
    pub digMonPeriodicStatus: rlUInt32_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1millisecond (the stamp rolls over upon exceeding allotted bit \\n"]
    #[doc = "width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlDigPeriodicReportData() {
    assert_eq!(
        ::core::mem::size_of::<rlDigPeriodicReportData>(),
        8usize,
        concat!("Size of: ", stringify!(rlDigPeriodicReportData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDigPeriodicReportData>(),
        4usize,
        concat!("Alignment of ", stringify!(rlDigPeriodicReportData))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDigPeriodicReportData>())).digMonPeriodicStatus as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDigPeriodicReportData),
            "::",
            stringify!(digMonPeriodicStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDigPeriodicReportData>())).timeStamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDigPeriodicReportData),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlDigPeriodicReportData_t = rlDigPeriodicReportData;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which RadarSS sends to the host,"]
#[doc = " containing the measured temperature near various RF analog and digital modules."]
#[doc = " The xWR device sends this to host at the programmed periodicity or when failure occurs,"]
#[doc = " as programmed by the configuration API SB. Event:RL_RF_AE_MON_TEMPERATURE_REPORT_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonTempReportData {
    #[doc = " @brief  Status flags indicating pass fail results corresponding to \\n"]
    #[doc = "various threshold checks under this monitor. \\n"]
    #[doc = "Bit  STATUS_FLAG for monitor \\n"]
    #[doc = "[0]  STATUS_ANA_TEMP_MIN \\n"]
    #[doc = "[1]  STATUS_ANA_TEMP_MAX \\n"]
    #[doc = "[2]  STATUS_DIG_TEMP_MIN \\n"]
    #[doc = "[3]  STATUS_DIG_TEMP_MAX \\n"]
    #[doc = "[4]  STATUS_TEMP_DIFF_THRESH \\n"]
    #[doc = "[15:5]RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS  \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  The measured onchip temperatures are reported here. \\n"]
    #[doc = "Byte numbers corresponding to different temperature sensors \\n"]
    #[doc = "reported in this field are here: \\n"]
    #[doc = "Bytes       SIGNAL \\n"]
    #[doc = "[1:0]       TEMP_RX0 \\n"]
    #[doc = "[3:2]       TEMP_RX1 \\n"]
    #[doc = "[5:4]       TEMP_RX2 \\n"]
    #[doc = "[7:6]       TEMP_RX3 \\n"]
    #[doc = "[9:8]       TEMP_TX0 \\n"]
    #[doc = "[11:10]     TEMP_TX1 \\n"]
    #[doc = "[13:12]     TEMP_TX2 \\n"]
    #[doc = "[15:14]     TEMP_PM \\n"]
    #[doc = "[17:16]     TEMP_DIG1 \\n"]
    #[doc = "[19:18]     TEMP_DIG2 (Applicable only in xWR1642 & xWR1843) \\n"]
    #[doc = "1 LSB = 1 degree C, signed number  \\n"]
    pub tempValues: [rlInt16_t; 10usize],
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt32_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond  \\n"]
    #[doc = "(the stamp rolls over upon exceeding allotted bit width)  \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonTempReportData() {
    assert_eq!(
        ::core::mem::size_of::<rlMonTempReportData>(),
        32usize,
        concat!("Size of: ", stringify!(rlMonTempReportData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonTempReportData>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonTempReportData))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonTempReportData>())).statusFlags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTempReportData),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTempReportData>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTempReportData),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTempReportData>())).tempValues as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTempReportData),
            "::",
            stringify!(tempValues)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTempReportData>())).reserved as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTempReportData),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTempReportData>())).timeStamp as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTempReportData),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonTempReportData_t = rlMonTempReportData;
#[doc = " \\brief"]
#[doc = " This API is a Monitoring report which RadarSS sends to the host,"]
#[doc = " containing the measured RX gain and phase values,Loopback Power and Noise Power. Noise Power can"]
#[doc = " be used by the Host to detect the presence of interference. RadarSS sends this to host at the \\n"]
#[doc = " programmed periodicity or when failure occurs, as programmed by the configuration API SB."]
#[doc = " Event: RL_RF_AE_MON_RX_GAIN_PHASE_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonRxGainPhRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding \\n"]
    #[doc = "to various threshold checks under this monitor. \\n"]
    #[doc = "Bit  STATUS_FLAG for monitor \\n"]
    #[doc = "[0]  STATUS_RX_GAIN_ABS \\n"]
    #[doc = "[1]  STATUS_RX_GAIN_MISMATCH \\n"]
    #[doc = "[2]  STATUS_RX_GAIN_FLATNESS \\n"]
    #[doc = "[3]  STATUS_RX_PHASE_MISMATCH \\n"]
    #[doc = "[15:4]RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS  \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring  Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  Profile Index for which this monitoring report applies."]
    pub profIndex: rlUInt8_t,
    #[doc = " @brief  The measured average loop-back power across RX channels at each enabled"]
    #[doc = "         RF1 frequency (i.e. Lowest, center and highest with 60MHz dither in the"]
    #[doc = "         profile's RF band) at LNA input is reported here. \\n"]
    #[doc = "         b4:b0 RF1 \\n"]
    #[doc = "         b7-b5: reserved \\n"]
    #[doc = "         1LSB = -2 dBm \\n"]
    #[doc = "         Valid range = -62dBm to 0dBm. \\n"]
    #[doc = "         Only the entries of enabled RF frequencies are valid. \\n"]
    #[doc = "         The LB power might be bad/corrupted under interference conditions, and unreliable"]
    #[doc = "         at temperatures far away from room temperature. So, their usage is discouraged and"]
    #[doc = "         not supported for production usage. \\n"]
    pub loopbackPowerRF1: rlUInt8_t,
    #[doc = " @brief  The measured average loop-back power across RX channels at each enabled"]
    #[doc = "         RF2 frequency (i.e. Lowest, center and highest with 60MHz dither in the"]
    #[doc = "         profile's RF band) at LNA input is reported here. \\n"]
    #[doc = "         b4:b0 RF2 \\n"]
    #[doc = "         b7-b5: reserved \\n"]
    #[doc = "         1LSB = -2 dBm \\n"]
    #[doc = "         Valid range = -62dBm to 0dBm. \\n"]
    #[doc = "         Only the entries of enabled RF frequencies are valid. \\n"]
    #[doc = "         The LB power might be bad/corrupted under interference conditions, and unreliable"]
    #[doc = "         at temperatures far away from room temperature. So, their usage is discouraged and"]
    #[doc = "         not supported for production usage. \\n"]
    pub loopbackPowerRF2: rlUInt8_t,
    #[doc = " @brief  The measured average loop-back power across RX channels at each enabled"]
    #[doc = "         RF3 frequency (i.e. Lowest, center and highest with 60MHz dither in the"]
    #[doc = "         profile's RF band) at LNA input is reported here. \\n"]
    #[doc = "         b4:b0 RF3 \\n"]
    #[doc = "         b7-b5: reserved \\n"]
    #[doc = "         1LSB = -2 dBm \\n"]
    #[doc = "         Valid range = -62dBm to 0dBm. \\n"]
    #[doc = "         Only the entries of enabled RF frequencies are valid. \\n"]
    #[doc = "         The LB power might be bad/corrupted under interference conditions, and unreliable"]
    #[doc = "         at temperatures far away from room temperature. So, their usage is discouraged and"]
    #[doc = "         not supported for production usage. \\n"]
    pub loopbackPowerRF3: rlUInt8_t,
    #[doc = " @brief  The measured RX gain for each enabled channel, at each enabled RF frequency \\n"]
    #[doc = "(i.e., lowest, center and highest in the profile's RF band) is reported \\n"]
    #[doc = "here. Byte numbers corresponding to different RX and RF, in this field \\n"]
    #[doc = "are here: \\n"]
    #[doc = "RF1     RF2     RF3 \\n"]
    #[doc = "RX0     1:0     9:8     17:16 \\n"]
    #[doc = "RX1     3:2     11:10   19:18 \\n"]
    #[doc = "RX2     5:4     13:12   21:20 \\n"]
    #[doc = "RX3     7:6     15:14   23:22 \\n"]
    #[doc = "1 LSB = 0.1 dB \\n"]
    #[doc = "Only the entries of enabled RF Frequencies and enabled RX channels are \\n"]
    #[doc = "valid. \\n"]
    #[doc = "The RX gain is measured using only ADC power and under assumption of a fixed"]
    #[doc = "LB power for all RF1, RF2 and RF3 frequencies to avoid interference"]
    #[doc = "impact. \\n Therefore, RX gain shows around 10 dB deviation from"]
    #[doc = "programmed RX gain across full temperature range. \\n"]
    #[doc = "For xWR1xxx devices: \\n"]
    #[doc = "The actual Rx gain of the device in dB = RX GAIN VALUE(Rf freq, Rx) +"]
    #[doc = "(-38dBm) – LOOPBACK_POWER_TEMP_dBm(Temp[C]) \\n"]
    #[doc = "Where LOOPBACK_POWER_TEMP_dBm (Temp[C]) = -0.07*Temp[C] – 34 \\n"]
    #[doc = "Loopback power is -38 dBm around 50 C, and decreases with slope of"]
    #[doc = "-7 dBm/100C. These formulae can be used for monitoring reports not affected"]
    #[doc = "by interference. \\n"]
    #[doc = "For xWR6x43 devices: \\n"]
    #[doc = "RX gain value reported by the device assumes a constant loopback power."]
    #[doc = "Please refer to monitoring application notes for more information on"]
    #[doc = "computing the actual RX gain from the device reported gain value. \\n"]
    pub rxGainVal: [rlUInt16_t; 12usize],
    #[doc = " @brief  The measured RX phase for each enabled channel, at each enabled RF frequency is \\n"]
    #[doc = "reported here. Byte numbers corresponding to different RX and RF,  \\n"]
    #[doc = "in this field are here: \\n"]
    #[doc = "RF1     RF2     RF3 \\n"]
    #[doc = "RX0     1:0     9:8     17:16 \\n"]
    #[doc = "RX1     3:2     11:10   19:18 \\n"]
    #[doc = "RX2     5:4     13:12   21:20 \\n"]
    #[doc = "RX3     7:6     15:14   23:22 \\n"]
    #[doc = "LSB = 360 (degree)/2^16. \\n"]
    #[doc = "Only the entries of enabled RF Frequencies and enabled RX channels are \\n"]
    #[doc = "valid. \\n"]
    #[doc = "@note : these phases include an unknown bias common to all RX channels. \\n"]
    pub rxPhaseVal: [rlUInt16_t; 12usize],
    #[doc = " @brief  The measured RX noise power for each enabled channel, at RF1 & RF2 frequencies \\n"]
    #[doc = "(i.e., lowest and center in the profile's RF band) are reported here. Bit \\n"]
    #[doc = "numbers corresponding to different RX and RF, in this field are here: \\n"]
    #[doc = ""]
    #[doc = "| Bit         |   4:0   |   9:5   |  14:10  |  19:15  |  24:20  |  29:25  |"]
    #[doc = "| ----------: |         |         |         |         |         |         |"]
    #[doc = "| **RX & RF** | RX0.RF1 | RX1.RF1 | RX2.RF1 | RX3.RF1 | RX0.RF2 | RX1.RF2 |"]
    #[doc = ""]
    #[doc = "bit 31:30 - Reserved \\n"]
    #[doc = "1 LSB = -2 dBm. \\n"]
    #[doc = "Range: 0 to -62dBm \\n"]
    #[doc = "Noise Power shows a decreasing trend with temperature with average noise"]
    #[doc = "power being -43 dBm at 50 C and decreasing with slope = -8 dBm/100C. \\n"]
    #[doc = "Noise_Power_dBm (Temp[C]) =-0.08 * Temp [C] - 39 \\n"]
    #[doc = "Noise Power can be used for detecting the monitoring reports impacted by"]
    #[doc = "interference. \\n"]
    #[doc = ""]
    pub rxNoisePower1: rlUInt32_t,
    #[doc = " @brief  The measured RX noise power for each enabled channel, at RF2 & RF3 frequencies \\n"]
    #[doc = "(i.e., center and highest in the profile's RF band) are reported here. Bit \\n"]
    #[doc = "numbers corresponding to different RX and RF, in this field are here: \\n"]
    #[doc = ""]
    #[doc = "| Bit         |   4:0   |   9:5   |  14:10  |  19:15  |  24:20  |  29:25  |"]
    #[doc = "| ------:     |         |         |         |         |         |         |"]
    #[doc = "| **RX & RF** | RX2.RF2 | RX3.RF2 | RX0.RF3 | RX1.RF3 | RX2.RF3 | RX3.RF3 |"]
    #[doc = ""]
    #[doc = "bit 31:30 - Reserved \\n"]
    #[doc = "1 LSB = -2 dBm. \\n"]
    #[doc = "Range: 0 to -62dBm \\n"]
    #[doc = "Noise Power shows a decreasing trend with temperature with average noise"]
    #[doc = "power being -43 dBm at 50 C and decreasing with slope = -8 dBm/100C. \\n"]
    #[doc = "Noise_Power_dBm (Temp[C]) =-0.08 * Temp [C] - 39 \\n"]
    #[doc = "Noise Power can be used for detecting the monitoring reports impacted by"]
    #[doc = "interference. \\n"]
    pub rxNoisePower2: rlUInt32_t,
    #[doc = " @brief  This field indicates when the last monitoring  in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon exceeding allotted bit \\n"]
    #[doc = "width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonRxGainPhRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonRxGainPhRep>(),
        68usize,
        concat!("Size of: ", stringify!(rlMonRxGainPhRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonRxGainPhRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonRxGainPhRep))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxGainPhRep>())).statusFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxGainPhRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxGainPhRep>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxGainPhRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxGainPhRep>())).profIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxGainPhRep),
            "::",
            stringify!(profIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonRxGainPhRep>())).loopbackPowerRF1 as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxGainPhRep),
            "::",
            stringify!(loopbackPowerRF1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonRxGainPhRep>())).loopbackPowerRF2 as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxGainPhRep),
            "::",
            stringify!(loopbackPowerRF2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonRxGainPhRep>())).loopbackPowerRF3 as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxGainPhRep),
            "::",
            stringify!(loopbackPowerRF3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxGainPhRep>())).rxGainVal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxGainPhRep),
            "::",
            stringify!(rxGainVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxGainPhRep>())).rxPhaseVal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxGainPhRep),
            "::",
            stringify!(rxPhaseVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxGainPhRep>())).rxNoisePower1 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxGainPhRep),
            "::",
            stringify!(rxNoisePower1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxGainPhRep>())).rxNoisePower2 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxGainPhRep),
            "::",
            stringify!(rxNoisePower2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxGainPhRep>())).timeStamp as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxGainPhRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonRxGainPhRep_t = rlMonRxGainPhRep;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which RadarSS sends"]
#[doc = " to the host, containing the measured RX noise figure values"]
#[doc = " corresponding to the full IF band of a profile. RadarSS sends"]
#[doc = " this to host at the programmed periodicity or when failure occurs,"]
#[doc = " as programmed by the configuration API SB. Event: RL_RF_AE_MON_RX_NOISE_FIG_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonRxNoiseFigRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding to various threshold \\n"]
    #[doc = "checks under this monitor. \\n"]
    #[doc = "Bit  STATUS_FLAG for monitor \\n"]
    #[doc = "[0]  STATUS_RX_NOISE_FIGURE \\n"]
    #[doc = "[15:1]RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS  \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  Profile Index for which this monitoring report applies."]
    pub profIndex: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  TThe measured RX input referred for each enabled channel, at each enabled RF \\n"]
    #[doc = "frequency is reported here. Byte numbers corresponding to different RX \\n"]
    #[doc = "and RF, in this field are here: \\n"]
    #[doc = "RF1     RF2     RF3 \\n"]
    #[doc = "RX0     1:0     9:8     17:16 \\n"]
    #[doc = "RX1     3:2     11:10   19:18 \\n"]
    #[doc = "RX2     5:4     13:12   21:20 \\n"]
    #[doc = "RX3     7:6     15:14   23:22 \\n"]
    #[doc = "1 LSB = 0.1 dB \\n"]
    #[doc = "Only the entries of enabled RF Frequencies and enabled RX channels are \\n"]
    #[doc = "valid. \\n"]
    pub rxNoiseFigVal: [rlUInt16_t; 12usize],
    #[doc = " @brief  Reserved for future use"]
    pub reserved2: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved3: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved4: rlUInt32_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon \\n"]
    #[doc = "exceeding allotted bit width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonRxNoiseFigRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonRxNoiseFigRep>(),
        48usize,
        concat!("Size of: ", stringify!(rlMonRxNoiseFigRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonRxNoiseFigRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonRxNoiseFigRep))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxNoiseFigRep>())).statusFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxNoiseFigRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxNoiseFigRep>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxNoiseFigRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxNoiseFigRep>())).profIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxNoiseFigRep),
            "::",
            stringify!(profIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxNoiseFigRep>())).reserved0 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxNoiseFigRep),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxNoiseFigRep>())).reserved1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxNoiseFigRep),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonRxNoiseFigRep>())).rxNoiseFigVal as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxNoiseFigRep),
            "::",
            stringify!(rxNoiseFigVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxNoiseFigRep>())).reserved2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxNoiseFigRep),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxNoiseFigRep>())).reserved3 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxNoiseFigRep),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxNoiseFigRep>())).reserved4 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxNoiseFigRep),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxNoiseFigRep>())).timeStamp as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxNoiseFigRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonRxNoiseFigRep_t = rlMonRxNoiseFigRep;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which RadarSS sends to the host, containing the measured"]
#[doc = " RX IF filter attenuation values at the given IF frequencies. RadarSS sends this to host"]
#[doc = " at the programmed periodicity or when failure occurs, as programmed by the configuration API SB."]
#[doc = " Event: RL_RF_AE_MON_RX_IF_STAGE_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonRxIfStageRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding to various threshold \\n"]
    #[doc = "checks under this monitor. \\n"]
    #[doc = "Bit  STATUS_FLAG for monitor \\n"]
    #[doc = "[0]  STATUS_RX_HPF_ERROR \\n"]
    #[doc = "[1]  RESERVED \\n"]
    #[doc = "[2]  STATUS_RX_IFA_GAIN_ERROR \\n"]
    #[doc = "[15:3]RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS  \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  Profile Index for which this monitoring report applies."]
    pub profIndex: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  The deviations of RX IFA HPF cutoff frequency from the ideally expected values \\n"]
    #[doc = "for all the enabled RX channels are reported here. \\n"]
    #[doc = "HPF_CUTOFF_FREQ_ERROR = 100*(Measured Cutoff Frequency /  \\n"]
    #[doc = "Expected Cutoff Frequency) - 100, \\n"]
    #[doc = "for RX IF filter in the HPF region. \\n"]
    #[doc = "Byte numbers corresponding to measured cutoff frequency error  \\n"]
    #[doc = "on different RX channels, in this field are here: \\n"]
    #[doc = "I channel   Q channel \\n"]
    #[doc = "RX0     0           4 \\n"]
    #[doc = "RX1     1           5 \\n"]
    #[doc = "RX2     2           6 \\n"]
    #[doc = "RX3     3           7 \\n"]
    #[doc = "1 LSB = 1%, signed number \\n"]
    #[doc = "Applicable only for the enabled channels. \\n"]
    pub hpfCutOffFreqEr: [rlInt8_t; 8usize],
    #[doc = " @brief  The deviations of RX IFA LPF cutoff frequency \\n"]
    #[doc = "from the ideally expected values for all the enabled \\n"]
    #[doc = "RX channels are reported here. \\n"]
    #[doc = "LPF_CUTOFF_FREQ_ERROR = 100*(Measured Cutoff Frequency / \\n"]
    #[doc = "Expected Cutoff Frequency) - 100, for RX IF filter in the LPF \\n"]
    #[doc = "region. \\n"]
    #[doc = "Byte numbers corresponding to measured cutoff frequency error \\n"]
    #[doc = "on different RX channels, in this field are here: \\n"]
    #[doc = "I channel   Q channel \\n"]
    #[doc = "RX0     0           4 \\n"]
    #[doc = "RX1     1           5 \\n"]
    #[doc = "RX2     2           6 \\n"]
    #[doc = "RX3     3           7 \\n"]
    #[doc = "1 LSB = 1%, signed number \\n"]
    #[doc = "Applicable only for the enabled channels. \\n"]
    #[doc = "@note : This field is not applicable in this release for all devices. This is a RESERVED"]
    #[doc = "field and will be set to 0."]
    pub lpfCutOffFreqEr: [rlInt8_t; 8usize],
    #[doc = " @brief  The deviations of RX IFA Gain from the ideally expected \\n"]
    #[doc = "values for all the enabled RX channels are reported here. \\n"]
    #[doc = "Byte numbers corresponding to measured cutoff frequency error \\n"]
    #[doc = "on different RX channels and HPF/LPF, in this field are here: \\n"]
    #[doc = "I channel   Q channel \\n"]
    #[doc = "RX0     0           4 \\n"]
    #[doc = "RX1     1           5 \\n"]
    #[doc = "RX2     2           6 \\n"]
    #[doc = "RX3     3           7 \\n"]
    #[doc = "1 LSB = 0.1dB, signed number \\n"]
    #[doc = "Applicable only for the enabled channels. \\n"]
    pub rxIfaGainErVal: [rlInt8_t; 8usize],
    #[doc = " @brief  Expected IF gain"]
    #[doc = " 1 LSB = 1 dB, 8 bit signed number"]
    pub ifGainExp: rlInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved2: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved3: rlUInt16_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved4: rlUInt32_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon exceeding allotted bit width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonRxIfStageRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonRxIfStageRep>(),
        44usize,
        concat!("Size of: ", stringify!(rlMonRxIfStageRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonRxIfStageRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonRxIfStageRep))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIfStageRep>())).statusFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIfStageRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIfStageRep>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIfStageRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIfStageRep>())).profIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIfStageRep),
            "::",
            stringify!(profIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIfStageRep>())).reserved0 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIfStageRep),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIfStageRep>())).reserved1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIfStageRep),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonRxIfStageRep>())).hpfCutOffFreqEr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIfStageRep),
            "::",
            stringify!(hpfCutOffFreqEr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonRxIfStageRep>())).lpfCutOffFreqEr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIfStageRep),
            "::",
            stringify!(lpfCutOffFreqEr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonRxIfStageRep>())).rxIfaGainErVal as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIfStageRep),
            "::",
            stringify!(rxIfaGainErVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIfStageRep>())).ifGainExp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIfStageRep),
            "::",
            stringify!(ifGainExp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIfStageRep>())).reserved2 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIfStageRep),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIfStageRep>())).reserved3 as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIfStageRep),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIfStageRep>())).reserved4 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIfStageRep),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIfStageRep>())).timeStamp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIfStageRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonRxIfStageRep_t = rlMonRxIfStageRep;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which RadarSS sends to the host, containing the"]
#[doc = " measured TX power values during an explicit monitoring chirp. RadarSS sends this to"]
#[doc = " host at the programmed periodicity or when failure occurs, as programmed by the"]
#[doc = " configuration API SB. Same structure is application for Tx0/Tx1/Tx2 power report."]
#[doc = " Event: RL_RF_AE_MON_TXn_POWER_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonTxPowRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding \\n"]
    #[doc = "to various threshold checks under this monitor. \\n"]
    #[doc = "Bit  STATUS_FLAG for monitor \\n"]
    #[doc = "[0]  STATUS_ABS_ERR \\n"]
    #[doc = "[1]  STATUS_FLATNESS_ERR \\n"]
    #[doc = "[15:2]RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS  \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  Profile Index for which this monitoring report applies."]
    pub profIndex: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  The measured TX power for each enabled channel, at each enabled RF frequency is \\n"]
    #[doc = "reported here. Byte numbers corresponding to different TX and RF, in this \\n"]
    #[doc = "field are here: \\n"]
    #[doc = "RF1     RF2     RF3 \\n"]
    #[doc = "TX      1:0     3:2     5:4 \\n"]
    #[doc = "(other bytes are reserved) \\n"]
    #[doc = "1 LSB = 0.1 dBm, signed number \\n"]
    #[doc = "Only the entries of enabled RF Frequencies and enabled RX \\n"]
    #[doc = "channels are valid. \\n"]
    pub txPowVal: [rlInt16_t; 3usize],
    #[doc = " @brief  Reserved for future use"]
    pub reserved2: rlUInt16_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon \\n"]
    #[doc = "exceeding allotted bit width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonTxPowRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonTxPowRep>(),
        20usize,
        concat!("Size of: ", stringify!(rlMonTxPowRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonTxPowRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonTxPowRep))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxPowRep>())).statusFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxPowRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxPowRep>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxPowRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxPowRep>())).profIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxPowRep),
            "::",
            stringify!(profIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxPowRep>())).reserved0 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxPowRep),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxPowRep>())).reserved1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxPowRep),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxPowRep>())).txPowVal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxPowRep),
            "::",
            stringify!(txPowVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxPowRep>())).reserved2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxPowRep),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxPowRep>())).timeStamp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxPowRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonTxPowRep_t = rlMonTxPowRep;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which RadarSS sends to the host, containing the measured"]
#[doc = " TX reflection coefficient's magnitude values, meant for detecting TX ball break. RadarSS sends"]
#[doc = " this to host at the programmed periodicity or when failure occurs, as programmed by the"]
#[doc = " configuration API SB."]
#[doc = " Same strucuture is applicable for Tx0/Tx1/Tx2 ball break report."]
#[doc = " Event: RL_RF_AE_MON_TXn_BALLBREAK_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonTxBallBreakRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding \\n"]
    #[doc = "to various threshold checks under this monitor. \\n"]
    #[doc = "Bit  STATUS_FLAG for monitor \\n"]
    #[doc = "[0]  STATUS_TXn_BALLBREAK \\n"]
    #[doc = "[15:1]RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS  \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  The TX reflection coefficient's magnitude for this channel is reported here. \\n"]
    #[doc = "1 LSB = 0.1 dB, signed number \\n"]
    pub txReflCoefVal: rlInt16_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt32_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon \\n"]
    #[doc = "exceeding allotted bit width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonTxBallBreakRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonTxBallBreakRep>(),
        16usize,
        concat!("Size of: ", stringify!(rlMonTxBallBreakRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonTxBallBreakRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonTxBallBreakRep))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonTxBallBreakRep>())).statusFlags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBallBreakRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxBallBreakRep>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBallBreakRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonTxBallBreakRep>())).txReflCoefVal as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBallBreakRep),
            "::",
            stringify!(txReflCoefVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxBallBreakRep>())).reserved0 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBallBreakRep),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxBallBreakRep>())).reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBallBreakRep),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxBallBreakRep>())).timeStamp as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBallBreakRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonTxBallBreakRep_t = rlMonTxBallBreakRep;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which RadarSS sends to the host, containing the measured Tx"]
#[doc = " gain and phase mismatch values during an explicit monitoring chirp. RadarSS sends this to host"]
#[doc = " at the programmed periodicity or when failure occurs, as programmed by the configuration API SB."]
#[doc = " Event: RL_RF_AE_MON_TX_GAIN_MISMATCH_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonTxGainPhaMisRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding \\n"]
    #[doc = "to various threshold checks under this monitor. \\n"]
    #[doc = "Bit  STATUS_FLAG for monitor \\n"]
    #[doc = "[0]  STATUS_TX_GAIN_MISMATCH \\n"]
    #[doc = "[1]  STATUS_TX_PHASE_MISMATCH \\n"]
    #[doc = "[15:2]RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  Profile Index for which this monitoring report applies."]
    pub profIndex: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief   The measured TX PA loopback tone power at the RX ADC input, \\n"]
    #[doc = "for each enabled TX channel, at each enabled RF frequency is reported \\n"]
    #[doc = "here. Byte numbers corresponding to different TX and RF, in this field are \\n"]
    #[doc = "here: \\n"]
    #[doc = "RF1     RF2     RF3 \\n"]
    #[doc = "TX0     1:0     7:6     13:12 \\n"]
    #[doc = "TX1     3:2     9:8     15:14 \\n"]
    #[doc = "TX2     5:4     11:10   17:16 \\n"]
    #[doc = "1 LSB = 0.1dBm, signed number \\n"]
    #[doc = "Only the entries of enabled RF Frequencies and enabled TX channels are valid. \\n"]
    pub txGainVal: [rlInt16_t; 9usize],
    #[doc = " @brief  The measured TX phase for each enabled channel, at each enabled RF \\n"]
    #[doc = "frequency is reported here.Byte numbers corresponding to different TX and \\n"]
    #[doc = "RF, in this field are here: \\n"]
    #[doc = "RF1     RF2     RF3 \\n"]
    #[doc = "TX0     1:0     7:6     13:12 \\n"]
    #[doc = "TX1     3:2     9:8     15:14 \\n"]
    #[doc = "TX2     5:4     11:10   17:16 \\n"]
    #[doc = "1 LSB = 360(degree)/2^16. \\n"]
    #[doc = "Only the entries of enabled RF Frequencies and enabled TX channels are \\n"]
    #[doc = "valid. \\n"]
    #[doc = "Note: these phases include an unknown bias common to all TX channels. \\n"]
    pub txPhaVal: [rlUInt16_t; 9usize],
    #[doc = " @brief  Reserved for future use"]
    pub reserved2: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved3: rlUInt32_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon exceeding allotted bit width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonTxGainPhaMisRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonTxGainPhaMisRep>(),
        56usize,
        concat!("Size of: ", stringify!(rlMonTxGainPhaMisRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonTxGainPhaMisRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonTxGainPhaMisRep))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonTxGainPhaMisRep>())).statusFlags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxGainPhaMisRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxGainPhaMisRep>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxGainPhaMisRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxGainPhaMisRep>())).profIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxGainPhaMisRep),
            "::",
            stringify!(profIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxGainPhaMisRep>())).reserved0 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxGainPhaMisRep),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxGainPhaMisRep>())).reserved1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxGainPhaMisRep),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxGainPhaMisRep>())).txGainVal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxGainPhaMisRep),
            "::",
            stringify!(txGainVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxGainPhaMisRep>())).txPhaVal as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxGainPhaMisRep),
            "::",
            stringify!(txPhaVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxGainPhaMisRep>())).reserved2 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxGainPhaMisRep),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxGainPhaMisRep>())).reserved3 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxGainPhaMisRep),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxGainPhaMisRep>())).timeStamp as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxGainPhaMisRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonTxGainPhaMisRep_t = rlMonTxGainPhaMisRep;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which RadarSS sends to the host, containing the measured"]
#[doc = " TX1 BPM error values. RadarSS sends this to host at the programmed periodicity or when failure"]
#[doc = " occurs, as programmed by the configuration API SB. Same structure is applicable for"]
#[doc = " Tx0/Tx1/Tx2 BPM report data."]
#[doc = " Event: RL_RF_AE_MON_TXn_BPM_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonTxBpmRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding \\n"]
    #[doc = "to various threshold checks under this monitor. \\n"]
    #[doc = "Bit  STATUS_FLAG for monitor \\n"]
    #[doc = "[0]  STATUS_TXn_BPM_PHASE \\n"]
    #[doc = "[1]  STATUS_TXn_BPM_AMPLITUDE \\n"]
    #[doc = "[2]  RESERVED \\n"]
    #[doc = "[15:3]RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS  \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  Profile Index for which this monitoring report applies."]
    pub profIndex: rlUInt8_t,
    #[doc = " @brief  MSB of phase shifter monitor 2 for TX. \\n"]
    #[doc = "phaseShifterMonVal2 = phaseShifterMonVal2Msb * pow(2,8) + \\n"]
    #[doc = "phaseShifterMonVal2Lsb \\n"]
    #[doc = "1 LSB = (360 degree) / pow(2,16) \\n"]
    pub phaseShifterMonVal2Msb: rlUInt8_t,
    #[doc = " @brief  Monitored phase shift for phase shifter monitor 1 for TX"]
    #[doc = "1 LSB = (360 degree) / pow(2,16) \\n"]
    pub phaseShifterMonVal1: rlUInt16_t,
    #[doc = " @brief  The TX output phase difference between the two BPM settings (phase for TX BPM \\n"]
    #[doc = "setting 0 - phase for TX BPM setting 1) is reported here. \\n"]
    #[doc = "1 LSB = 360(degree)/2^16. \\n"]
    pub txBpmPhaDiff: rlUInt16_t,
    #[doc = " @brief  The deviation of the TX output amplitude difference between the two \\n"]
    #[doc = "BPM settings (amplitude for TX BPM setting 0 - amplitude for TX \\n"]
    #[doc = "BPM setting 1) from the ideal 0dB is reported here. \\n"]
    #[doc = "1 LSB = 0.1dB, signed number \\n"]
    pub txBpmAmpDiff: rlInt8_t,
    #[doc = " @brief  LSB of phase shifter monitor 2 for TX. \\n"]
    #[doc = "phaseShifterMonVal2 = phaseShifterMonVal2Msb * pow(2,8) + \\n"]
    #[doc = "phaseShifterMonVal2Lsb \\n"]
    #[doc = "1 LSB = (360 degree) / pow(2,16) \\n"]
    pub phaseShifterMonVal2Lsb: rlUInt8_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon exceeding allotted bit \\n"]
    #[doc = "width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonTxBpmRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonTxBpmRep>(),
        16usize,
        concat!("Size of: ", stringify!(rlMonTxBpmRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonTxBpmRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonTxBpmRep))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxBpmRep>())).statusFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBpmRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxBpmRep>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBpmRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxBpmRep>())).profIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBpmRep),
            "::",
            stringify!(profIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonTxBpmRep>())).phaseShifterMonVal2Msb as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBpmRep),
            "::",
            stringify!(phaseShifterMonVal2Msb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonTxBpmRep>())).phaseShifterMonVal1 as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBpmRep),
            "::",
            stringify!(phaseShifterMonVal1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxBpmRep>())).txBpmPhaDiff as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBpmRep),
            "::",
            stringify!(txBpmPhaDiff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxBpmRep>())).txBpmAmpDiff as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBpmRep),
            "::",
            stringify!(txBpmAmpDiff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonTxBpmRep>())).phaseShifterMonVal2Lsb as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBpmRep),
            "::",
            stringify!(phaseShifterMonVal2Lsb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxBpmRep>())).timeStamp as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxBpmRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonTxBpmRep_t = rlMonTxBpmRep;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which RadarSS sends to the host, containing information"]
#[doc = " related to measured frequency error during the chirp. RadarSS sends this to host at the"]
#[doc = " programmed periodicity or when failure occurs, as programmed by the configuration API SB."]
#[doc = " Event: RL_RF_AE_MON_SYNTHESIZER_FREQ_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonSynthFreqRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding to various threshold \\n"]
    #[doc = "checks under this monitor. \\n"]
    #[doc = "Bit  STATUS_FLAG for monitor \\n"]
    #[doc = "[0]  STATUS_SYNTH_FREQ_ERR \\n"]
    #[doc = "[15:1]RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  Profile Index for which this monitoring report applies."]
    pub profIndex: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  This field indicates the maximum instantaneous frequency error measured  \\n"]
    #[doc = "during the chirps for which frequency monitoring has been enabled in the \\n"]
    #[doc = "previous monitoring period. \\n"]
    #[doc = "Bits    Parameter \\n"]
    #[doc = "31:0    Maximum frequency error value, signed number. 1 LSB = 1kHz. \\n"]
    pub maxFreqErVal: rlInt32_t,
    #[doc = " @brief  This field indicates the number of times during chirping in the previous \\n"]
    #[doc = "monitoring period in which the measured frequency error violated the \\n"]
    #[doc = "allowed threshold. Frequency error threshold violation is counted every \\n"]
    #[doc = "10ns. \\n"]
    #[doc = "Bits    Parameter \\n"]
    #[doc = "31:19   RESERVED \\n"]
    #[doc = "18:0    Failure count, unsigned number. \\n"]
    pub freqFailCnt: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved2: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved3: rlUInt32_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon exceeding allotted bit \\n"]
    #[doc = "width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonSynthFreqRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonSynthFreqRep>(),
        28usize,
        concat!("Size of: ", stringify!(rlMonSynthFreqRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonSynthFreqRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonSynthFreqRep))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonSynthFreqRep>())).statusFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonSynthFreqRep>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonSynthFreqRep>())).profIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqRep),
            "::",
            stringify!(profIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonSynthFreqRep>())).reserved0 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqRep),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonSynthFreqRep>())).reserved1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqRep),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonSynthFreqRep>())).maxFreqErVal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqRep),
            "::",
            stringify!(maxFreqErVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonSynthFreqRep>())).freqFailCnt as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqRep),
            "::",
            stringify!(freqFailCnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonSynthFreqRep>())).reserved2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqRep),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonSynthFreqRep>())).reserved3 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqRep),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonSynthFreqRep>())).timeStamp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonSynthFreqRep_t = rlMonSynthFreqRep;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which RadarSS sends to the host, containing the external"]
#[doc = " signal voltage values measured using the GPADC. RadarSS sends this to host at the programmed"]
#[doc = " periodicity or when failure occurs, as programmed by the configuration API SB."]
#[doc = " Event: RL_RF_AE_MON_EXT_ANALOG_SIG_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonExtAnaSigRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding \\n"]
    #[doc = "to various threshold checks under this monitor. \\n"]
    #[doc = "Bit  STATUS_FLAG for monitor \\n"]
    #[doc = "0    STATUS_ANALOGTEST1 \\n"]
    #[doc = "1    STATUS_ANALOGTEST2 \\n"]
    #[doc = "2    STATUS_ANALOGTEST3 \\n"]
    #[doc = "3    STATUS_ANALOGTEST4 \\n"]
    #[doc = "4    STATUS_ANAMUX \\n"]
    #[doc = "5    STATUS_VSENSE \\n"]
    #[doc = "15:3 RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS  \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  MEASURED_VALUE \\n"]
    #[doc = "Bytes   SIGNAL \\n"]
    #[doc = "1:0     ANALOGTEST1 \\n"]
    #[doc = "3:2     ANALOGTEST2 \\n"]
    #[doc = "5:4     ANALOGTEST3 \\n"]
    #[doc = "7:6     ANALOGTEST4 \\n"]
    #[doc = "9:8     ANAMUX \\n"]
    #[doc = "11:10   VSENSE \\n"]
    #[doc = "1 LSB = 1.8V/1024  \\n"]
    pub extAnaSigVal: [rlInt16_t; 6usize],
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt32_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon exceeding allotted bit \\n"]
    #[doc = "width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonExtAnaSigRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonExtAnaSigRep>(),
        24usize,
        concat!("Size of: ", stringify!(rlMonExtAnaSigRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonExtAnaSigRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonExtAnaSigRep))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonExtAnaSigRep>())).statusFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonExtAnaSigRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonExtAnaSigRep>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonExtAnaSigRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonExtAnaSigRep>())).extAnaSigVal as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonExtAnaSigRep),
            "::",
            stringify!(extAnaSigVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonExtAnaSigRep>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonExtAnaSigRep),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonExtAnaSigRep>())).timeStamp as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonExtAnaSigRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonExtAnaSigRep_t = rlMonExtAnaSigRep;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which RadarSS sends to the host, containing information"]
#[doc = " about Internal TX internal analog signals. RadarSS sends this to host at the programmed"]
#[doc = " periodicity or when failure occurs, as programmed by the configuration API SB. Same structure"]
#[doc = " is applicable for Tx0/Tx1/Tx2 monitoring report. Event: RL_RF_AE_MON_TXn_INT_ANA_SIG_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonTxIntAnaSigRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding to various threshold \\n"]
    #[doc = "checks under this monitor. \\n"]
    #[doc = "Bit  STATUS_FLAG for monitor \\n"]
    #[doc = "[0]  STATUS_SUPPLY_TXn \\n"]
    #[doc = "[1]  STATUS_DCBIAS_TXn \\n"]
    #[doc = "[2]  STATUS_PS_DAC_TXn \\n"]
    #[doc = "[15:3]RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS  \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  Profile Index for which this monitoring report applies."]
    pub profIndex: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Phase shifter DAC I arm delta min value across different DAC settings"]
    #[doc = "1 LSB = 1.8V/1024"]
    #[doc = "@note : This field is applicable only for xWR6843 and xWR1843 devices only."]
    pub phShiftDacIdeltaMin: rlUInt8_t,
    #[doc = " @brief  Phase shifter DAC Q arm delta min value across different DAC settings"]
    #[doc = "1 LSB = 1.8V/1024"]
    #[doc = "@note : This field is applicable only for xWR6843 and xWR1843 devices only."]
    pub phShiftDacQdeltaMin: rlUInt8_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon \\n"]
    #[doc = "exceeding allotted bit width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonTxIntAnaSigRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonTxIntAnaSigRep>(),
        12usize,
        concat!("Size of: ", stringify!(rlMonTxIntAnaSigRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonTxIntAnaSigRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonTxIntAnaSigRep))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonTxIntAnaSigRep>())).statusFlags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxIntAnaSigRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxIntAnaSigRep>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxIntAnaSigRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxIntAnaSigRep>())).profIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxIntAnaSigRep),
            "::",
            stringify!(profIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxIntAnaSigRep>())).reserved0 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxIntAnaSigRep),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonTxIntAnaSigRep>())).phShiftDacIdeltaMin as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxIntAnaSigRep),
            "::",
            stringify!(phShiftDacIdeltaMin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonTxIntAnaSigRep>())).phShiftDacQdeltaMin as *const _
                as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxIntAnaSigRep),
            "::",
            stringify!(phShiftDacQdeltaMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonTxIntAnaSigRep>())).timeStamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonTxIntAnaSigRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonTxIntAnaSigRep_t = rlMonTxIntAnaSigRep;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which RadarSS sends to the host, containing information"]
#[doc = " about Internal RX internal analog signals. RadarSS sends this to host at the programmed"]
#[doc = " periodicity or when failure occurs, as programmed by the configuration API SB."]
#[doc = " Event: RL_RF_AE_MON_RX_INT_ANALOG_SIG_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonRxIntAnaSigRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding to various threshold \\n"]
    #[doc = "checks under this monitor. \\n"]
    #[doc = "Bit      STATUS_FLAG for monitor \\n"]
    #[doc = "0        STATUS_SUPPLY_RX0 \\n"]
    #[doc = "1        STATUS_SUPPLY_RX1 \\n"]
    #[doc = "2        STATUS_SUPPLY_RX2 \\n"]
    #[doc = "3        STATUS_SUPPLY_RX3 \\n"]
    #[doc = "4        STATUS_DCBIAS_RX0 \\n"]
    #[doc = "5        STATUS_DCBIAS_RX1 \\n"]
    #[doc = "6        STATUS_DCBIAS_RX2 \\n"]
    #[doc = "7        STATUS_DCBIAS_RX3 \\n"]
    #[doc = "15:8    RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS  \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  Profile Index for which this monitoring report applies."]
    pub profIndex: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon exceeding allotted bit \\n"]
    #[doc = "width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonRxIntAnaSigRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonRxIntAnaSigRep>(),
        12usize,
        concat!("Size of: ", stringify!(rlMonRxIntAnaSigRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonRxIntAnaSigRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonRxIntAnaSigRep))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonRxIntAnaSigRep>())).statusFlags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIntAnaSigRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIntAnaSigRep>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIntAnaSigRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIntAnaSigRep>())).profIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIntAnaSigRep),
            "::",
            stringify!(profIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIntAnaSigRep>())).reserved0 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIntAnaSigRep),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIntAnaSigRep>())).reserved1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIntAnaSigRep),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxIntAnaSigRep>())).timeStamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxIntAnaSigRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonRxIntAnaSigRep_t = rlMonRxIntAnaSigRep;
#[doc = " \\brief"]
#[doc = " This API is a Monitoring Report API which the AWR device sends to the host, containing"]
#[doc = " information about Internal PM, CLK and LO subsystems' internal analog signals and in cascade"]
#[doc = " devices the 20GHz SYNC IN/OUT power. The AWR device sends this to host at the programmed"]
#[doc = " periodicity or when failure occurs, as programmed by the configuration API SB."]
#[doc = " Event: RL_RF_AE_MON_PMCLKLO_INT_ANA_SIG_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonPmclkloIntAnaSigRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding to various threshold \\n"]
    #[doc = "checks under this monitor. \\n"]
    #[doc = "Bit      STATUS_FLAG for monitor \\n"]
    #[doc = "0        STATUS_SUPPLY_PMCLKLO \\n"]
    #[doc = "1        STATUS_DCBIAS_PMCLKLO \\n"]
    #[doc = "2        STATUS_LVDS_PMCLKLO (Use this status bit only if LVDS is used, \\n"]
    #[doc = "else ignorethis) \\n"]
    #[doc = "3        RESERVED \\n"]
    #[doc = "15:4     RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS  \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  Profile Index for which this monitoring report applies."]
    pub profIndex: rlUInt8_t,
    #[doc = " @brief  Monitored 20GHz signal power, signed number \\n"]
    #[doc = "         1 LSB = 0.5 dBm \\n"]
    #[doc = "         The 20GHz SYNC monitor is done at 77GHz RF frequency. \\n"]
    #[doc = "         @note : This field is not supported in xWR6x43 devices."]
    pub sync20GPower: rlInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt16_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon \\n"]
    #[doc = "exceeding allotted bit width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonPmclkloIntAnaSigRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonPmclkloIntAnaSigRep>(),
        12usize,
        concat!("Size of: ", stringify!(rlMonPmclkloIntAnaSigRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonPmclkloIntAnaSigRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonPmclkloIntAnaSigRep))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonPmclkloIntAnaSigRep>())).statusFlags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonPmclkloIntAnaSigRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonPmclkloIntAnaSigRep>())).errorCode as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonPmclkloIntAnaSigRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonPmclkloIntAnaSigRep>())).profIndex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonPmclkloIntAnaSigRep),
            "::",
            stringify!(profIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonPmclkloIntAnaSigRep>())).sync20GPower as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonPmclkloIntAnaSigRep),
            "::",
            stringify!(sync20GPower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonPmclkloIntAnaSigRep>())).reserved as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonPmclkloIntAnaSigRep),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonPmclkloIntAnaSigRep>())).timeStamp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonPmclkloIntAnaSigRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonPmclkloIntAnaSigRep_t = rlMonPmclkloIntAnaSigRep;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which RadarSS sends to the host, containing information"]
#[doc = " about the measured value of the GPADC input DC signals whose measurements were enabled."]
#[doc = " RadarSS sends this to host at the programmed periodicity or when failure occurs, as programmed"]
#[doc = " by the configuration API."]
#[doc = " SB. Event: RL_RF_AE_MON_GPADC_INT_ANA_SIG_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonGpadcIntAnaSigRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding to various threshold \\n"]
    #[doc = "checks under this monitor. \\n"]
    #[doc = "Bit      STATUS_FLAG for monitor \\n"]
    #[doc = "0        STATUS_GPADC_REF1 \\n"]
    #[doc = "1        STATUS_GPADC_REF2 \\n"]
    #[doc = "15:2     RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS  \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  The measured GPADC outputs corresponding to internal DC signal (GPADC_REF1, \\n"]
    #[doc = "expected level 0.45V) is reported here. \\n"]
    #[doc = "1 LSB = 1.8V/1024  \\n"]
    pub gpadcRef1Val: rlInt16_t,
    #[doc = " @brief  The measured GPADC outputs corresponding to internal DC signal (GPADC_REF2, \\n"]
    #[doc = "expected level 1.2V) is reported here. \\n"]
    #[doc = "1 LSB = 1.8V/1024  \\n"]
    pub gpadcRef2Val: rlUInt16_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt32_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon exceeding allotted bit \\n"]
    #[doc = "width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonGpadcIntAnaSigRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonGpadcIntAnaSigRep>(),
        16usize,
        concat!("Size of: ", stringify!(rlMonGpadcIntAnaSigRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonGpadcIntAnaSigRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonGpadcIntAnaSigRep))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonGpadcIntAnaSigRep>())).statusFlags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonGpadcIntAnaSigRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonGpadcIntAnaSigRep>())).errorCode as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonGpadcIntAnaSigRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonGpadcIntAnaSigRep>())).gpadcRef1Val as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonGpadcIntAnaSigRep),
            "::",
            stringify!(gpadcRef1Val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonGpadcIntAnaSigRep>())).gpadcRef2Val as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonGpadcIntAnaSigRep),
            "::",
            stringify!(gpadcRef2Val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonGpadcIntAnaSigRep>())).reserved as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonGpadcIntAnaSigRep),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonGpadcIntAnaSigRep>())).timeStamp as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonGpadcIntAnaSigRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonGpadcIntAnaSigRep_t = rlMonGpadcIntAnaSigRep;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which RadarSS sends to the host, containing the measured PLL"]
#[doc = " control voltage values during explicit monitoring chirps. RadarSS sends this to host at the"]
#[doc = " programmed periodicity or when failure occurs, as programmed by the configuration API SB."]
#[doc = " Event: RL_RF_AE_MON_PLL_CONTROL_VOLT_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonPllConVoltRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding to various threshold \\n"]
    #[doc = "checks under this monitor. \\n"]
    #[doc = "Bit      STATUS_FLAG for monitor \\n"]
    #[doc = "0        STATUS_APLL_VCTRL \\n"]
    #[doc = "1        STATUS_SYNTH_VCO1_VCTRL_MAX_ FREQ \\n"]
    #[doc = "2        STATUS_SYNTH_VCO1_VCTRL_MIN_ FREQ \\n"]
    #[doc = "3        RESERVED \\n"]
    #[doc = "4        STATUS_SYNTH_VCO2_VCTRL_MAX_ FREQ \\n"]
    #[doc = "5        STATUS_SYNTH_VCO2_VCTRL_MIN_ FREQ \\n"]
    #[doc = "6        RESERVED \\n"]
    #[doc = "15:7     RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  The measured values of PLL control voltage levels and Synthesizer VCO slopes are \\n"]
    #[doc = "reported here. Byte numbers corresponding to different control voltage \\n"]
    #[doc = "values reported in this field are here:  \\n"]
    #[doc = "Bytes   SIGNAL                              1 LSB \\n"]
    #[doc = "1:0     APLL_VCTRL                          1mV  \\n"]
    #[doc = "3:2     SYNTH_VCO1_VCTRL_MAX_ FREQ          1mV \\n"]
    #[doc = "5:4     SYNTH_VCO1_VCTRL_MIN_ FREQ          1mV \\n"]
    #[doc = "7:6     SYNTH_VCO1_SLOPE                    1MHz/V \\n"]
    #[doc = "9:8     SYNTH_VCO2_VCTRL_MAX_ FREQ          1mV \\n"]
    #[doc = "11:10   SYNTH_VCO2_VCTRL_MIN_ FREQ          1mV \\n"]
    #[doc = "13:12   SYNTH_VCO2_SLOPE                    1MHz/V \\n"]
    #[doc = "15:14   RESERVED                            RESERVED \\n"]
    #[doc = "Only the fields corresponding to the enabled monitors are valid.  \\n"]
    #[doc = "The failure thresholds are based on the following: \\n"]
    #[doc = "Valid VCTRL values are [140 to 1400] mV. \\n"]
    #[doc = "Valid VCO1_SLOPE values are [1760 to 2640] MHz/V. \\n"]
    #[doc = "Valid VCO2_SLOPE values are [3520 to 5280] MHz/V. \\n"]
    #[doc = "@note : The VCOx SLOPE should be ignored when synth fault is injected. \\n"]
    pub pllContVoltVal: [rlInt16_t; 8usize],
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt32_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon exceeding allotted bit \\n"]
    #[doc = "width)"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonPllConVoltRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonPllConVoltRep>(),
        28usize,
        concat!("Size of: ", stringify!(rlMonPllConVoltRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonPllConVoltRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonPllConVoltRep))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonPllConVoltRep>())).statusFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonPllConVoltRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonPllConVoltRep>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonPllConVoltRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonPllConVoltRep>())).pllContVoltVal as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonPllConVoltRep),
            "::",
            stringify!(pllContVoltVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonPllConVoltRep>())).reserved as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonPllConVoltRep),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonPllConVoltRep>())).timeStamp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonPllConVoltRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonPllConVoltRep_t = rlMonPllConVoltRep;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which RadarSS sends to the host, containing information about"]
#[doc = " the relative frequency measurements. RadarSS sends this to host at the programmed periodicity or"]
#[doc = " when failure occurs, as programmed by the configuration API SB."]
#[doc = " Event: RL_RF_AE_MON_DCC_CLK_FREQ_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonDccClkFreqRep {
    #[doc = " @brief  Status flags indicating pass fail results corresponding to various threshold \\n"]
    #[doc = "checks under this monitor. \\n"]
    #[doc = "Bit      STATUS_FLAG for monitor \\n"]
    #[doc = "0        STATUS_CLK_PAIR0 \\n"]
    #[doc = "1        STATUS_CLK_PAIR1 \\n"]
    #[doc = "2        STATUS_CLK_PAIR2 \\n"]
    #[doc = "3        STATUS_CLK_PAIR3 \\n"]
    #[doc = "4        STATUS_CLK_PAIR4 \\n"]
    #[doc = "15:5    RESERVED \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief  Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  The measured clock frequencies from the enabled clock pair measurements are \\n"]
    #[doc = "reported here.Byte numbers corresponding to different frequency measurement \\n"]
    #[doc = "values reported in this field are here: \\n"]
    #[doc = "Bytes   CLOCK PAIR  MEASURED CLOCK FREQUENCY \\n"]
    #[doc = "1:0     0           BSS_600M \\n"]
    #[doc = "3:2     1           BSS_200M \\n"]
    #[doc = "5:4     2           BSS_100M \\n"]
    #[doc = "7:6     3           GPADC_10M \\n"]
    #[doc = "9:8     4           RCOSC_10M \\n"]
    #[doc = "15:10   RESERVED    RESERVED \\n"]
    #[doc = "1 LSB = 0.1 MHz, unsigned number \\n"]
    pub freqMeasVal: [rlUInt16_t; 8usize],
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt32_t,
    #[doc = " @brief  This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon exceeding allotted bit \\n"]
    #[doc = "width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonDccClkFreqRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonDccClkFreqRep>(),
        28usize,
        concat!("Size of: ", stringify!(rlMonDccClkFreqRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonDccClkFreqRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonDccClkFreqRep))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonDccClkFreqRep>())).statusFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonDccClkFreqRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonDccClkFreqRep>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonDccClkFreqRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonDccClkFreqRep>())).freqMeasVal as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonDccClkFreqRep),
            "::",
            stringify!(freqMeasVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonDccClkFreqRep>())).reserved as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonDccClkFreqRep),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonDccClkFreqRep>())).timeStamp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonDccClkFreqRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonDccClkFreqRep_t = rlMonDccClkFreqRep;
#[doc = " \\brief"]
#[doc = " This is the Monitoring report which the xWR device sends to the host, containing the"]
#[doc = " measured RX mixer input voltage swing values. The xWR device sends this to host at the"]
#[doc = " programmed periodicity or when failure occurs, as programmed by the configuration API SB."]
#[doc = " Event: RL_RF_AE_MON_RX_MIXER_IN_PWR_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonRxMixrInPwrRep {
    #[doc = " @brief Status flags indicating pass fail results corresponding \\n"]
    #[doc = "to various threshold checks under this monitor. \\n"]
    #[doc = "Bit      STATUS_FLAG for monitor \\n"]
    #[doc = "0        STATUS_MIXER_IN_POWER_RX0 \\n"]
    #[doc = "1        STATUS_MIXER_IN_POWER_RX1 \\n"]
    #[doc = "2        STATUS_MIXER_IN_POWER_RX2 \\n"]
    #[doc = "3        STATUS_MIXER_IN_POWER_RX3 \\n"]
    #[doc = "15:4     RESERVED          \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  Profile Index for which this monitoring report applies."]
    pub profIndex: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief The measured RX mixer input voltage swing values are \\n"]
    #[doc = "reported here. The byte location of the value for each \\n"]
    #[doc = "receivers is tabulated here- \\n"]
    #[doc = "Byte location \\n"]
    #[doc = "Rx0  0  \\n"]
    #[doc = "Rx1  1  \\n"]
    #[doc = "Rx2  2  \\n"]
    #[doc = "Rx3  3  \\n"]
    #[doc = "1 LSB = 1800 mV/256, unsigned number \\n"]
    #[doc = "Only the entries of enabled RX channels are valid. \\n"]
    pub rxMixInVolt: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved2: rlUInt32_t,
    #[doc = " @brief This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon exceeding allotted bit width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonRxMixrInPwrRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonRxMixrInPwrRep>(),
        20usize,
        concat!("Size of: ", stringify!(rlMonRxMixrInPwrRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonRxMixrInPwrRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonRxMixrInPwrRep))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonRxMixrInPwrRep>())).statusFlags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxMixrInPwrRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxMixrInPwrRep>())).errorCode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxMixrInPwrRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxMixrInPwrRep>())).profIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxMixrInPwrRep),
            "::",
            stringify!(profIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxMixrInPwrRep>())).reserved0 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxMixrInPwrRep),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxMixrInPwrRep>())).reserved1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxMixrInPwrRep),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonRxMixrInPwrRep>())).rxMixInVolt as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxMixrInPwrRep),
            "::",
            stringify!(rxMixInVolt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxMixrInPwrRep>())).reserved2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxMixrInPwrRep),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonRxMixrInPwrRep>())).timeStamp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonRxMixrInPwrRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonRxMixrInPwrRep_t = rlMonRxMixrInPwrRep;
#[doc = " \\brief"]
#[doc = " This is a Non live Monitoring report which device sends to the host, containing information"]
#[doc = " related to measured frequency error during the monitoring chirp for two profiles"]
#[doc = " configurations. The device sends this to host at the programmed periodicity or when failure"]
#[doc = " occurs, as programmed by the configuration API SB."]
#[doc = " This is a new feature addition in xWR6843 device only."]
#[doc = " Event: RL_RF_AE_MON_SYNTH_FREQ_NONLIVE_REPORT"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonSynthFreqNonLiveRep {
    #[doc = " @brief Status flags indicating pass fail results corresponding \\n"]
    #[doc = "to various threshold checks under this monitor. \\n"]
    #[doc = "Bit      STATUS_FLAG for monitor \\n"]
    #[doc = "0        VCO1_SYNTH_FREQ_ERR_STATUS \\n"]
    #[doc = "1        VCO2_SYNTH_FREQ_ERR_STATUS \\n"]
    #[doc = "15:2     RESERVED          \\n"]
    #[doc = "0 - FAIL or check wasn't done, 1 - PASS \\n"]
    pub statusFlags: rlUInt16_t,
    #[doc = " @brief Indicates any error reported during monitoring Value of 0 indicates no error"]
    pub errorCode: rlUInt16_t,
    #[doc = " @brief  VCO1 Profile index for which this monitoring report applies."]
    pub profIndex0: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  This field indicates the maximum instantaneous frequency error measured during"]
    #[doc = "the monitoring chirp for which frequency monitoring has been enabled in the"]
    #[doc = "previous monitoring period for VCO1 profile. \\n"]
    #[doc = "Bits    Parameter \\n"]
    #[doc = "31:0    Maximum frequency error value, signed number. 1 LSB = 1kHz. \\n"]
    pub maxFreqErVal0: rlInt32_t,
    #[doc = " @brief  This field indicates the number of times during chirping in the previous"]
    #[doc = "monitoring period in which the measured frequency error violated the allowed"]
    #[doc = "threshold for VCO1 profile. Frequency error threshold violation is"]
    #[doc = "counted every 10 ns. \\n"]
    #[doc = "Bits    Parameter \\n"]
    #[doc = "31:19   RESERVED \\n"]
    #[doc = "18:0    Failure count, unsigned number. \\n"]
    pub freqFailCnt0: rlUInt32_t,
    #[doc = " @brief  This field indicates the time at which error occurred for VCO1 profile w.r.t. knee"]
    #[doc = "of the ramp. \\n"]
    #[doc = "1 LSB = 10ns \\n"]
    pub maxFreqFailTime0: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved2: rlUInt32_t,
    #[doc = " @brief  VCO2 Profile index for which this monitoring report applies."]
    pub profIndex1: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved3: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved4: rlUInt16_t,
    #[doc = " @brief  This field indicates the maximum instantaneous frequency error measured during"]
    #[doc = "the monitoring chirp for which frequency monitoring has been enabled in the"]
    #[doc = "previous monitoring period for VCO2 profile. \\n"]
    #[doc = "Bits    Parameter \\n"]
    #[doc = "31:0    Maximum frequency error value, signed number. 1 LSB = 1kHz. \\n"]
    pub maxFreqErVal1: rlInt32_t,
    #[doc = " @brief  This field indicates the number of times during chirping in the previous"]
    #[doc = "monitoring period in which the measured frequency error violated the allowed"]
    #[doc = "threshold for VCO2 profile. Frequency error threshold violation is"]
    #[doc = "counted every 10 ns. \\n"]
    #[doc = "Bits    Parameter \\n"]
    #[doc = "31:19   RESERVED \\n"]
    #[doc = "18:0    Failure count, unsigned number. \\n"]
    pub freqFailCnt1: rlUInt32_t,
    #[doc = " @brief  This field indicates the time at which error occurred for VCO2 profile w.r.t. knee"]
    #[doc = "of the ramp. \\n"]
    #[doc = "1 LSB = 10ns \\n"]
    pub maxFreqFailTime1: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved5: rlUInt32_t,
    #[doc = " @brief This field indicates when the last monitoring in the enabled set was performed. \\n"]
    #[doc = "1 LSB = 1 millisecond (the stamp rolls over upon exceeding allotted bit width) \\n"]
    pub timeStamp: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonSynthFreqNonLiveRep() {
    assert_eq!(
        ::core::mem::size_of::<rlMonSynthFreqNonLiveRep>(),
        48usize,
        concat!("Size of: ", stringify!(rlMonSynthFreqNonLiveRep))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonSynthFreqNonLiveRep>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonSynthFreqNonLiveRep))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).statusFlags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).errorCode as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(errorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).profIndex0 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(profIndex0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).reserved0 as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).reserved1 as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).maxFreqErVal0 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(maxFreqErVal0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).freqFailCnt0 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(freqFailCnt0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).maxFreqFailTime0 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(maxFreqFailTime0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).reserved2 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).profIndex1 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(profIndex1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).reserved3 as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).reserved4 as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).maxFreqErVal1 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(maxFreqErVal1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).freqFailCnt1 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(freqFailCnt1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).maxFreqFailTime1 as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(maxFreqFailTime1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).reserved5 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlMonSynthFreqNonLiveRep>())).timeStamp as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonSynthFreqNonLiveRep),
            "::",
            stringify!(timeStamp)
        )
    );
}
pub type rlMonSynthFreqNonLiveRep_t = rlMonSynthFreqNonLiveRep;
#[doc = " \\brief"]
#[doc = " This is an error status report internally generated from mmWaveLink when it finds any"]
#[doc = " issue with the recieved message or communication. Currently errorVal can be"]
#[doc = " RL_RET_CODE_CRC_FAILED, RL_RET_CODE_CHKSUM_FAILED or RL_RET_CODE_HOSTIRQ_TIMEOUT."]
#[doc = " Event: RL_MMWL_AE_MISMATCH_REPORT, RL_MMWL_AE_INTERNALERR_REPORT"]
#[doc = " ErroVal: RL_RET_CODE_CRC_FAILED, RL_RET_CODE_CHKSUM_FAILED or RL_RET_CODE_HOSTIRQ_TIMEOUT"]
#[doc = "          for RL_MMWL_AE_MISMATCH_REPORT Event and RL_RET_CODE_RADAR_OSIF_ERROR for"]
#[doc = "          RL_MMWL_AE_INTERNALERR_REPORT Event"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMmwlErrorStatus {
    pub errorVal: rlInt32_t,
}
#[test]
fn bindgen_test_layout_rlMmwlErrorStatus() {
    assert_eq!(
        ::core::mem::size_of::<rlMmwlErrorStatus>(),
        4usize,
        concat!("Size of: ", stringify!(rlMmwlErrorStatus))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMmwlErrorStatus>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMmwlErrorStatus))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMmwlErrorStatus>())).errorVal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMmwlErrorStatus),
            "::",
            stringify!(errorVal)
        )
    );
}
pub type rlMmwlErrorStatus_t = rlMmwlErrorStatus;
#[doc = " \\brief"]
#[doc = " mmWaveLink API Error Type"]
pub type rlSysNRespType_t = rlUInt16_t;
#[doc = " \\brief"]
#[doc = " mmWaveLink API Error Sub block structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlErrorResp {
    #[doc = "@ brief  16 bits error type"]
    pub errorType: rlSysNRespType_t,
    #[doc = "@ brief  16 bits SBC ID"]
    pub sbcID: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlErrorResp() {
    assert_eq!(
        ::core::mem::size_of::<rlErrorResp>(),
        4usize,
        concat!("Size of: ", stringify!(rlErrorResp))
    );
    assert_eq!(
        ::core::mem::align_of::<rlErrorResp>(),
        2usize,
        concat!("Alignment of ", stringify!(rlErrorResp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlErrorResp>())).errorType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlErrorResp),
            "::",
            stringify!(errorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlErrorResp>())).sbcID as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlErrorResp),
            "::",
            stringify!(sbcID)
        )
    );
}
pub type rlErrorResp_t = rlErrorResp;
#[doc = " \\brief"]
#[doc = " RHCP SYNC Pattern Structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlSyncPattern {
    pub sync1: rlUInt16_t,
    pub sync2: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlSyncPattern() {
    assert_eq!(
        ::core::mem::size_of::<rlSyncPattern>(),
        4usize,
        concat!("Size of: ", stringify!(rlSyncPattern))
    );
    assert_eq!(
        ::core::mem::align_of::<rlSyncPattern>(),
        2usize,
        concat!("Alignment of ", stringify!(rlSyncPattern))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSyncPattern>())).sync1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSyncPattern),
            "::",
            stringify!(sync1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSyncPattern>())).sync2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSyncPattern),
            "::",
            stringify!(sync2)
        )
    );
}
pub type rlSyncPattern_t = rlSyncPattern;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlOpcode {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_rlOpcode() {
    assert_eq!(
        ::core::mem::size_of::<rlOpcode>(),
        2usize,
        concat!("Size of: ", stringify!(rlOpcode))
    );
    assert_eq!(
        ::core::mem::align_of::<rlOpcode>(),
        2usize,
        concat!("Alignment of ", stringify!(rlOpcode))
    );
}
impl rlOpcode {
    #[inline]
    pub fn b4Direction(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_b4Direction(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn b2MsgType(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_b2MsgType(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn b10MsgId(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 10u8) as u16) }
    }
    #[inline]
    pub fn set_b10MsgId(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        b4Direction: rlUInt16_t,
        b2MsgType: rlUInt16_t,
        b10MsgId: rlUInt16_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let b4Direction: u16 = unsafe { ::core::mem::transmute(b4Direction) };
            b4Direction as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let b2MsgType: u16 = unsafe { ::core::mem::transmute(b2MsgType) };
            b2MsgType as u64
        });
        __bindgen_bitfield_unit.set(6usize, 10u8, {
            let b10MsgId: u16 = unsafe { ::core::mem::transmute(b10MsgId) };
            b10MsgId as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rlOpcode_t = rlOpcode;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlHdrFlags {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_rlHdrFlags() {
    assert_eq!(
        ::core::mem::size_of::<rlHdrFlags>(),
        2usize,
        concat!("Size of: ", stringify!(rlHdrFlags))
    );
    assert_eq!(
        ::core::mem::align_of::<rlHdrFlags>(),
        2usize,
        concat!("Alignment of ", stringify!(rlHdrFlags))
    );
}
impl rlHdrFlags {
    #[inline]
    pub fn b2RetryFlag(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_b2RetryFlag(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn b2AckFlag(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_b2AckFlag(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn b4Version(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_b4Version(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn b2Crc(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_b2Crc(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn b2CrcLen(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_b2CrcLen(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn b4SeqNum(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_b4SeqNum(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        b2RetryFlag: rlUInt16_t,
        b2AckFlag: rlUInt16_t,
        b4Version: rlUInt16_t,
        b2Crc: rlUInt16_t,
        b2CrcLen: rlUInt16_t,
        b4SeqNum: rlUInt16_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let b2RetryFlag: u16 = unsafe { ::core::mem::transmute(b2RetryFlag) };
            b2RetryFlag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let b2AckFlag: u16 = unsafe { ::core::mem::transmute(b2AckFlag) };
            b2AckFlag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let b4Version: u16 = unsafe { ::core::mem::transmute(b4Version) };
            b4Version as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let b2Crc: u16 = unsafe { ::core::mem::transmute(b2Crc) };
            b2Crc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let b2CrcLen: u16 = unsafe { ::core::mem::transmute(b2CrcLen) };
            b2CrcLen as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let b4SeqNum: u16 = unsafe { ::core::mem::transmute(b4SeqNum) };
            b4SeqNum as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rlHdrFlags_t = rlHdrFlags;
#[doc = " \\brief"]
#[doc = " RHCP protocol header structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlProtHeader {
    #[doc = " @brief  rlUInt16_t, rlApiActionType,rlApiGetSetType"]
    pub opcode: rlOpcode_t,
    pub len: rlUInt16_t,
    pub flags: rlHdrFlags_t,
    pub remChunks: rlUInt16_t,
    pub nsbc: rlUInt16_t,
    pub chksum: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlProtHeader() {
    assert_eq!(
        ::core::mem::size_of::<rlProtHeader>(),
        12usize,
        concat!("Size of: ", stringify!(rlProtHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<rlProtHeader>(),
        2usize,
        concat!("Alignment of ", stringify!(rlProtHeader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProtHeader>())).opcode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProtHeader),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProtHeader>())).len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProtHeader),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProtHeader>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProtHeader),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProtHeader>())).remChunks as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProtHeader),
            "::",
            stringify!(remChunks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProtHeader>())).nsbc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProtHeader),
            "::",
            stringify!(nsbc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProtHeader>())).chksum as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProtHeader),
            "::",
            stringify!(chksum)
        )
    );
}
pub type rlProtHeader_t = rlProtHeader;
#[doc = " \\brief"]
#[doc = " RHCP message structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rlRhcpMsg {
    pub syncPattern: rlSyncPattern_t,
    pub hdr: rlProtHeader_t,
    pub payload: [rlUInt8_t; 240usize],
}
#[test]
fn bindgen_test_layout_rlRhcpMsg() {
    assert_eq!(
        ::core::mem::size_of::<rlRhcpMsg>(),
        256usize,
        concat!("Size of: ", stringify!(rlRhcpMsg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRhcpMsg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlRhcpMsg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRhcpMsg>())).syncPattern as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRhcpMsg),
            "::",
            stringify!(syncPattern)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRhcpMsg>())).hdr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRhcpMsg),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRhcpMsg>())).payload as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRhcpMsg),
            "::",
            stringify!(payload)
        )
    );
}
impl Default for rlRhcpMsg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlRhcpMsg_t = rlRhcpMsg;
#[doc = " \\brief"]
#[doc = " File Dowload data structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rlFileData {
    #[doc = " @brief  File data length"]
    pub chunkLen: rlUInt32_t,
    #[doc = " @brief  File data buffer"]
    pub fData: [rlUInt16_t; 116usize],
}
#[test]
fn bindgen_test_layout_rlFileData() {
    assert_eq!(
        ::core::mem::size_of::<rlFileData>(),
        236usize,
        concat!("Size of: ", stringify!(rlFileData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlFileData>(),
        4usize,
        concat!("Alignment of ", stringify!(rlFileData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFileData>())).chunkLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFileData),
            "::",
            stringify!(chunkLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFileData>())).fData as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFileData),
            "::",
            stringify!(fData)
        )
    );
}
impl Default for rlFileData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlFileData_t = rlFileData;
#[doc = " \\brief"]
#[doc = " mmwave radar device MCU Clock output"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMcuClkCfg {
    #[doc = " @brief  This field controls the enable - disable of the MCU clock. \\n"]
    #[doc = "Value    Description \\n"]
    #[doc = "0x0      Disable MCU clock \\n"]
    #[doc = "0x1      Enable MCU clock  \\n"]
    pub mcuClkCtrl: rlUInt8_t,
    #[doc = " @brief  This field specifies the source of the MCU clock. Applicable only in case of MCU \\n"]
    #[doc = "clock enable.Else ignored. \\n"]
    #[doc = "Value   Description \\n"]
    #[doc = "0x0     XTAL(as connected to the device) \\n"]
    #[doc = "0x1     RESERVED \\n"]
    #[doc = "0x2     600MHz PLL divided clock \\n"]
    pub mcuClkSrc: rlUInt8_t,
    #[doc = " @brief  This field specifies the division factor to be applied to source clock. \\n"]
    #[doc = "Applicable only in case of MCU \\n"]
    #[doc = "clock enable. Else ignored. \\n"]
    #[doc = "Value     Description \\n"]
    #[doc = "0x0       Divide by 1 \\n"]
    #[doc = "0x1       Divide by 2 \\n"]
    #[doc = "...       ... \\n"]
    #[doc = "0xFF      Divide by 256 \\n"]
    pub srcClkDiv: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlMcuClkCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlMcuClkCfg>(),
        4usize,
        concat!("Size of: ", stringify!(rlMcuClkCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMcuClkCfg>(),
        1usize,
        concat!("Alignment of ", stringify!(rlMcuClkCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMcuClkCfg>())).mcuClkCtrl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMcuClkCfg),
            "::",
            stringify!(mcuClkCtrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMcuClkCfg>())).mcuClkSrc as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMcuClkCfg),
            "::",
            stringify!(mcuClkSrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMcuClkCfg>())).srcClkDiv as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMcuClkCfg),
            "::",
            stringify!(srcClkDiv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMcuClkCfg>())).reserved as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMcuClkCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlMcuClkCfg_t = rlMcuClkCfg;
#[doc = " \\brief"]
#[doc = " mmwave radar device PMIC Clock output"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlPmicClkCfg {
    #[doc = " @brief  This field controls the enable - disable of the PMIC clock. \\n"]
    #[doc = "Value  Description \\n"]
    #[doc = "0x0    Disable PMIC clock \\n"]
    #[doc = "0x1    Enable PMIC clock \\n"]
    pub pmicClkCtrl: rlUInt8_t,
    #[doc = " @brief  This field specifies the source of the PMIC clock. Applicable only in case of \\n"]
    #[doc = "PMIC clock enable. Else ignored. \\n"]
    #[doc = "Value   Description \\n"]
    #[doc = "0x0     XTAL (as connected to the device) \\n"]
    #[doc = "0x2     600MHz PLL divided clock \\n"]
    pub pmicClkSrc: rlUInt8_t,
    #[doc = " @brief  This field specifies the division factor to be applie to source clock. \\n"]
    #[doc = "Applicable only in case of PMIC clock \\n"]
    #[doc = "enable. Else ignored. \\n"]
    #[doc = "Value   Description \\n"]
    #[doc = "0x0     Divide by 1 (Not supported) \\n"]
    #[doc = "0x1     Divide by 2 \\n"]
    #[doc = "...     ... \\n"]
    #[doc = "0xFF    Divide by 256 \\n"]
    pub srcClkDiv: rlUInt8_t,
    #[doc = " @brief  This field specifies the mode of operation for the PMIC clock generation. \\n"]
    #[doc = "Applicable only in case of PMIC clock \\n"]
    #[doc = "enable. Else ignored. \\n"]
    #[doc = "Value   Description \\n"]
    #[doc = "0x0     Continuous mode (free running mode where the frequency \\n"]
    #[doc = "change/jump is triggered based on configured number of \\n"]
    #[doc = "internal clock ticks) \\n"]
    #[doc = "0x1     Chirp-to-Chirp staircase mode (frequency change/jump is \\n"]
    #[doc = "triggered at every chirp boundary) \\n"]
    pub modeSel: rlUInt8_t,
    #[doc = " @brief  Applicable only in case of PMIC clock enable. Else ignored. \\n"]
    #[doc = "Bit[25:0] - Frequency slope value to be applied in [8.18] format. \\n"]
    #[doc = "1 LSB = 1/218 \\n"]
    #[doc = "In continuous mode this value is accumulated every PMIC clock tick \\n"]
    #[doc = "with the seed as MIN_NDIV_VAL till MAX_NDIV_VAL is reached \\n"]
    #[doc = "In the stair case mode this value is accumulated every chirp with the \\n"]
    #[doc = "seed as MIN_NDIV_VAL till MAX_NDIV_VAL is reached \\n"]
    pub freqSlope: rlUInt32_t,
    #[doc = " @brief  Applicable only in case of PMIC clock enable. Else ignored. Min allowed divider \\n"]
    #[doc = "value (depends upon the highest desired clock frequency) \\n"]
    pub minNdivVal: rlUInt8_t,
    #[doc = " @brief  Applicable only in case of PMIC clock enable. Else ignored. Max allowed divider \\n"]
    #[doc = "value (depends upon the lowest desired clock frequency) \\n"]
    pub maxNdivVal: rlUInt8_t,
    #[doc = " @brief  Applicable only in case of PMIC clock enable. Else ignored. This field controls \\n"]
    #[doc = "the enable-disable of the clock dithering. Adds a pseudo random real number \\n"]
    #[doc = "(0 or 1) to the accumulated divide value. Hence it brings a random dithering \\n"]
    #[doc = "of 1 LSB. \\n"]
    #[doc = "Value   Description \\n"]
    #[doc = "0x0     Clock dithering disabled \\n"]
    #[doc = "0x1     Clock dithering enabled \\n"]
    pub clkDitherEn: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlPmicClkCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlPmicClkCfg>(),
        12usize,
        concat!("Size of: ", stringify!(rlPmicClkCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlPmicClkCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlPmicClkCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlPmicClkCfg>())).pmicClkCtrl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmicClkCfg),
            "::",
            stringify!(pmicClkCtrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlPmicClkCfg>())).pmicClkSrc as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmicClkCfg),
            "::",
            stringify!(pmicClkSrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlPmicClkCfg>())).srcClkDiv as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmicClkCfg),
            "::",
            stringify!(srcClkDiv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlPmicClkCfg>())).modeSel as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmicClkCfg),
            "::",
            stringify!(modeSel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlPmicClkCfg>())).freqSlope as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmicClkCfg),
            "::",
            stringify!(freqSlope)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlPmicClkCfg>())).minNdivVal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmicClkCfg),
            "::",
            stringify!(minNdivVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlPmicClkCfg>())).maxNdivVal as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmicClkCfg),
            "::",
            stringify!(maxNdivVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlPmicClkCfg>())).clkDitherEn as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmicClkCfg),
            "::",
            stringify!(clkDitherEn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlPmicClkCfg>())).reserved as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmicClkCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlPmicClkCfg_t = rlPmicClkCfg;
#[doc = " \\brief"]
#[doc = " mmwave radar device latent fault test"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rllatentFault {
    #[doc = " @brief  Bits    Definition \\n"]
    #[doc = "0       RESERVED \\n"]
    #[doc = "1       DMA self-test \\n"]
    #[doc = "2       RESERVED \\n"]
    #[doc = "3       RTI self-test \\n"]
    #[doc = "4       RESERVED \\n"]
    #[doc = "5       EDMA self-test \\n"]
    #[doc = "6       CRC self-test \\n"]
    #[doc = "7       VIM self-test \\n"]
    #[doc = "8       RESERVED \\n"]
    #[doc = "9       Mailbox self-test \\n"]
    #[doc = "10      RESERVED \\n"]
    #[doc = "11      RESERVED \\n"]
    #[doc = "12      Generating NERROR \\n"]
    #[doc = "13      MibSPI single bit error test \\n"]
    #[doc = "14      MibSPI double bit error test \\n"]
    #[doc = "15      DMA Parity error \\n"]
    #[doc = "16      TCMA RAM single bit errors (Not supported, refer latest release note) \\n"]
    #[doc = "17      TCMB RAM single bit errors (Not supported, refer latest release note) \\n"]
    #[doc = "18      TCMA RAM double bit errors (Not supported, refer latest release note) \\n"]
    #[doc = "19      TCMB RAM double bit errors (Not supported, refer latest release note) \\n"]
    #[doc = "20      TCMA RAM parity errors (Not supported, refer latest release note) \\n"]
    #[doc = "21      TCMB RAM parity errors (Not supported, refer latest release note) \\n"]
    #[doc = "22      RESERVED \\n"]
    #[doc = "23      RESERVED \\n"]
    #[doc = "24      DMA MPU Region tests \\n"]
    #[doc = "25      MSS Mailbox Single bit errors \\n"]
    #[doc = "26      MSS Mailbox double bit errors \\n"]
    #[doc = "27      radarSS Mailbox Single bit errors \\n"]
    #[doc = "28      radarSS Mailbox double bit errors \\n"]
    #[doc = "29      EDMA MPU test \\n"]
    #[doc = "30      EDMA parity test \\n"]
    #[doc = "31      CSI2 parity test \\n"]
    pub testEn1: rlUInt32_t,
    #[doc = " @brief  Bits    Definition \\n"]
    #[doc = "0       RESERVED \\n"]
    #[doc = "1       RESERVED \\n"]
    #[doc = "2       RESERVED \\n"]
    #[doc = "3       VIM RAM parity test \\n"]
    #[doc = "4       SCI boot time test  \\n"]
    #[doc = "31:5    RESERVED \\n"]
    pub testEn2: rlUInt32_t,
    #[doc = " @brief  Value  Definition \\n"]
    #[doc = "0      Report is sent after test completion \\n"]
    #[doc = "1      Report is send only upon a failure \\n"]
    pub repMode: rlUInt8_t,
    #[doc = " @brief  Value  Definition \\n"]
    #[doc = "0      Production mode. Latent faults are tested and any failures are reported \\n"]
    #[doc = "1      Characterization mode. Faults are injected and failures are reported which \\n"]
    #[doc = "allows testing of the failure reporting \\n"]
    pub testMode: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rllatentFault() {
    assert_eq!(
        ::core::mem::size_of::<rllatentFault>(),
        12usize,
        concat!("Size of: ", stringify!(rllatentFault))
    );
    assert_eq!(
        ::core::mem::align_of::<rllatentFault>(),
        4usize,
        concat!("Alignment of ", stringify!(rllatentFault))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rllatentFault>())).testEn1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rllatentFault),
            "::",
            stringify!(testEn1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rllatentFault>())).testEn2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rllatentFault),
            "::",
            stringify!(testEn2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rllatentFault>())).repMode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rllatentFault),
            "::",
            stringify!(repMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rllatentFault>())).testMode as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rllatentFault),
            "::",
            stringify!(testMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rllatentFault>())).reserved as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rllatentFault),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rllatentFault_t = rllatentFault;
#[doc = " \\brief"]
#[doc = " mmwave radar periodicity test config"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlperiodicTest {
    #[doc = " @brief  1 LSB = 1 ms Periodicity at which tests need to be run \\n"]
    #[doc = "Minimum value is 40 ms \\n"]
    #[doc = "Maximum value is 150ms \\n"]
    #[doc = "@note : MSS Windowed WDT period is set to this periodicity and WDT can not \\n"]
    #[doc = "support period more than 150ms. \\n"]
    #[doc = ""]
    pub periodicity: rlUInt32_t,
    #[doc = " @brief  Bit value definition: 1 - Enable, 0 - Disable \\n"]
    #[doc = "Bit Monitoring type \\n"]
    #[doc = "0   PERIODIC_CONFG_REGISTER_READ_EN \\n"]
    #[doc = "1   ESM_MONITORING_EN \\n"]
    #[doc = "31:2  RESERVED \\n"]
    pub testEn: rlUInt32_t,
    #[doc = " @brief  Value   Definition \\n"]
    #[doc = "0      Report is sent every monitoring period \\n"]
    #[doc = "1      Report is sent only on a failure \\n"]
    pub repMode: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlperiodicTest() {
    assert_eq!(
        ::core::mem::size_of::<rlperiodicTest>(),
        12usize,
        concat!("Size of: ", stringify!(rlperiodicTest))
    );
    assert_eq!(
        ::core::mem::align_of::<rlperiodicTest>(),
        4usize,
        concat!("Alignment of ", stringify!(rlperiodicTest))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlperiodicTest>())).periodicity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlperiodicTest),
            "::",
            stringify!(periodicity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlperiodicTest>())).testEn as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlperiodicTest),
            "::",
            stringify!(testEn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlperiodicTest>())).repMode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlperiodicTest),
            "::",
            stringify!(repMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlperiodicTest>())).reserved0 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rlperiodicTest),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlperiodicTest>())).reserved1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlperiodicTest),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlperiodicTest_t = rlperiodicTest;
#[doc = " \\brief"]
#[doc = " mmwave radar test pattern config"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rltestPattern {
    #[doc = " @brief  This field controls the enable-disable of the generation of the test pattern. \\n"]
    #[doc = "Value   Description \\n"]
    #[doc = "0x0     Disable test pattern generation \\n"]
    #[doc = "0x1     Enable test pattern generation \\n"]
    pub testPatGenCtrl: rlUInt8_t,
    #[doc = " @brief  Number of system clocks (200 MHz) between successive samples for the test pattern \\n"]
    #[doc = "gen. Applicable only in case of Test pattern enable. Else ignored. \\n"]
    pub testPatGenTime: rlUInt8_t,
    #[doc = " @brief  Number of ADC samples to capture for each RX"]
    #[doc = "Valid range: 64 to MAX_NUM_SAMPLES,"]
    #[doc = "Where MAX_NUM_SAMPLES is such that all the enabled RX channels’ data fits into \\n"]
    #[doc = "16 kB memory, with each sample consuming 2 bytes for real ADC output case and 4 \\n"]
    #[doc = "bytes for complex 1x and complex 2x ADC output cases. For example:"]
    #[doc = "4 RX, Complex ADC output -> MAX_NUM_SAMPLES = 1024"]
    #[doc = "4 RX, Real ADC output -> MAX_NUM_SAMPLES = 2048"]
    #[doc = "2 RX, Complex ADC output -> MAX_NUM_SAMPLES = 2048"]
    #[doc = "2 RX, Real ADC output -> MAX_NUM_SAMPLES = 4096"]
    pub testPatrnPktSize: rlUInt16_t,
    #[doc = " @brief Number of test pattern packets to send, for infinite packets set it to 0"]
    pub numTestPtrnPkts: rlUInt32_t,
    #[doc = " @brief  This field specifies the values for Rx0, I channel. Applicable only in case of \\n"]
    #[doc = "test pattern enable. Else ignored. Bits    Description \\n"]
    #[doc = "[15:0]  Start offset value to be used for the first sample for the test \\n"]
    #[doc = "pattern data  \\n"]
    #[doc = "[31:16] Value to be added for each successive sample for the test pattern \\n"]
    #[doc = "data \\n"]
    pub testPatRx0Icfg: rlUInt32_t,
    #[doc = " @brief  This field specifies the values for Rx0, Q channel. Applicable only in case of \\n"]
    #[doc = "test pattern enable. Else ignored. \\n"]
    #[doc = "Bits    Description \\n"]
    #[doc = "[15:0]  Start offset value to be used for the first sample for the test \\n"]
    #[doc = "pattern data"]
    #[doc = "[31:16] Value to be added for each successive sample for the test pattern \\n"]
    #[doc = "data \\n"]
    pub testPatRx0Qcfg: rlUInt32_t,
    #[doc = " @brief  This field specifies the values for Rx1, I channel. Applicable only in case of \\n"]
    #[doc = "test pattern enable. Else ignored. \\n"]
    #[doc = "Bits    Description \\n"]
    #[doc = "[15:0]  Start offset value to be used for the first sample for the test \\n"]
    #[doc = "pattern data"]
    #[doc = "[31:16] Value to be added for each successive sample for the test pattern \\n"]
    #[doc = "data"]
    pub testPatRx1Icfg: rlUInt32_t,
    #[doc = " @brief  This field specifies the values for Rx1, Q channel. \\n"]
    #[doc = "Applicable only in case of test pattern enable. Else ignored. \\n"]
    #[doc = "Bits    Description \\n"]
    #[doc = "[15:0]  Start offset value to be used for the first sample for the test \\n"]
    #[doc = "pattern data"]
    #[doc = "[31:16] Value to be added for each successive sample for the test pattern \\n"]
    #[doc = "data"]
    pub testPatRx1Qcfg: rlUInt32_t,
    #[doc = " @brief  This field specifies the values for Rx2, I channel. \\n"]
    #[doc = "Applicable only in case of test pattern enable. Else ignored. \\n"]
    #[doc = "Bits    Description \\n"]
    #[doc = "[15:0]  Start offset value to be used for the first sample for the test \\n"]
    #[doc = "pattern data"]
    #[doc = "[31:16] Value to be added for each successive sample for the test pattern \\n"]
    #[doc = "data"]
    pub testPatRx2Icfg: rlUInt32_t,
    #[doc = " @brief  This field specifies the values for Rx2, Q channel. \\n"]
    #[doc = "Applicable only in case of test pattern enable. Else ignored. \\n"]
    #[doc = "Bits    Description \\n"]
    #[doc = "[15:0]  Start offset value to be used for the first sample for the test \\n"]
    #[doc = "pattern data"]
    #[doc = "[31:16] Value to be added for each successive sample for the test pattern \\n"]
    #[doc = "data"]
    pub testPatRx2Qcfg: rlUInt32_t,
    #[doc = " @brief  This field specifies the values for Rx3, I channel. \\n"]
    #[doc = "Applicable only in case of test pattern enable. Else ignored. \\n"]
    #[doc = "Bits    Description \\n"]
    #[doc = "[15:0]  Start offset value to be used for the first sample for the test \\n"]
    #[doc = "pattern data"]
    #[doc = "[31:16] Value to be added for each successive sample for the test pattern \\n"]
    #[doc = "data"]
    pub testPatRx3Icfg: rlUInt32_t,
    #[doc = " @brief  This field specifies the values for Rx3, Q channel. \\n"]
    #[doc = "Applicable only in case of test pattern enable. Else ignored. \\n"]
    #[doc = "Bits    Description \\n"]
    #[doc = "[15:0]  Start offset value to be used for the first sample for the test \\n"]
    #[doc = "pattern data"]
    #[doc = "[31:16] Value to be added for each successive sample for the test pattern \\n"]
    #[doc = "data"]
    pub testPatRx3Qcfg: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rltestPattern() {
    assert_eq!(
        ::core::mem::size_of::<rltestPattern>(),
        44usize,
        concat!("Size of: ", stringify!(rltestPattern))
    );
    assert_eq!(
        ::core::mem::align_of::<rltestPattern>(),
        4usize,
        concat!("Alignment of ", stringify!(rltestPattern))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rltestPattern>())).testPatGenCtrl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rltestPattern),
            "::",
            stringify!(testPatGenCtrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rltestPattern>())).testPatGenTime as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rltestPattern),
            "::",
            stringify!(testPatGenTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rltestPattern>())).testPatrnPktSize as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rltestPattern),
            "::",
            stringify!(testPatrnPktSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rltestPattern>())).numTestPtrnPkts as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rltestPattern),
            "::",
            stringify!(numTestPtrnPkts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rltestPattern>())).testPatRx0Icfg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rltestPattern),
            "::",
            stringify!(testPatRx0Icfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rltestPattern>())).testPatRx0Qcfg as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rltestPattern),
            "::",
            stringify!(testPatRx0Qcfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rltestPattern>())).testPatRx1Icfg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rltestPattern),
            "::",
            stringify!(testPatRx1Icfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rltestPattern>())).testPatRx1Qcfg as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rltestPattern),
            "::",
            stringify!(testPatRx1Qcfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rltestPattern>())).testPatRx2Icfg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rltestPattern),
            "::",
            stringify!(testPatRx2Icfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rltestPattern>())).testPatRx2Qcfg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rltestPattern),
            "::",
            stringify!(testPatRx2Qcfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rltestPattern>())).testPatRx3Icfg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rltestPattern),
            "::",
            stringify!(testPatRx3Icfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rltestPattern>())).testPatRx3Qcfg as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rltestPattern),
            "::",
            stringify!(testPatRx3Qcfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rltestPattern>())).reserved as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rltestPattern),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rltestPattern_t = rltestPattern;
#[doc = " \\brief"]
#[doc = " mmwave radar data format config"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDevDataFmtCfg {
    #[doc = " @brief  RX Channel Bitmap \\n"]
    #[doc = "b0 RX0 Channel Enable \\n"]
    #[doc = "0 Disable RX Channel 0 \\n"]
    #[doc = "1 Enable RX Channel 0 \\n"]
    #[doc = "b1 RX1 Channel Enable \\n"]
    #[doc = "0 Disable RX Channel 1 \\n"]
    #[doc = "1 Enable RX Channel 1 \\n"]
    #[doc = "b2 RX2 Channel Enable \\n"]
    #[doc = "0 Disable RX Channel 2 \\n"]
    #[doc = "1 Enable RX Channel 2 \\n"]
    #[doc = "b3 RX3 Channel Enable \\n"]
    #[doc = "0 Disable RX Channel 3 \\n"]
    #[doc = "1 Enable RX Channel 3 \\n"]
    pub rxChannelEn: rlUInt16_t,
    #[doc = " @brief  ADC out bits - 0(12 Bits), 1(14 Bits), 2(16 Bits)"]
    pub adcBits: rlUInt16_t,
    #[doc = " @brief  ADC out format - 0(Real), 1(Complex), 2(Complex with Image band), 3(Pseudo Real)"]
    pub adcFmt: rlUInt16_t,
    #[doc = " @brief  I/Q Swap selection for complex outputs \\n"]
    #[doc = "0 Sample interleave mode - I first \\n"]
    #[doc = "1 Sample interleave mode - Q first \\n"]
    #[doc = "others reserved \\n"]
    pub iqSwapSel: rlUInt8_t,
    #[doc = " @brief  Channel interleaving of the samples stored in \\n"]
    #[doc = "the ADC buffer to be transferred out on the data path \\n"]
    #[doc = "0 - Interleaved \\n"]
    #[doc = "1 - Non Interleaved \\n"]
    #[doc = "others reserved \\n"]
    pub chInterleave: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlDevDataFmtCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlDevDataFmtCfg>(),
        12usize,
        concat!("Size of: ", stringify!(rlDevDataFmtCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDevDataFmtCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlDevDataFmtCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataFmtCfg>())).rxChannelEn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataFmtCfg),
            "::",
            stringify!(rxChannelEn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataFmtCfg>())).adcBits as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataFmtCfg),
            "::",
            stringify!(adcBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataFmtCfg>())).adcFmt as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataFmtCfg),
            "::",
            stringify!(adcFmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataFmtCfg>())).iqSwapSel as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataFmtCfg),
            "::",
            stringify!(iqSwapSel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataFmtCfg>())).chInterleave as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataFmtCfg),
            "::",
            stringify!(chInterleave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataFmtCfg>())).reserved as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataFmtCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlDevDataFmtCfg_t = rlDevDataFmtCfg;
#[doc = " \\brief"]
#[doc = " mmwave radar data path config."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDevDataPathCfg {
    #[doc = " @brief  Data Path Interface, \\n"]
    #[doc = "0x0  CSI2 interface selected \\n"]
    #[doc = "0x1  LVDS interface selected \\n"]
    pub intfSel: rlUInt8_t,
    #[doc = " @brief  Data out Format, \\n"]
    #[doc = "b5:0 Packet 0 content selection \\n"]
    #[doc = "000001 - ADC_DATA_ONLY \\n"]
    #[doc = "000110 - CP_ADC_DATA \\n"]
    #[doc = "001001 - ADC_CP_DATA \\n"]
    #[doc = "110110 - CP_ADC_CQ_DATA \\n"]
    #[doc = "b7:6 Packet 0 virtual channel number (valid only for CSI2) \\n"]
    #[doc = "00   Virtual channel number 0 (Default) \\n"]
    #[doc = "01   Virtual channel number 1 \\n"]
    #[doc = "10   Virtual channel number 2 \\n"]
    #[doc = "11   Virtual channel number 3 \\n"]
    pub transferFmtPkt0: rlUInt8_t,
    #[doc = " @brief  Data out Format, \\n"]
    #[doc = "b5:0 Packet 1 content selection \\n"]
    #[doc = "000000 - Suppress Packet 1 \\n"]
    #[doc = "001110 - CP_CQ_DATA \\n"]
    #[doc = "001011 - CQ_CP_DATA \\n"]
    #[doc = "b7:6 Packet 1 virtual channel number (valid only for CSI2) \\n"]
    #[doc = "00   Virtual channel number 0 (Default) \\n"]
    #[doc = "01   Virtual channel number 1 \\n"]
    #[doc = "10   Virtual channel number 2 \\n"]
    #[doc = "11   Virtual channel number 3 \\n"]
    pub transferFmtPkt1: rlUInt8_t,
    #[doc = " @brief  This field specifies the data size of CQ samples on the lanes. \\n"]
    #[doc = "b1:0   Data size \\n"]
    #[doc = "00    12 bits   \\n"]
    #[doc = "01    14 bits   \\n"]
    #[doc = "10    16 bits   \\n"]
    #[doc = "b7:2    Reserved"]
    pub cqConfig: rlUInt8_t,
    #[doc = " @brief  Number of samples (in 16 bit halfwords) of CQ0 data to be"]
    #[doc = "transferred. Valid range [32 halfwords to 128 halfwords] \\n"]
    #[doc = "Value 0 = Disabled \\n"]
    #[doc = "@note : Ensure that the number of halfwords specified are a multiple"]
    #[doc = "of the number of lanes selected."]
    pub cq0TransSize: rlUInt8_t,
    #[doc = " @brief  Number of samples (in 16 bit halfwords) of CQ1 data to be"]
    #[doc = "transferred. Valid range [32 halfwords to 128 halfwords] \\n"]
    #[doc = "Value 0 = Disabled \\n"]
    #[doc = "@note : Ensure that the number of halfwords specified are a multiple"]
    #[doc = "of the number of lanes selected."]
    pub cq1TransSize: rlUInt8_t,
    #[doc = " @brief  Number of samples (in 16 bit halfwords) of CQ2 data to be"]
    #[doc = "transferred. Valid range [32 halfwords to 128 halfwords] \\n"]
    #[doc = "Value 0 = Disabled \\n"]
    #[doc = "@note : Ensure that the number of halfwords specified are a multiple"]
    #[doc = "of the number of lanes selected."]
    pub cq2TransSize: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlDevDataPathCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlDevDataPathCfg>(),
        8usize,
        concat!("Size of: ", stringify!(rlDevDataPathCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDevDataPathCfg>(),
        1usize,
        concat!("Alignment of ", stringify!(rlDevDataPathCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataPathCfg>())).intfSel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataPathCfg),
            "::",
            stringify!(intfSel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDevDataPathCfg>())).transferFmtPkt0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataPathCfg),
            "::",
            stringify!(transferFmtPkt0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDevDataPathCfg>())).transferFmtPkt1 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataPathCfg),
            "::",
            stringify!(transferFmtPkt1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataPathCfg>())).cqConfig as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataPathCfg),
            "::",
            stringify!(cqConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataPathCfg>())).cq0TransSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataPathCfg),
            "::",
            stringify!(cq0TransSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataPathCfg>())).cq1TransSize as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataPathCfg),
            "::",
            stringify!(cq1TransSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataPathCfg>())).cq2TransSize as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataPathCfg),
            "::",
            stringify!(cq2TransSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataPathCfg>())).reserved as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataPathCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlDevDataPathCfg_t = rlDevDataPathCfg;
#[doc = " \\brief"]
#[doc = " mmwave radar data path lane enable"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDevLaneEnable {
    #[doc = " @brief  Lane Enable Bitmap  \\n"]
    #[doc = "b0 Lane 0 Enable  \\n"]
    #[doc = "0 Disable lane 0 \\n"]
    #[doc = "1 Enable lane 0  \\n"]
    #[doc = "b1 Lane 1 Enable  \\n"]
    #[doc = "0 Disable lane 1 \\n"]
    #[doc = "1 Enable lane 1  \\n"]
    #[doc = "b2 Lane 2 Enable  \\n"]
    #[doc = "0 Disable lane 2 \\n"]
    #[doc = "1 Enable lane 2  \\n"]
    #[doc = "b3 Lane 3 Enable  \\n"]
    #[doc = "0 Disable lane 3 \\n"]
    #[doc = "1 Enable lane 3  \\n"]
    #[doc = "b15:4 Reserved    \\n"]
    pub laneEn: rlUInt16_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlDevLaneEnable() {
    assert_eq!(
        ::core::mem::size_of::<rlDevLaneEnable>(),
        4usize,
        concat!("Size of: ", stringify!(rlDevLaneEnable))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDevLaneEnable>(),
        2usize,
        concat!("Alignment of ", stringify!(rlDevLaneEnable))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevLaneEnable>())).laneEn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevLaneEnable),
            "::",
            stringify!(laneEn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevLaneEnable>())).reserved as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevLaneEnable),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlDevLaneEnable_t = rlDevLaneEnable;
#[doc = " \\brief"]
#[doc = " DataPath clock configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDevDataPathClkCfg {
    #[doc = " @brief  Clock COnfiguration \\n"]
    #[doc = "0 -SDR Clock \\n"]
    #[doc = "1 - DDR Clock (Only valid value for CSI2) \\n"]
    pub laneClkCfg: rlUInt8_t,
    #[doc = " @brief  Data rate selection \\n"]
    #[doc = "0001b - 600 Mbps (DDR only) \\n"]
    #[doc = "0010b - 450 Mbps (SDR, DDR) \\n"]
    #[doc = "0011b - 400 Mbps (DDR only) \\n"]
    #[doc = "0100b - 300 Mbps (SDR, DDR) \\n"]
    #[doc = "0101b - 225 Mbps (DDR only) \\n"]
    #[doc = "0110b - 150 Mbps (DDR only) \\n"]
    #[doc = "Others - Reserved \\n"]
    pub dataRate: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlDevDataPathClkCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlDevDataPathClkCfg>(),
        4usize,
        concat!("Size of: ", stringify!(rlDevDataPathClkCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDevDataPathClkCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlDevDataPathClkCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataPathClkCfg>())).laneClkCfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataPathClkCfg),
            "::",
            stringify!(laneClkCfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataPathClkCfg>())).dataRate as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataPathClkCfg),
            "::",
            stringify!(dataRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevDataPathClkCfg>())).reserved as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevDataPathClkCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlDevDataPathClkCfg_t = rlDevDataPathClkCfg;
#[doc = " \\brief"]
#[doc = " LVDS Lane configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDevLvdsLaneCfg {
    #[doc = " @brief  Lane format \\n"]
    #[doc = "0x0000 Format map 0 (Rx0,Rx1,...) \\n"]
    #[doc = "0x0001 Format map 1 (Rx3,Rx2,...) \\n"]
    pub laneFmtMap: rlUInt16_t,
    #[doc = " @brief  Lane Parameter configurations \\n"]
    #[doc = "b0 - 0(LSB first), 1(MSB first) \\n"]
    #[doc = "b1 - 0(Packet End Pulse Disable), 1(enable) \\n"]
    #[doc = "b2 - 0(CRC disabled), 1(CRC enabled)        \\n"]
    #[doc = "b7:3 - Reserved \\n"]
    #[doc = "b8 - Configures LSB/MSB first for CRC \\n"]
    #[doc = "0(CRC value swapped wrt to MSB_FIRST setting) \\n"]
    #[doc = "1(CRC value follows MSB_FIRST setting) \\n"]
    #[doc = "b9 - Frame clock state during idle \\n"]
    #[doc = "0(Frame clock is held low) \\n"]
    #[doc = "1(Frame clock is held high) \\n"]
    #[doc = "b10 - Frame clock period for CRC(when CRC enabled - b2) \\n"]
    #[doc = "0(32-bit CRC is trasmitted as single sample with frame clock set to \\n"]
    #[doc = "16high, 16low configuration) \\n"]
    #[doc = "1(32-bit CRC is trasmitted as single sample with frame clock set to \\n"]
    #[doc = "8high, 8low configuration) \\n"]
    #[doc = "b11 - Bit clock state during idle \\n"]
    #[doc = "0(Bit clock toggles during idle when there are no transmission) \\n"]
    #[doc = "1(Bit clock doesn't toggle during idle when there are no transmission,  \\n"]
    #[doc = "the value of bit clock is held low) \\n"]
    #[doc = "b12 - CRC inversion control(when CRC enabled - b2) \\n"]
    #[doc = "0(The calcualted value of 32-bit ethernet polynomial CRC is inverted and \\n"]
    #[doc = "sent out) \\n"]
    #[doc = "1(The calcualted value of 32-bit ethernet polynomial CRC is sent without \\n"]
    #[doc = "inversion) \\n"]
    #[doc = "b15:13 - Reserved \\n"]
    pub laneParamCfg: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlDevLvdsLaneCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlDevLvdsLaneCfg>(),
        4usize,
        concat!("Size of: ", stringify!(rlDevLvdsLaneCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDevLvdsLaneCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlDevLvdsLaneCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevLvdsLaneCfg>())).laneFmtMap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevLvdsLaneCfg),
            "::",
            stringify!(laneFmtMap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevLvdsLaneCfg>())).laneParamCfg as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevLvdsLaneCfg),
            "::",
            stringify!(laneParamCfg)
        )
    );
}
pub type rlDevLvdsLaneCfg_t = rlDevLvdsLaneCfg;
#[doc = " \\brief"]
#[doc = " Continous streaming mode configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDevContStreamingModeCfg {
    #[doc = " @brief  Enable - 1, Disable - 0"]
    pub contStreamModeEn: rlUInt16_t,
    #[doc = " @brief  Reserved for future use \\n"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlDevContStreamingModeCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlDevContStreamingModeCfg>(),
        4usize,
        concat!("Size of: ", stringify!(rlDevContStreamingModeCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDevContStreamingModeCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlDevContStreamingModeCfg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDevContStreamingModeCfg>())).contStreamModeEn as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevContStreamingModeCfg),
            "::",
            stringify!(contStreamModeEn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDevContStreamingModeCfg>())).reserved as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevContStreamingModeCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlDevContStreamingModeCfg_t = rlDevContStreamingModeCfg;
#[doc = " \\brief"]
#[doc = " CSI2 configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDevCsi2Cfg {
    #[doc = " @brief  b2:0 - DATA_LANE0_POS \\n"]
    #[doc = "Valid values (Should be a unique position if lane 0 is enabled, ignored if \\n"]
    #[doc = "lane 0 is not enabled): \\n"]
    #[doc = "000b - Unused, 001b - Position 1 (default), \\n"]
    #[doc = "010b - Position 2, 011b - Position 3, \\n"]
    #[doc = "100b - Position 4, 101b - Position 5 \\n"]
    #[doc = "b3 DATA_LANE0_POL \\n"]
    #[doc = "0b - PLUSMINUS pin order, 1b - MINUSPLUS pin order \\n"]
    #[doc = "b6:4 DATA_LANE1_POS \\n"]
    #[doc = "Valid values (Should be a unique position if lane 1 is \\n"]
    #[doc = "enabled, ignored if lane 1 is not enabled): \\n"]
    #[doc = "000b - Unused, 001b - Position 1, \\n"]
    #[doc = "010b - Position 2 (default), 011b - Position 3, \\n"]
    #[doc = "100b - Position 4, 101b - Position 5 \\n"]
    #[doc = "b7 DATA_LANE1_POL \\n"]
    #[doc = "0b - PLUSMINUS pin order, 1b - MINUSPLUS pin order \\n"]
    #[doc = "b10:8 DATA_LANE2_POS \\n"]
    #[doc = "Valid values (Should be a unique position if lane 2 is \\n"]
    #[doc = "enabled, ignored if lane 2 is not enabled): \\n"]
    #[doc = "000b - Unused, 001b - Position 1, \\n"]
    #[doc = "010b - Position 2, 011b - Position 3, \\n"]
    #[doc = "100b - Position 4 (default), 101b - Position 5 \\n"]
    #[doc = "b11 DATA_LANE2_POL \\n"]
    #[doc = "0b - PLUSMINUS pin order, 1b - MINUSPLUS pin order \\n"]
    #[doc = "b14:12 DATA_LANE3_POS \\n"]
    #[doc = "Valid values (Should be a unique position if lane 3 is \\n"]
    #[doc = "enabled, ignored if lane 3 is not enabled): \\n"]
    #[doc = "000b - Unused, 001b - Position 1, \\n"]
    #[doc = "010b - Position 2, 011b - Position 3, \\n"]
    #[doc = "100b - Position 4, 101b - Position 5 (default) \\n"]
    #[doc = "b15 DATA_LANE3_POL \\n"]
    #[doc = "0b - PLUSMINUS pin order, 1b - MINUSPLUS pin order \\n"]
    #[doc = "b18:16 CLOCK_POS \\n"]
    #[doc = "Valid values (Should be a unique position): \\n"]
    #[doc = "001b - Position 1, \\n"]
    #[doc = "010b - Position 2, 011b - Position 3 (default), \\n"]
    #[doc = "100b - Position 4 \\n"]
    #[doc = "b19 CLOCK_POL \\n"]
    #[doc = "0b - PLUSMINUS pin order, 1b - MINUSPLUS pin order \\n"]
    #[doc = "b31:20 RESERVED \\n"]
    pub lanePosPolSel: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlDevCsi2Cfg() {
    assert_eq!(
        ::core::mem::size_of::<rlDevCsi2Cfg>(),
        8usize,
        concat!("Size of: ", stringify!(rlDevCsi2Cfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDevCsi2Cfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlDevCsi2Cfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevCsi2Cfg>())).lanePosPolSel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevCsi2Cfg),
            "::",
            stringify!(lanePosPolSel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevCsi2Cfg>())).reserved1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevCsi2Cfg),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlDevCsi2Cfg_t = rlDevCsi2Cfg;
#[doc = " \\brief"]
#[doc = " mmwave radar high speed clock configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDevHsiClk {
    #[doc = " @brief  High Speed Interface Clock configurations. Below table indicates possible values"]
    #[doc = "for different data rate supported \\n"]
    #[doc = "HSICLKRATECODE (corresponding datarate in Mbps): \\n"]
    #[doc = "SDR - 0x5(900 mbps), 0xA(600 mbps), 0x6(450 mbps), 0x2(400 mbps),"]
    #[doc = "0xB(300 mbps), 0x7(225 mbps)  \\n"]
    #[doc = "DDR - 0xD(900 mbps), 0x9(600 mbps), 0x5(450 mbps), 0x1(400 mbps),"]
    #[doc = "0xA(300 mbps), 0x6(225 mbps ), 0xB(150 mbps) \\n"]
    pub hsiClk: rlUInt16_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlDevHsiClk() {
    assert_eq!(
        ::core::mem::size_of::<rlDevHsiClk>(),
        4usize,
        concat!("Size of: ", stringify!(rlDevHsiClk))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDevHsiClk>(),
        2usize,
        concat!("Alignment of ", stringify!(rlDevHsiClk))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevHsiClk>())).hsiClk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevHsiClk),
            "::",
            stringify!(hsiClk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevHsiClk>())).reserved as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevHsiClk),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlDevHsiClk_t = rlDevHsiClk;
#[doc = " \\brief"]
#[doc = " mmwave radar high speed Data path configuraiton"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlDevHsiCfg {
    #[doc = " @brief  Data format config"]
    pub datafmt: *mut rlDevDataFmtCfg_t,
    #[doc = " @brief  Data path config"]
    pub dataPath: *mut rlDevDataPathCfg_t,
    #[doc = " @brief  Data path clock configuration"]
    pub dataPathClk: *mut rlDevDataPathClkCfg_t,
}
#[test]
fn bindgen_test_layout_rlDevHsiCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlDevHsiCfg>(),
        12usize,
        concat!("Size of: ", stringify!(rlDevHsiCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDevHsiCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlDevHsiCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevHsiCfg>())).datafmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevHsiCfg),
            "::",
            stringify!(datafmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevHsiCfg>())).dataPath as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevHsiCfg),
            "::",
            stringify!(dataPath)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevHsiCfg>())).dataPathClk as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevHsiCfg),
            "::",
            stringify!(dataPathClk)
        )
    );
}
impl Default for rlDevHsiCfg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlDevHsiCfg_t = rlDevHsiCfg;
#[doc = " \\brief"]
#[doc = " mmwave radar device config"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDevConfig {
    #[doc = " @brief  Set CRC type of Async Event message from MSS to Host \\n"]
    #[doc = "0 - 16 Bit CRC \\n"]
    #[doc = "1 - 32 Bit CRC \\n"]
    #[doc = "2 - 64 Bit CRC \\n"]
    pub aeCrcConfig: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved2: rlUInt32_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved3: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlDevConfig() {
    assert_eq!(
        ::core::mem::size_of::<rlDevConfig>(),
        12usize,
        concat!("Size of: ", stringify!(rlDevConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDevConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(rlDevConfig))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevConfig>())).aeCrcConfig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevConfig),
            "::",
            stringify!(aeCrcConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevConfig>())).reserved0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevConfig),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevConfig>())).reserved1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevConfig),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevConfig>())).reserved2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevConfig),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDevConfig>())).reserved3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDevConfig),
            "::",
            stringify!(reserved3)
        )
    );
}
pub type rlDevMiscCfg_t = rlDevConfig;
extern "C" {
    #[doc = "  @defgroup Device Device"]
    #[doc = "  @brief Radar Device Management Module."]
    #[doc = ""]
    #[doc = "  The Device module has interface for Enabling and controlling Radar device."]
    #[doc = "  Configures the callbacks(SPI, Interrupt, OS etc) for communication with device"]
    #[doc = "  It also allows Firmware download over SPI."]
    #[doc = ""]
    #[doc = "    Related Files"]
    #[doc = "   - rl_device.c"]
    #[doc = "  @addtogroup Device"]
    #[doc = "  @{"]
    pub fn rlDevicePowerOn(deviceMap: rlUInt8_t, clientCb: rlClientCbs_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceAddDevices(deviceMap: rlUInt8_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceRemoveDevices(deviceMap: rlUInt8_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDevicePowerOff() -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceRfStart(deviceMap: rlUInt8_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceFileDownload(
        deviceMap: rlUInt8_t,
        data: *mut rlFileData_t,
        remChunks: rlUInt16_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceGetMssVersion(
        deviceMap: rlUInt8_t,
        data: *mut rlFwVersionParam_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceGetRfVersion(
        deviceMap: rlUInt8_t,
        data: *mut rlFwVersionParam_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceGetVersion(deviceMap: rlUInt8_t, data: *mut rlVersion_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceGetMmWaveLinkVersion(data: *mut rlSwVersionParam_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceMcuClkConfig(deviceMap: rlUInt8_t, data: *mut rlMcuClkCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDevicePmicClkConfig(deviceMap: rlUInt8_t, data: *mut rlPmicClkCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceLatentFaultTests(
        deviceMap: rlUInt8_t,
        data: *mut rllatentFault_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceEnablePeriodicTests(
        deviceMap: rlUInt8_t,
        data: *mut rlperiodicTest_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceSetTestPatternConfig(
        deviceMap: rlUInt8_t,
        data: *mut rltestPattern_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceConfigureCrc(crcType: rlCrcType_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceConfigureAckTimeout(ackTimeout: rlUInt32_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceSetRetryCount(retryCnt: rlUInt8_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceSetContStreamingModeConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlDevContStreamingModeCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceGetContStreamingModeConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlDevContStreamingModeCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceSetMiscConfig(deviceMap: rlUInt8_t, data: *mut rlDevMiscCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceGetCpuFault(deviceMap: rlUInt8_t, data: *mut rlCpuFault_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceGetEsmFault(deviceMap: rlUInt8_t, data: *mut rlMssEsmFault_t) -> rlReturnVal_t;
}
extern "C" {
    #[doc = "  @defgroup Data_Path Data Path"]
    #[doc = "  @brief mmWave Radar Data Path(LVDS/CSI2) Module."]
    #[doc = ""]
    #[doc = "  The Data path module has interface for Enabling and controlling high speed"]
    #[doc = "  data interface such as CSI2 and LVDS. Configures the data format, data rate,"]
    #[doc = "  lane parameters. \\n"]
    #[doc = "  Below diagram shows the data transfer for different data formats and lanes"]
    #[doc = "  on high speed interface"]
    #[doc = ""]
    #[doc = "  @image html data_path_lanes.png"]
    #[doc = ""]
    #[doc = "    Related Files"]
    #[doc = "   - rl_device.c"]
    #[doc = "  @addtogroup Data_Path"]
    #[doc = "  @{"]
    pub fn rlDeviceSetDataFmtConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlDevDataFmtCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceGetDataFmtConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlDevDataFmtCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceSetDataPathConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlDevDataPathCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceGetDataPathConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlDevDataPathCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceSetLaneConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlDevLaneEnable_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceGetLaneConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlDevLaneEnable_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceSetDataPathClkConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlDevDataPathClkCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceGetDataPathClkConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlDevDataPathClkCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceSetLvdsLaneConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlDevLvdsLaneCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceGetLvdsLaneConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlDevLvdsLaneCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceSetHsiConfig(deviceMap: rlUInt8_t, data: *mut rlDevHsiCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceSetHsiClk(deviceMap: rlUInt8_t, data: *mut rlDevHsiClk_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceSetCsi2Config(deviceMap: rlUInt8_t, data: *mut rlDevCsi2Cfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlDeviceGetCsi2Config(deviceMap: rlUInt8_t, data: *mut rlDevCsi2Cfg_t) -> rlReturnVal_t;
}
#[doc = " \\brief"]
#[doc = " Rx/Tx Channel Configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlChanCfg {
    #[doc = " @ brief  RX Channel Bitmap \\n"]
    #[doc = "b0 RX0 Channel Enable \\n"]
    #[doc = "0   Disable RX Channel 0 \\n"]
    #[doc = "1   Enable RX Channel 0 \\n"]
    #[doc = "b1 RX1 Channel Enable \\n"]
    #[doc = "0   Disable RX Channel 1 \\n"]
    #[doc = "1   Enable RX Channel 1 \\n"]
    #[doc = "b2 RX2 Channel Enable \\n"]
    #[doc = "0   Disable RX Channel 2 \\n"]
    #[doc = "1   Enable RX Channel 2 \\n"]
    #[doc = "b3 RX3 Channel Enable \\n"]
    #[doc = "0   Disable RX Channel 3 \\n"]
    #[doc = "1   Enable RX Channel 3 \\n"]
    #[doc = "b15:4 - RESERVED \\n"]
    pub rxChannelEn: rlUInt16_t,
    #[doc = " @brief  TX Channel Bitmap \\n"]
    #[doc = "b0 TX0 Channel Enable \\n"]
    #[doc = "0   Disable TX Channel 0 \\n"]
    #[doc = "1   Enable TX Channel 0\\n"]
    #[doc = "b1 TX1 Channel Enable \\n"]
    #[doc = "0   Disable TX Channel 1 \\n"]
    #[doc = "1   Enable TX Channel 1 \\n"]
    #[doc = "b2 TX2 Channel Enable \\n"]
    #[doc = "0   Disable TX Channel 2 \\n"]
    #[doc = "1   Enable TX Channel 2 \\n"]
    #[doc = "b15:3 - RESERVED \\n"]
    #[doc = "@note : TX2 is supported only on some of the devices, Please refer device data \\n"]
    #[doc = "sheet. \\n"]
    pub txChannelEn: rlUInt16_t,
    #[doc = " @brief  Enable Cascading \\n"]
    #[doc = "0x0000 SINGLECHIP: Single mmWave sensor application\\n"]
    #[doc = "0x0001 MULTICHIP_MASTER: Multiple mmwave sensor application. This mmwave is \\n"]
    #[doc = "the master chip and generates LO and conveys to other mmwave sensor. \\n"]
    #[doc = "This is applicable only in AWR1243.\\n"]
    #[doc = "0x0002 MULTICHIP_SLAVE: Multiple mmwave sensor application. This mmwave is a \\n"]
    #[doc = "slave chip and uses LO conveyed to it by the master mmwave sensor. \\n"]
    #[doc = "This is applicable only in AWR1243 \\n"]
    #[doc = "@note : Please refer device data sheet for cascading capability and 20G SYNC"]
    #[doc = "pins \\n"]
    pub cascading: rlUInt16_t,
    #[doc = " @brief  Cascading pinout config \\n"]
    #[doc = "         b0 - CLKOUT_MASTER_DIS \\n"]
    #[doc = "              0 - 20G FM_CW_CLKOUT from master is enabled \\n"]
    #[doc = "              1 - 20G FM_CW_CLKOUT from master is disabled \\n"]
    #[doc = "         b1 - SYNCOUT_MASTER_DIS \\n"]
    #[doc = "              0 - 20G FM_CW_SYNCOUT from master is enabled \\n"]
    #[doc = "              1 - 20G FM_CW_SYNCOUT from master is disabled \\n"]
    #[doc = "         b2 - CLKOUT_SLAVE_EN \\n"]
    #[doc = "              0 - 20G FM_CW_CLKOUT from slave is disabled \\n"]
    #[doc = "              1 - 20G FM_CW_CLKOUT from slave is enabled \\n"]
    #[doc = "         b3 - SYNCOUT_SLAVE_EN \\n"]
    #[doc = "              0 - 20G FM_CW_SYNCOUT from slave is disabled \\n"]
    #[doc = "              1 - 20G FM_CW_SYNCOUT from slave is enabled \\n"]
    #[doc = "         b4 - INTLO_MASTER_EN \\n"]
    #[doc = "              0 - Master uses looped back LO \\n"]
    #[doc = "              1 - Master uses internal LO \\n"]
    #[doc = "         b5 - OSCCLKOUT_MASTER_DIS \\n"]
    #[doc = "              0 - OSCCLKOUT from master is enabled \\n"]
    #[doc = "              1 - OSCCLKOUT from master is disabled \\n"]
    #[doc = "      b15:6 - RESERVED \\n"]
    pub cascadingPinoutCfg: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlChanCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlChanCfg>(),
        8usize,
        concat!("Size of: ", stringify!(rlChanCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlChanCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlChanCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChanCfg>())).rxChannelEn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChanCfg),
            "::",
            stringify!(rxChannelEn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChanCfg>())).txChannelEn as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChanCfg),
            "::",
            stringify!(txChannelEn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChanCfg>())).cascading as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChanCfg),
            "::",
            stringify!(cascading)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChanCfg>())).cascadingPinoutCfg as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChanCfg),
            "::",
            stringify!(cascadingPinoutCfg)
        )
    );
}
pub type rlChanCfg_t = rlChanCfg;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlAdcBitFormat {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_rlAdcBitFormat() {
    assert_eq!(
        ::core::mem::size_of::<rlAdcBitFormat>(),
        4usize,
        concat!("Size of: ", stringify!(rlAdcBitFormat))
    );
    assert_eq!(
        ::core::mem::align_of::<rlAdcBitFormat>(),
        4usize,
        concat!("Alignment of ", stringify!(rlAdcBitFormat))
    );
}
impl rlAdcBitFormat {
    #[inline]
    pub fn b2AdcBits(&self) -> rlUInt32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_b2AdcBits(&mut self, val: rlUInt32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn b6Reserved0(&self) -> rlUInt32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_b6Reserved0(&mut self, val: rlUInt32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn b8FullScaleReducFctr(&self) -> rlUInt32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_b8FullScaleReducFctr(&mut self, val: rlUInt32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn b2AdcOutFmt(&self) -> rlUInt32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_b2AdcOutFmt(&mut self, val: rlUInt32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn b14Reserved1(&self) -> rlUInt32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_b14Reserved1(&mut self, val: rlUInt32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        b2AdcBits: rlUInt32_t,
        b6Reserved0: rlUInt32_t,
        b8FullScaleReducFctr: rlUInt32_t,
        b2AdcOutFmt: rlUInt32_t,
        b14Reserved1: rlUInt32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let b2AdcBits: u32 = unsafe { ::core::mem::transmute(b2AdcBits) };
            b2AdcBits as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let b6Reserved0: u32 = unsafe { ::core::mem::transmute(b6Reserved0) };
            b6Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let b8FullScaleReducFctr: u32 = unsafe { ::core::mem::transmute(b8FullScaleReducFctr) };
            b8FullScaleReducFctr as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let b2AdcOutFmt: u32 = unsafe { ::core::mem::transmute(b2AdcOutFmt) };
            b2AdcOutFmt as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let b14Reserved1: u32 = unsafe { ::core::mem::transmute(b14Reserved1) };
            b14Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rlAdcBitFormat_t = rlAdcBitFormat;
#[doc = " \\brief"]
#[doc = " ADC format and payload justification Configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlAdcOutCfg {
    #[doc = " @brief  ADC Data format"]
    pub fmt: rlAdcBitFormat_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlAdcOutCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlAdcOutCfg>(),
        8usize,
        concat!("Size of: ", stringify!(rlAdcOutCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlAdcOutCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlAdcOutCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdcOutCfg>())).fmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdcOutCfg),
            "::",
            stringify!(fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdcOutCfg>())).reserved0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdcOutCfg),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdcOutCfg>())).reserved1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdcOutCfg),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlAdcOutCfg_t = rlAdcOutCfg;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlBpmModeCfg {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_rlBpmModeCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlBpmModeCfg>(),
        2usize,
        concat!("Size of: ", stringify!(rlBpmModeCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlBpmModeCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlBpmModeCfg))
    );
}
impl rlBpmModeCfg {
    #[inline]
    pub fn b2SrcSel(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_b2SrcSel(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn b1Reserved0(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_b1Reserved0(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn b13Reserved1(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 13u8) as u16) }
    }
    #[inline]
    pub fn set_b13Reserved1(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        b2SrcSel: rlUInt16_t,
        b1Reserved0: rlUInt16_t,
        b13Reserved1: rlUInt16_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let b2SrcSel: u16 = unsafe { ::core::mem::transmute(b2SrcSel) };
            b2SrcSel as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let b1Reserved0: u16 = unsafe { ::core::mem::transmute(b1Reserved0) };
            b1Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 13u8, {
            let b13Reserved1: u16 = unsafe { ::core::mem::transmute(b13Reserved1) };
            b13Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rlBpmModeCfg_t = rlBpmModeCfg;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlBpmKCounterSel {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout_rlBpmKCounterSel() {
    assert_eq!(
        ::core::mem::size_of::<rlBpmKCounterSel>(),
        2usize,
        concat!("Size of: ", stringify!(rlBpmKCounterSel))
    );
    assert_eq!(
        ::core::mem::align_of::<rlBpmKCounterSel>(),
        2usize,
        concat!("Alignment of ", stringify!(rlBpmKCounterSel))
    );
}
impl rlBpmKCounterSel {
    #[inline]
    pub fn b1BpmKStart(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_b1BpmKStart(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn b1BpmKEnd(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_b1BpmKEnd(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn b14Reserved(&self) -> rlUInt16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_b14Reserved(&mut self, val: rlUInt16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        b1BpmKStart: rlUInt16_t,
        b1BpmKEnd: rlUInt16_t,
        b14Reserved: rlUInt16_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let b1BpmKStart: u16 = unsafe { ::core::mem::transmute(b1BpmKStart) };
            b1BpmKStart as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let b1BpmKEnd: u16 = unsafe { ::core::mem::transmute(b1BpmKEnd) };
            b1BpmKEnd as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let b14Reserved: u16 = unsafe { ::core::mem::transmute(b14Reserved) };
            b14Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rlBpmKCounterSel_t = rlBpmKCounterSel;
#[doc = " \\brief"]
#[doc = " Binary phase modulation common configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlBpmCommonCfg {
    #[doc = " @brief  BPM Mode configuration"]
    pub mode: rlBpmModeCfg_t,
    #[doc = " @brief  Reserved for future, should set to zero."]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  Reserved for future, should set to zero."]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  Reserved for future, should set to zero."]
    pub reserved2: rlUInt16_t,
    #[doc = " @brief  Reserved for future, should set to zero."]
    pub reserved3: rlUInt32_t,
    #[doc = " @brief  Reserved for future, should set to zero."]
    pub reserved4: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlBpmCommonCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlBpmCommonCfg>(),
        16usize,
        concat!("Size of: ", stringify!(rlBpmCommonCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlBpmCommonCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlBpmCommonCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlBpmCommonCfg>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlBpmCommonCfg),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlBpmCommonCfg>())).reserved0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlBpmCommonCfg),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlBpmCommonCfg>())).reserved1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlBpmCommonCfg),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlBpmCommonCfg>())).reserved2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlBpmCommonCfg),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlBpmCommonCfg>())).reserved3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlBpmCommonCfg),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlBpmCommonCfg>())).reserved4 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlBpmCommonCfg),
            "::",
            stringify!(reserved4)
        )
    );
}
pub type rlBpmCommonCfg_t = rlBpmCommonCfg;
#[doc = " \\brief"]
#[doc = " Binary phase modulation common configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlBpmChirpCfg {
    #[doc = " @brief  Chirp Start Index, Valid Range 0 -511"]
    pub chirpStartIdx: rlUInt16_t,
    #[doc = " @brief  Chirp End Index, Valid Range from chirpStartIdx to 511"]
    pub chirpEndIdx: rlUInt16_t,
    #[doc = " @brief  b0  CONST_BPM_VAL_TX0_TXOFF \\n"]
    #[doc = "Value of Binary Phase Shift value for TX0, when during idle time \\n"]
    #[doc = "b1  CONST_BPM_VAL_TX0_TXON \\n"]
    #[doc = "Value of Binary Phase Shift value for TX0, during chirp \\n"]
    #[doc = "b2  CONST_BPM_VAL_TX1_TXOFF \\n"]
    #[doc = "Value of Binary Phase Shift value for TX1, when during idle time \\n"]
    #[doc = "b3  CONST_BPM_VAL_TX1_TXON \\n"]
    #[doc = "Value of Binary Phase Shift value for TX1, during chirp \\n"]
    #[doc = "b4  CONST_BPM_VAL_TX2_TXOFF \\n"]
    #[doc = "Value of Binary Phase Shift value for TX2, when during idle time \\n"]
    #[doc = "b5  CONST_BPM_VAL_TX2_TXON \\n"]
    #[doc = "Value of Binary Phase Shift value for TX2, during chirp \\n"]
    #[doc = "b15:6 Reserved \\n"]
    pub constBpmVal: rlUInt16_t,
    #[doc = " @brief  Reserved for future"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlBpmChirpCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlBpmChirpCfg>(),
        8usize,
        concat!("Size of: ", stringify!(rlBpmChirpCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlBpmChirpCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlBpmChirpCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlBpmChirpCfg>())).chirpStartIdx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlBpmChirpCfg),
            "::",
            stringify!(chirpStartIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlBpmChirpCfg>())).chirpEndIdx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlBpmChirpCfg),
            "::",
            stringify!(chirpEndIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlBpmChirpCfg>())).constBpmVal as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlBpmChirpCfg),
            "::",
            stringify!(constBpmVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlBpmChirpCfg>())).reserved as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlBpmChirpCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlBpmChirpCfg_t = rlBpmChirpCfg;
#[doc = " \\brief"]
#[doc = " Low Power mode configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlLowPowerModeCfg {
    #[doc = " @brief  Reserved for future"]
    pub reserved: rlUInt16_t,
    #[doc = " ADC Mode \\n"]
    #[doc = " @brief  0x00 : Regular ADC mode \\n"]
    #[doc = "0x01 : Low poer ADC mode \\n"]
    pub lpAdcMode: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlLowPowerModeCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlLowPowerModeCfg>(),
        4usize,
        concat!("Size of: ", stringify!(rlLowPowerModeCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlLowPowerModeCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlLowPowerModeCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLowPowerModeCfg>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLowPowerModeCfg),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLowPowerModeCfg>())).lpAdcMode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLowPowerModeCfg),
            "::",
            stringify!(lpAdcMode)
        )
    );
}
pub type rlLowPowerModeCfg_t = rlLowPowerModeCfg;
#[doc = " \\brief"]
#[doc = " Power saving mode configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlPowerSaveModeCfg {
    #[doc = " @brief  Low power state transition commands are defined as below \\n"]
    #[doc = "Mode       Definition \\n"]
    #[doc = "0          RESERVED \\n"]
    #[doc = "1          ENTER_RF_PWR_DOWN, device enters RF power down state from normal active"]
    #[doc = "state. \\n"]
    #[doc = "2          EXIT_RF_PWR_DOWN, device exits the RF power down state back to its"]
    #[doc = "previous state. \\n"]
    #[doc = "3          ENTER_APLL_PWR_DOWN, device enters APLL power down state from RF power"]
    #[doc = "down state. \\n"]
    #[doc = "Application has to ensure, the device MSS and DSS clock system is"]
    #[doc = "switched to XTAL clock before powering down APLL. \\n"]
    #[doc = "4          EXIT_APLL_PWR_DOWN, device exits the APLL power down state. \\n"]
    #[doc = "Application has to ensure, the device MSS and DSS clock system is"]
    #[doc = "switched back to APLL clock after powering up APLL. \\n"]
    #[doc = "5          ENTER_APLL_GPADC_PWR_DOWN, device enters APLL and GPADC power down"]
    #[doc = "state from RF power down state. \\n"]
    #[doc = "Application has to ensure, the device MSS and DSS clock system is"]
    #[doc = "switched to XTAL clock before powering down APLL. \\n"]
    #[doc = "6          EXIT_APLL_GPADC_PWR_DOWN, device exits the APLL and GPADC power down"]
    #[doc = "state. \\n"]
    #[doc = "Application has to ensure, the device MSS and DSS clock system is"]
    #[doc = "switched back to APLL clock after powering up APLL. \\n"]
    #[doc = "7-65535    RESERVED \\n"]
    pub lowPwrStateTransCmd: rlUInt16_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  Reserved for future use"]
    pub reserved: [rlUInt32_t; 4usize],
}
#[test]
fn bindgen_test_layout_rlPowerSaveModeCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlPowerSaveModeCfg>(),
        20usize,
        concat!("Size of: ", stringify!(rlPowerSaveModeCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlPowerSaveModeCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlPowerSaveModeCfg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPowerSaveModeCfg>())).lowPwrStateTransCmd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPowerSaveModeCfg),
            "::",
            stringify!(lowPwrStateTransCmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlPowerSaveModeCfg>())).reserved0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPowerSaveModeCfg),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlPowerSaveModeCfg>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPowerSaveModeCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlPowerSaveModeCfg_t = rlPowerSaveModeCfg;
#[doc = " \\brief"]
#[doc = " Profile config API parameters. A profile contains coarse parameters of FMCW chirp such as"]
#[doc = " start frequency, chirp slope, ramp time, idle time etc. Fine dithering values need"]
#[doc = " to be programmed in chirp configuration \\ref rlChirpCfg_t"]
#[doc = " \\note Maximum of 4 profiles can be configured."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlProfileCfg {
    #[doc = " @brief  Profile index (0-3)"]
    pub profileId: rlUInt16_t,
    #[doc = " @brief  Bit Description  \\n"]
    #[doc = "b0 FORCE_VCO_SEL (Not supported for production, debug purpose only) \\n"]
    #[doc = "0 - Use internal VCO selection    \\n"]
    #[doc = "1 - Forced external VCO selection \\n"]
    #[doc = "b1 VCO_SEL (Not supported for production, debug purpose only) \\n"]
    #[doc = "0 - VCO1 (77G:76 - 78 GHz or 60G:57 - 61 GHz)  \\n"]
    #[doc = "1 - VCO2 (77G:77 - 81 GHz or 60G:60 - 64 GHz)  \\n"]
    #[doc = "@note 1: xWR1xxx devices: There is an overlap region of 77-78 GHz in which any \\n"]
    #[doc = "of the VCOs can be used, for other regions use only the VCO which can \\n"]
    #[doc = "work in that region. For e.g. for 76-78 GHz use only VCO1 and for \\n"]
    #[doc = "77-81GHz use only VCO2, for 77-78 GHz, any VCO can be used. Also note \\n"]
    #[doc = "that users can inter-mix chirps from different VCOs within the same \\n"]
    #[doc = "frame."]
    #[doc = "@note 2: xWR6843 device: There is an overlap region of 60-61 GHz in which \\n"]
    #[doc = "any of the VCOs can be used. \\n"]
    #[doc = "b7:2 RESERVED            \\n"]
    pub pfVcoSelect: rlUInt8_t,
    #[doc = " @brief Bit Description       \\n"]
    #[doc = "b0 RETAIN_TXCAL_LUT \\n"]
    #[doc = "0 - Update TX calibration LUT           \\n"]
    #[doc = "1 - Do not update TX calibration LUT    \\n"]
    #[doc = "b1 RETAIN_RXCAL_LUT \\n"]
    #[doc = "0 - Update RX calibration LUT and update RX IQMM correction \\n"]
    #[doc = "1 - Do not update RX calibration LUT    \\n"]
    #[doc = "b7:2 RESERVED                            \\n"]
    #[doc = "If PF_TX_OUTPUT_POWER_BACKOFF is changed then set RETAIN_TXCAL_LUT to 0, \\n"]
    #[doc = "else set it to 1 and if PF_RX_GAIN is changed, then set RETAIN_RXCAL_LUT to 0 \\n"]
    #[doc = "else set them to 1."]
    pub pfCalLutUpdate: rlUInt8_t,
    #[doc = " @brief  Start frequency for each profile \\n"]
    #[doc = "For 77GHz devices (76 GHz - 81 GHz): \\n"]
    #[doc = "1 LSB = 3.6e9 / 2^26 Hz = 53.644 Hz  \\n"]
    #[doc = "Valid range: 0x5471C71B to 0x5A000000 \\n"]
    #[doc = "For 60GHz devices (57 GHz - 64 GHz): \\n"]
    #[doc = "1 LSB = 2.7e9 / 2^26 Hz = 40.233 Hz  \\n"]
    #[doc = "Valid range: Only even numbers from 0x5471C71C to 0x5ED097B4 \\n"]
    pub startFreqConst: rlUInt32_t,
    #[doc = " @brief  Idle time\\n"]
    #[doc = "1 LSB = 10 ns \\n"]
    #[doc = "Valid range: 0 to 524287 \\n"]
    pub idleTimeConst: rlUInt32_t,
    #[doc = " @brief  Time of starting of ADC capture relative to the knee of the ramp\\n"]
    #[doc = "1 LSB = 10 ns \\n"]
    #[doc = "Valid range: 0 to 4095 \\n"]
    pub adcStartTimeConst: rlUInt32_t,
    #[doc = " @brief  End of ramp time relative to the knee of the ramp\\n"]
    #[doc = "1 LSB = 10 ns\\n"]
    #[doc = "Valid range: 0 to 500000 \\n"]
    #[doc = "Ensure that the total frequency sweep is either within these ranges: \\n"]
    #[doc = "77G : 76 - 78 GHz or 77 - 81 GHz \\n"]
    #[doc = "60G : 57 - 60.75 GHz or 60 - 64 GHz \\n"]
    pub rampEndTime: rlUInt32_t,
    #[doc = " @brief  Concatenated code for output power backoff for TX0, TX1, TX2\\n"]
    #[doc = "Bit    Description  \\n"]
    #[doc = "b7:0   TX0 output power back off \\n"]
    #[doc = "b15:8  TX1 output power back off \\n"]
    #[doc = "b23:16 TX2 output power back off \\n"]
    #[doc = "b31:24 Reserved \\n"]
    #[doc = "This field defines how much the transmit power should be reduced from the maximum \\n"]
    #[doc = "1 LSB = 1 dB \\n"]
    #[doc = "Valid Range for xWR1xxx devices: 0 to 20 \\n"]
    #[doc = "Valid Range for xWR6x43 devices: 0 to 26 \\n"]
    #[doc = "0dB back-off corresponds to typically 12dBm power level in 1st gen xWR1xxx devices."]
    #[doc = "0dB back-off corresponds to typically 13dBm power level in xWR6843 devices. \\n"]
    #[doc = "@note : For best inter-TX channel matching performance, same chirp profile and \\n"]
    #[doc = "same TX backoff value should be used for all the TXs that are used in \\n"]
    #[doc = "beam-forming"]
    pub txOutPowerBackoffCode: rlUInt32_t,
    #[doc = " @brief  Concatenated phase shift for TX0/1/2,\\n"]
    #[doc = "Bit       Description \\n"]
    #[doc = "b1:0      Reserved (set to 0b00) \\n"]
    #[doc = "b7:2      TX0 phase shift value \\n"]
    #[doc = "b9:8      Reserved (set to 0b00) \\n"]
    #[doc = "b15:10    TX1 phase shift value \\n"]
    #[doc = "b17:16    Reserved (set to 0b00) \\n"]
    #[doc = "b23:18    TX2 phase shift value \\n"]
    #[doc = "b31:24    Reserved \\n"]
    #[doc = "1 LSB = 360/2^6 = 5.625 degrees \\n"]
    #[doc = "This field defines the additional phase shift to be introduced on each \\n"]
    #[doc = "transmitter output. \\n"]
    #[doc = "@note : Chirps corresponding to different profiles are not guaranteed to have \\n"]
    #[doc = "phase coherency."]
    pub txPhaseShifter: rlUInt32_t,
    #[doc = " @brief  Ramp slope frequency, \\n"]
    #[doc = "For 77GHz devices (76GHz to 81GHz): \\n"]
    #[doc = "1 LSB = (3.6e6 * 900) / 2^26 = 48.279 kHz/uS \\n"]
    #[doc = "Valid range: -2072 to 2072 (Max 100MHz/uS) \\n"]
    #[doc = "For 60GHz devices (57GHz to 64GHz): \\n"]
    #[doc = "1 LSB = (2.7e6 * 900) / 2^26 = 36.21 kHz/uS for 60GHz devices \\n"]
    #[doc = "Valid range: Only even numbers in -6905 to 6905 (Max 250 MHz/uS) \\n"]
    #[doc = "@note : Refer \\ref rlRfApllSynthBwControl_t bandwidth control API for \\n"]
    #[doc = "constraints on max slope."]
    pub freqSlopeConst: rlInt16_t,
    #[doc = " @brief  Time of start of transmitter relative to the knee of the ramp \\n"]
    #[doc = "1 LSB = 10ns \\n"]
    #[doc = "Valid range: -4096 to 4095 \\n"]
    pub txStartTime: rlInt16_t,
    #[doc = " @brief  Number of ADC samples to capture in a chirp for  each RX \\n"]
    #[doc = "Valid range: 2 to MAX_NUM_SAMPLES\\n"]
    #[doc = "Where MAX_NUM_SAMPLES is such that all the enabled RX channels' data fits \\n"]
    #[doc = "into 16 kB memory memory in AWR1243/xWR1443 or 32 kB memory in xWR1642/ \\n"]
    #[doc = "xWR6843/xWR1843, with each sample consuming 2 bytes for real ADC output \\n"]
    #[doc = "case and 4 bytes for complex 1x and complex 2x ADC output cases \\n"]
    #[doc = "number of RX chains    ADC format    Maximum Number of samples \\n"]
    #[doc = "4                      complex       1024 \\n"]
    #[doc = "4                      Real          2048 \\n"]
    #[doc = "2                      Complex       2048 \\n"]
    #[doc = "2                      Real          4096 \\n"]
    pub numAdcSamples: rlUInt16_t,
    #[doc = " @brief  ADC Sampling rate for each profile is encoded in \\n"]
    #[doc = "2 bytes (16 bit unsigned number) \\n"]
    #[doc = "1 LSB = 1 ksps \\n"]
    #[doc = "Valid range: xWR1xxx devices: 2000 to 37500 (Max 15MHz IF bandwidth) \\n"]
    #[doc = "xWR6x43 devices: 2000 to 25000 (Max 10MHz IF bandwidth) \\n"]
    #[doc = "The maximum sampling rate supported is limited based on the information"]
    #[doc = "below. \\n"]
    #[doc = "<table>"]
    #[doc = "<caption id=\"IF_BW_15MHz\">When device supports 15 MHz IF bandwidth (refer"]
    #[doc = "device data sheet)</caption>"]
    #[doc = "<tr><th>ADC mode   <th>Real/PseudoReal   <th>Complex1x   <th>Complex2x"]
    #[doc = "<tr><td>Regular ADC mode<td>37.5 Msps<td>18.75 Msps<td>37.5 Msps"]
    #[doc = "<tr><td>Low power ADC mode(xWR1xxx)<td>18.75 Msps<td>9.375 Msps<td>18.75 Msps"]
    #[doc = "</table>"]
    #[doc = "<table>"]
    #[doc = "<caption id=\"IF_BW_10MHz\">When device supports 10 MHz IF bandwidth (refer"]
    #[doc = "device data sheet)</caption>"]
    #[doc = "<tr><th>ADC mode   <th>Real/PseudoReal   <th>Complex1x   <th>Complex2x"]
    #[doc = "<tr><td>Regular ADC mode<td>25 Msps<td>12.5 Msps<td>25 Msps"]
    #[doc = "<tr><td>Low power ADC mode(xWR6x43)<td>25 Msps<td>12.5 Msps<td>25 Msps"]
    #[doc = "<tr><td>Low power ADC mode(xWR1xxx)<td>18.75 Msps<td>9.375 Msps<td>18.75 Msps"]
    #[doc = "</table>"]
    #[doc = "<table>"]
    #[doc = "<caption id=\"IF_BW_5MHz\">When device supports 5 MHz IF bandwidth (refer"]
    #[doc = "device data sheet)</caption>"]
    #[doc = "<tr><th>ADC mode   <th>Real/PseudoReal   <th>Complex1x   <th>Complex2x"]
    #[doc = "<tr><td>Regular ADC mode<td>12.5 Msps<td>6.25 Msps<td>12.5 Msps"]
    #[doc = "<tr><td>Low power ADC mode(xWR6x43)<td>12.5 Msps<td>6.25 Msps<td>12.5 Msps"]
    #[doc = "<tr><td>Low power ADC mode(xWR1xxx)<td>12.5 Msps<td>6.25 Msps<td>12.5 Msps"]
    #[doc = "</table>"]
    pub digOutSampleRate: rlUInt16_t,
    #[doc = " @brief  Code for HPF1 corner frequency\\n"]
    #[doc = "0x00 175 kHz \\n"]
    #[doc = "0x01 235 kHz \\n"]
    #[doc = "0x02 350 kHz \\n"]
    #[doc = "0x03 700 kHz \\n"]
    pub hpfCornerFreq1: rlUInt8_t,
    #[doc = " @brief  Code for HPF2 corner frequency\\n"]
    #[doc = "0x00 350 kHz \\n"]
    #[doc = "0x01 700 kHz \\n"]
    #[doc = "0x02 1.4 MHz \\n"]
    #[doc = "0x03 2.8 MHz \\n"]
    pub hpfCornerFreq2: rlUInt8_t,
    #[doc = " @brief  Number of transmitters to turn on during TX power  \\n"]
    #[doc = "calibration. During actual operation, if more than \\n"]
    #[doc = "1 TXs are enabled during the chirp, then enabling  \\n"]
    #[doc = "the same TXs during calibration will have better TX \\n"]
    #[doc = "output power accuracy \\n"]
    #[doc = "b2:0 TX enabled during TX0 calibration \\n"]
    #[doc = "b0 - TX0, b1 - TX1, b2 - TX2 \\n"]
    #[doc = "b5:3 TX enabled during TX1 calibration \\n"]
    #[doc = "b3 - TX0, b4 - TX1, b5 - TX2 \\n"]
    #[doc = "b8:6 TX enabled during TX2 calibration \\n"]
    #[doc = "b6 - TX0, b7 - TX1, b8 - TX2 \\n"]
    #[doc = "b14:9 RESERVED \\n"]
    #[doc = "b15  Enable multi TX enable during TX power calibration. \\n"]
    #[doc = "@note 1: If this bit is not set, only 1 TX is enabled \\n"]
    #[doc = "during the TX power calibration. For e.g. during TX0 \\n"]
    #[doc = "calibration, only TX0 will be enabled; during TX1 \\n"]
    #[doc = "calibration, only TX1 will be enabled and so on. \\n"]
    #[doc = "NOTE: This field is not applcicable for IWR6843 ES 1.0"]
    pub txCalibEnCfg: rlUInt16_t,
    #[doc = " @brief"]
    #[doc = "b5:0  Code for Rx VGA gain\\n"]
    #[doc = "1 LSB = 1 dB\\n"]
    #[doc = "Valid values:"]
    #[doc = "For xWR1xxx : all even values from 24 to 52"]
    #[doc = "For xWR6x43 : all even values from 30 to 48"]
    #[doc = "b7:6  Code for RF gain target (Not applicable for IWR6843 ES1.0, \\n"]
    #[doc = "RF gain is fixed to 34dB). \\n"]
    #[doc = "For xWR1243/xWR1443/xWR1642/xWR1843:"]
    #[doc = "00 - 30 dB \\n"]
    #[doc = "01 - 34 dB \\n"]
    #[doc = "10 - RESERVED \\n"]
    #[doc = "11 - 26 dB \\n"]
    #[doc = "For xWR6843 ES 2.0:"]
    #[doc = "00 - 30 dB \\n"]
    #[doc = "01 - 33 dB \\n"]
    #[doc = "10 - 36 dB \\n"]
    #[doc = "11 - RESERVED \\n"]
    #[doc = "b15:8 RESERVED \\n"]
    #[doc = "In IWR6843 ES1.0 device, Rx Gain is not accurate and not calibrated. \\n"]
    #[doc = "The RF gain is 34dB and total Rx gain can be varied from 28dB to 56dB \\n"]
    pub rxGain: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlProfileCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlProfileCfg>(),
        44usize,
        concat!("Size of: ", stringify!(rlProfileCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlProfileCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlProfileCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).profileId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(profileId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).pfVcoSelect as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(pfVcoSelect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).pfCalLutUpdate as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(pfCalLutUpdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).startFreqConst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(startFreqConst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).idleTimeConst as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(idleTimeConst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).adcStartTimeConst as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(adcStartTimeConst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).rampEndTime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(rampEndTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlProfileCfg>())).txOutPowerBackoffCode as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(txOutPowerBackoffCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).txPhaseShifter as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(txPhaseShifter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).freqSlopeConst as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(freqSlopeConst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).txStartTime as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(txStartTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).numAdcSamples as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(numAdcSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).digOutSampleRate as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(digOutSampleRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).hpfCornerFreq1 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(hpfCornerFreq1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).hpfCornerFreq2 as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(hpfCornerFreq2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).txCalibEnCfg as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(txCalibEnCfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).rxGain as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(rxGain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlProfileCfg>())).reserved as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(rlProfileCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlProfileCfg_t = rlProfileCfg;
#[doc = " \\brief"]
#[doc = " Chirp config API parameters. This structure contains fine dithering to coarse profile"]
#[doc = " defined in \\ref rlProfileCfg_t. It also includes the selection of Transmitter and"]
#[doc = " binary phase modulation for a chirp.\\n"]
#[doc = " @note : One can define upto 512 unique chirps.These chirps need to be included in"]
#[doc = "         frame configuration structure \\ref rlFrameCfg_t to create FMCW frame"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlChirpCfg {
    #[doc = " @brief  Chirp start index (0-511)"]
    pub chirpStartIdx: rlUInt16_t,
    #[doc = " @brief  Chirp end index (0-511)"]
    pub chirpEndIdx: rlUInt16_t,
    #[doc = " @brief  Associated profile id (0-3)"]
    pub profileId: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt16_t,
    #[doc = " @brief  Ramp start frequency, \\n"]
    #[doc = "For 77GHz devices(76GHz to 81GHz): \\n"]
    #[doc = "1 LSB = 3.6e9/2^26 = 53.644 Hz \\n"]
    #[doc = "valid range = 0-8388607 \\n"]
    #[doc = "For 60GHz devices(57GHz to 64GHz): \\n"]
    #[doc = "1 LSB = 2.7e9/2^26 = 40.233 Hz \\n"]
    #[doc = "valid range = Only even numbers from 0-8388607 \\n"]
    pub startFreqVar: rlUInt32_t,
    #[doc = " @brief  Ramp slope\\n"]
    #[doc = "For 77GHz devices(76GHz to 81GHz): \\n"]
    #[doc = "1 LSB = 3.6e6 * 900/2^26 = 48.279 KHz/us \\n"]
    #[doc = "valid range = 0-63 \\n"]
    #[doc = "For 60GHz devices(57GHz to 64GHz): \\n"]
    #[doc = "1 LSB = 2.7e6 * 900/2^26 = 36.21 KHz/us \\n"]
    #[doc = "valid range = Only even numbers between 0 to 63 \\n"]
    pub freqSlopeVar: rlUInt16_t,
    #[doc = " @brief  Idle time for each chirp\\n"]
    #[doc = "1 LSB = 10ns\\n"]
    #[doc = "valid range = 0-4096 \\n"]
    pub idleTimeVar: rlUInt16_t,
    #[doc = " @brief  Adc start time for each chirp \\n"]
    #[doc = "1 LSB = 10ns \\n"]
    #[doc = "valid range = 0-4096 \\n"]
    pub adcStartTimeVar: rlUInt16_t,
    #[doc = " @brief  Tx enable selection bit mask \\n"]
    #[doc = "b0 Enable TX0 \\n"]
    #[doc = "0 Tx0 Disable \\n"]
    #[doc = "1 Tx0 Enable \\n"]
    #[doc = "b1 Enable TX1 \\n"]
    #[doc = "0 Tx1 Disable \\n"]
    #[doc = "1 Tx1 Enable \\n"]
    #[doc = "b2 Enable TX2 \\n"]
    #[doc = "0 Tx2 Disable \\n"]
    #[doc = "1 Tx2 Enable  \\n"]
    #[doc = "@note : Maximum of only 2 TX can be turned in a chirp \\n"]
    pub txEnable: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlChirpCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlChirpCfg>(),
        20usize,
        concat!("Size of: ", stringify!(rlChirpCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlChirpCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlChirpCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChirpCfg>())).chirpStartIdx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpCfg),
            "::",
            stringify!(chirpStartIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChirpCfg>())).chirpEndIdx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpCfg),
            "::",
            stringify!(chirpEndIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChirpCfg>())).profileId as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpCfg),
            "::",
            stringify!(profileId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChirpCfg>())).reserved as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpCfg),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChirpCfg>())).startFreqVar as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpCfg),
            "::",
            stringify!(startFreqVar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChirpCfg>())).freqSlopeVar as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpCfg),
            "::",
            stringify!(freqSlopeVar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChirpCfg>())).idleTimeVar as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpCfg),
            "::",
            stringify!(idleTimeVar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChirpCfg>())).adcStartTimeVar as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpCfg),
            "::",
            stringify!(adcStartTimeVar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChirpCfg>())).txEnable as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpCfg),
            "::",
            stringify!(txEnable)
        )
    );
}
pub type rlChirpCfg_t = rlChirpCfg;
#[doc = " \\brief"]
#[doc = " Chirp start, end Index parameters for rlGetChirpConfig"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlWordParam {
    pub halfWordOne: rlUInt16_t,
    pub halfWordTwo: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlWordParam() {
    assert_eq!(
        ::core::mem::size_of::<rlWordParam>(),
        4usize,
        concat!("Size of: ", stringify!(rlWordParam))
    );
    assert_eq!(
        ::core::mem::align_of::<rlWordParam>(),
        2usize,
        concat!("Alignment of ", stringify!(rlWordParam))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlWordParam>())).halfWordOne as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlWordParam),
            "::",
            stringify!(halfWordOne)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlWordParam>())).halfWordTwo as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlWordParam),
            "::",
            stringify!(halfWordTwo)
        )
    );
}
pub type rlWordParam_t = rlWordParam;
#[doc = " \\brief"]
#[doc = " Frame config API parameters"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlFrameCfg {
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  Start Index of Chirp Valid range = 0-511"]
    pub chirpStartIdx: rlUInt16_t,
    #[doc = " @brief  End Index of Chirp Valid range = chirpStartIdx-511"]
    pub chirpEndIdx: rlUInt16_t,
    #[doc = " @brief  Number of times to repeat from chirpStartIdx to chirpStartIdx in each frame, \\n"]
    #[doc = "valid range = 1 to 255 \\n"]
    pub numLoops: rlUInt16_t,
    #[doc = " @brief  Number of frame to transmit \\n"]
    #[doc = "Valid Range 0 to 65535 (0 for infinite frames) \\n"]
    pub numFrames: rlUInt16_t,
    #[doc = " @brief  Number of ADC samples to capture This parameter is required only for AWR1243 and \\n"]
    #[doc = "configures the size of ADC samples per chirp to be sent on LVDS/CSI2 \\n"]
    #[doc = "interface.\\n"]
    #[doc = "It should be configured as:"]
    #[doc = "For real/pseudo real ADC data - numADCSamples = rlProfileCfg_t.numAdcSamples \\n"]
    #[doc = "For complex1x/complex2x ADC data -  \\n"]
    #[doc = "numADCSamples = (rlProfileCfg_t.numAdcSamples ) * 2 \\n"]
    pub numAdcSamples: rlUInt16_t,
    #[doc = " @brief  Frame repitition period \\n"]
    #[doc = "PERIOD >= Sum total time of all chirps + InterFrameBlankTime,"]
    #[doc = "where, Sum total time of all chirps = Num Loops * Num chirps * Chirp Period. \\n"]
    #[doc = "InterFrameBlankTime is primarily for sensor calibration/monitoring, thermal"]
    #[doc = "control, transferring out any safety monitoring data if requested, hardware"]
    #[doc = "reconfiguration for next frame, re-triggering of next frame. \\n"]
    #[doc = "InterFrameBlankTime >= 300 μs typically. \\n"]
    #[doc = "Add 150 us to InterFrameBlankTime if data-path reconfiguration needed in frame"]
    #[doc = "boundary due to change in profile. \\n"]
    #[doc = "1 LSB = 5 ns \\n"]
    #[doc = "Valid range : 300 us to 1.342 s \\n"]
    pub framePeriodicity: rlUInt32_t,
    #[doc = " @brief  Selects the mode for triggering start of transmission of frame \\n"]
    #[doc = "0x0001 SWTRIGGER (Software API based triggering): \\n"]
    #[doc = "Frame is triggered upon receiving rlSensorStart\\n"]
    #[doc = "There could be several tens of micro seconds uncertainty in triggering. \\n"]
    #[doc = "@note : This mode is not applicable if this mmwave device is configured as \\n"]
    #[doc = "MULTICHIP_SLAVE in rlChanCfg_t \\n"]
    #[doc = "0x0002 HWTRIGGER (Hardware SYNC_IN based triggering): \\n"]
    #[doc = "Each frame is triggered by rising edge of pulse in SYNC_IN pin, after"]
    #[doc = "receiving rlSensorStart (this is to prevent spurious transmission)."]
    #[doc = "W.r.t. the SYNC_IN pulse, the actual transmission has ~160ns delay and 5ns"]
    #[doc = "uncertainty in SINGLECHIP and only a 300 ps uncertainty (due to tight inter-chip"]
    #[doc = "synchronization needed) in MULTICHIP sensor applications as defined in"]
    #[doc = "rlChanCfg_t. \\n"]
    #[doc = "For more details please refer to device datasheet. \\n"]
    pub triggerSelect: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt8_t,
    #[doc = " @brief  Number of dummy chirps which will run in the rampgen at the end of the frame. The"]
    #[doc = "         ADC data, CP and CQ data for these chirps will not be sent out from the \\n"]
    #[doc = "         device/DFE. \\n"]
    #[doc = "         1LSB = 1 dummy chirp in the end of frame. \\n"]
    #[doc = "         valid range: 0 to 128 (should be less than the total number of chirps in a \\n"]
    #[doc = "         frame). \\n"]
    pub numDummyChirpsAtEnd: rlUInt8_t,
    #[doc = " @brief  Optional time delay from sync_in trigger to the occurance of frame chirps \\n"]
    #[doc = "Applicable only in SINGLECHIP sensor applications, as defined in rlChanCfg_t.\\n"]
    #[doc = "It is recommended only for staggering the transmission of multiple mmwave \\n"]
    #[doc = "sensors around the car for interference avoidance, if needed.\\n"]
    #[doc = "1 lsb = 5 ns \\n"]
    #[doc = "Typical range is 0 to 100 micro seconds. \\n"]
    pub frameTriggerDelay: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlFrameCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlFrameCfg>(),
        24usize,
        concat!("Size of: ", stringify!(rlFrameCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlFrameCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlFrameCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameCfg>())).reserved0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameCfg),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameCfg>())).chirpStartIdx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameCfg),
            "::",
            stringify!(chirpStartIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameCfg>())).chirpEndIdx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameCfg),
            "::",
            stringify!(chirpEndIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameCfg>())).numLoops as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameCfg),
            "::",
            stringify!(numLoops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameCfg>())).numFrames as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameCfg),
            "::",
            stringify!(numFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameCfg>())).numAdcSamples as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameCfg),
            "::",
            stringify!(numAdcSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameCfg>())).framePeriodicity as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameCfg),
            "::",
            stringify!(framePeriodicity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameCfg>())).triggerSelect as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameCfg),
            "::",
            stringify!(triggerSelect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameCfg>())).reserved1 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameCfg),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameCfg>())).numDummyChirpsAtEnd as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameCfg),
            "::",
            stringify!(numDummyChirpsAtEnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameCfg>())).frameTriggerDelay as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameCfg),
            "::",
            stringify!(frameTriggerDelay)
        )
    );
}
pub type rlFrameCfg_t = rlFrameCfg;
#[doc = " \\brief"]
#[doc = " Advance Frame config API Subframe configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlSubFrameCfg {
    #[doc = " @brief  Force profile index. This is applicable only if FORCE_SINGLE_PROFILE is set to 1"]
    pub forceProfileIdx: rlUInt16_t,
    #[doc = " @brief  Start Index of Chirp Valid range = 0-511"]
    pub chirpStartIdx: rlUInt16_t,
    #[doc = " @brief  Num of unique Chirps per burst including start index Valid range = 1 - 512"]
    pub numOfChirps: rlUInt16_t,
    #[doc = " @brief  No. of times to loop through the unique chirps in each burst, without gaps, \\n"]
    #[doc = "using HW.\\n valid range = 1 to 255 \\n"]
    pub numLoops: rlUInt16_t,
    #[doc = " @brief  burstPeriodicity >= (numLoops)* (sum total of all unique chirp times per burst) +"]
    #[doc = "InterBurstBlankTime, \\n"]
    #[doc = "where InterBurstBlankTime is primarily for sensor calibration / monitoring, \\n"]
    #[doc = "thermal control, and some minimum time needed for triggering next burst. \\n"]
    #[doc = "InterBurstBlankTime >= 100 us. Refer a NOTE at end of this API for more info. \\n"]
    #[doc = "With loop back enabled, InterBurstBlankTime >= 500 us \\n"]
    #[doc = "@note : Across bursts, if the value numOfChirps, is not a constant, then the \\n"]
    #[doc = "actual available blank time can vary and needs to be accounted for \\n"]
    #[doc = "1 LSB = 5 ns \\n"]
    pub burstPeriodicity: rlUInt32_t,
    #[doc = " @brief  Chirp Start address increment for next burst, \\n"]
    #[doc = "next_burst_chirp_start_idx = last_chirp_end_index + \\n"]
    #[doc = "h_ChirpStartIdxIncr 0 - 511, 0 = 2nd burst = 1st burst \\n"]
    pub chirpStartIdxOffset: rlUInt16_t,
    #[doc = " @brief  Num of bursts in the sub-frame. Valid Range: 1 - 512 \\n"]
    #[doc = "         Valid range: 1 to 16 for loop-back sub-frame \\n"]
    pub numOfBurst: rlUInt16_t,
    #[doc = " @brief  Number of times to loop over the set of above defined bursts, in the sub frame. \\n"]
    #[doc = "Valid Range: 1 - 64 \\n"]
    #[doc = "This field is not applicable for loop-back sub-frame \\n"]
    pub numOfBurstLoops: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  subFramePeriodicity >= Sum total time of all bursts + InterSubFrameBlankTime, \\n"]
    #[doc = "Where, Sum total time of all bursts = numOfBurstLoops * numOfBurst * \\n"]
    #[doc = "burstPeriodicity. \\n"]
    #[doc = "InterSubFrameBlankTime is primarily for sensor calibration / monitoring, \\n"]
    #[doc = "thermal control, transferring out any safety monitoring data if requested, \\n"]
    #[doc = "hardware reconfiguration for next sub frame, re-triggering of next SF (~10us). \\n"]
    #[doc = "The hardware reconfiguration time, which is needed to transfer out the SF's \\n"]
    #[doc = "InterSubFrameBlankTime >= 300 us. \\n"]
    #[doc = "Add 150 us to InterSubFrameBlankTime if data-path re-configuration needed in"]
    #[doc = "sub-frame boundary due to change in profile. \\n"]
    #[doc = "1 LSB = 5 ns \\n"]
    #[doc = "Valid range 300 us to 1.342 s. \\n"]
    pub subFramePeriodicity: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlSubFrameCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlSubFrameCfg>(),
        32usize,
        concat!("Size of: ", stringify!(rlSubFrameCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlSubFrameCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlSubFrameCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSubFrameCfg>())).forceProfileIdx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameCfg),
            "::",
            stringify!(forceProfileIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSubFrameCfg>())).chirpStartIdx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameCfg),
            "::",
            stringify!(chirpStartIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSubFrameCfg>())).numOfChirps as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameCfg),
            "::",
            stringify!(numOfChirps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSubFrameCfg>())).numLoops as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameCfg),
            "::",
            stringify!(numLoops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSubFrameCfg>())).burstPeriodicity as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameCfg),
            "::",
            stringify!(burstPeriodicity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlSubFrameCfg>())).chirpStartIdxOffset as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameCfg),
            "::",
            stringify!(chirpStartIdxOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSubFrameCfg>())).numOfBurst as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameCfg),
            "::",
            stringify!(numOfBurst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSubFrameCfg>())).numOfBurstLoops as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameCfg),
            "::",
            stringify!(numOfBurstLoops)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSubFrameCfg>())).reserved0 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameCfg),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlSubFrameCfg>())).subFramePeriodicity as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameCfg),
            "::",
            stringify!(subFramePeriodicity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSubFrameCfg>())).reserved1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameCfg),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSubFrameCfg>())).reserved2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameCfg),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type rlSubFrameCfg_t = rlSubFrameCfg;
#[doc = " \\brief"]
#[doc = " Advance Frame Sequence config API parameters rlAdvFrameCfg, 148 bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlAdvFrameSeqCfg {
    #[doc = " @brief  Number of sub frames enabled in this frame Valid range: 1 to 4"]
    pub numOfSubFrames: rlUInt8_t,
    #[doc = " @brief  Force profile. \\n"]
    #[doc = "0x0 The profile index set in rlSetChirpConfig API governs which profile is \\n"]
    #[doc = "used when that chirp is transmitted \\n"]
    #[doc = "0x1 The profile index indicated in rlSetChirpConfig API is ignored and all \\n"]
    #[doc = "the chirps in each sub frame use a single profile as indicated by that sub \\n"]
    #[doc = "frame's profile forceProfileIdx. \\n"]
    #[doc = "@note : This Field is not used/applicable for loop-back sub-frame. \\n"]
    pub forceProfile: rlUInt8_t,
    #[doc = " @brief Bit  Definition \\n"]
    #[doc = "b0   LOOPBACK_CFG_EN \\n"]
    #[doc = "0 - Disable \\n"]
    #[doc = "1 - Enable  \\n"]
    #[doc = "b2:1  SUB_FRAME_ID for which the loop-back configuration applies \\n"]
    #[doc = "b7:3  RESERVED \\n"]
    pub loopBackCfg: rlUInt8_t,
    #[doc = " @brief  Sub frame trigger"]
    #[doc = "              0 - Disabled (default mode, i.e no trigger is required in Frame SW triggered \\n"]
    #[doc = "                  mode and a pulse trigger is required for every burst start in frame HW \\n"]
    #[doc = "                  triggered mode) \\n"]
    #[doc = "              1 - Enabled (Need to trigger each sub-frame either by SW in \\n"]
    #[doc = "                  software triggered mode through AWR_SUBFRAME_START_CONF_SB API or HW \\n"]
    #[doc = "                  pulse in hardware triggered mode) \\n"]
    #[doc = "          @note : Disable WDT if this mode is enabled."]
    pub subFrameTrigger: rlUInt8_t,
    #[doc = " @brief  Subframe config for 4 sub frames"]
    pub subFrameCfg: [rlSubFrameCfg_t; 4usize],
    #[doc = " @brief  Number of frames to transmit (1 frame = all enabled sub frames). If set to 0, \\n"]
    #[doc = "frames are transmitted endlessly till Frame Stop message is received.\\n"]
    #[doc = "Valid range: 0 to 65535 \\n"]
    pub numFrames: rlUInt16_t,
    #[doc = " @brief  Selects the mode for triggering start of transmission of frame \\n"]
    #[doc = "0x0001 SWTRIGGER (Software API based triggering): \\n"]
    #[doc = "Frame is triggered upon receiving rlSensorStart There could be several tens \\n"]
    #[doc = "of micro seconds uncertainty in triggering. \\n"]
    #[doc = "@note :This mode is not applicable if this mmwave device is configured as \\n"]
    #[doc = "MULTICHIP_SLAVE in rlChanCfg_t \\n"]
    #[doc = "0x0002 HWTRIGGER (Hardware SYNC_IN based triggering): \\n"]
    #[doc = "Each frame is triggered by rising edge of pulse in SYNC_IN pin, after \\n"]
    #[doc = "receiving rlSensorStart (this is to \\n prevent spurious transmission). \\n"]
    #[doc = "W.r.t. the SYNC_IN pulse, the actual transmission has 5ns uncertainty in \\n"]
    #[doc = "SINGLECHIP and only a 300 ps uncertainty (due to tight inter-chip \\n"]
    #[doc = "synchronization needed) in MULTICHIP sensor applications as defined in \\n"]
    #[doc = "rlChanCfg_t. \\n"]
    pub triggerSelect: rlUInt16_t,
    #[doc = " @brief  Optional time delay from sync_in trigger to the occurance of frame chirps \\n"]
    #[doc = "Applicable only in SINGLECHIP sensor applications, as defined in rlChanCfg_t.\\n"]
    #[doc = "It is recommended only for staggering the transmission of multiple mmwave \\n"]
    #[doc = "sensors around the car for interference avoidance, if needed. \\n"]
    #[doc = "1 lsb = 5 ns \\n"]
    #[doc = "Typical range is 0 to few tens of micro seconds. \\n"]
    pub frameTrigDelay: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlAdvFrameSeqCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlAdvFrameSeqCfg>(),
        148usize,
        concat!("Size of: ", stringify!(rlAdvFrameSeqCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlAdvFrameSeqCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlAdvFrameSeqCfg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAdvFrameSeqCfg>())).numOfSubFrames as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameSeqCfg),
            "::",
            stringify!(numOfSubFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdvFrameSeqCfg>())).forceProfile as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameSeqCfg),
            "::",
            stringify!(forceProfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdvFrameSeqCfg>())).loopBackCfg as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameSeqCfg),
            "::",
            stringify!(loopBackCfg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAdvFrameSeqCfg>())).subFrameTrigger as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameSeqCfg),
            "::",
            stringify!(subFrameTrigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdvFrameSeqCfg>())).subFrameCfg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameSeqCfg),
            "::",
            stringify!(subFrameCfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdvFrameSeqCfg>())).numFrames as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameSeqCfg),
            "::",
            stringify!(numFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdvFrameSeqCfg>())).triggerSelect as *const _ as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameSeqCfg),
            "::",
            stringify!(triggerSelect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAdvFrameSeqCfg>())).frameTrigDelay as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameSeqCfg),
            "::",
            stringify!(frameTrigDelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdvFrameSeqCfg>())).reserved0 as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameSeqCfg),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdvFrameSeqCfg>())).reserved1 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameSeqCfg),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlAdvFrameSeqCfg_t = rlAdvFrameSeqCfg;
#[doc = " \\brief"]
#[doc = " Frame config API parameters"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlFrameApplyCfg {
    #[doc = " @brief  Number of Chirps per Frame"]
    pub numChirps: rlUInt32_t,
    #[doc = " @brief  Number of half words in ADC buffer per chirp \\n"]
    #[doc = "Example 1:  In real mode, if number of ADC samples per chirp is 256 then this \\n"]
    #[doc = "value will be 256 \\n"]
    #[doc = "Example 2: In complex1x or complex2x modes,if number of ADC samples per chirp \\n"]
    #[doc = "is 256 then this value will be 512 \\n"]
    pub numAdcSamples: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlFrameApplyCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlFrameApplyCfg>(),
        8usize,
        concat!("Size of: ", stringify!(rlFrameApplyCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlFrameApplyCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlFrameApplyCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameApplyCfg>())).numChirps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameApplyCfg),
            "::",
            stringify!(numChirps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameApplyCfg>())).numAdcSamples as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameApplyCfg),
            "::",
            stringify!(numAdcSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameApplyCfg>())).reserved as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameApplyCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlFrameApplyCfg_t = rlFrameApplyCfg;
#[doc = " \\brief"]
#[doc = " Sub Frame data config API parameters"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlSubFrameDataCfg {
    #[doc = " @brief  Number of Chirps in Sub-Frame = numOfChirps * numLoops * numOfBurst * burstLoop"]
    pub totalChirps: rlUInt32_t,
    #[doc = " @brief  Number of half words of ADC samples per data packet in sub frame 1 \\n"]
    #[doc = "Example 1:  In real mode, if number of ADC samples per chirp in subframe1 is"]
    #[doc = "256 then this value will be 256 \\n"]
    #[doc = "Example 2: In complex1x or complex2x modes, if number of ADC samples per"]
    #[doc = "chirp in subframe1 is 256 then this value will be 512 \\n"]
    #[doc = "In AWR1243/xWR1443: Program this as number of ADC samples in each chirp of"]
    #[doc = "this sub frame (required to be the same) \\n"]
    #[doc = "Exception: Can do number of chirps based ping-pong as in xWR1642"]
    #[doc = "(see below), if CP/CQ are not needed. Useful for chirp stitching use case. \\n"]
    #[doc = "In xWR1642/xWR1843(For reference only): The ADC samples corresponding to one or"]
    #[doc = "more chirps can be grouped and sent to the DSP as a single packet. Program this"]
    #[doc = "as the number of half words of ADC samples per packet. Ensure that in one sub"]
    #[doc = "frame, there is integer number of such packets. \\n"]
    #[doc = "Maximum size of a data packet: (16384 - 1) half words"]
    pub numAdcSamples: rlUInt16_t,
    #[doc = " @brief  Number of Chirps Per Data Packet to process at a time in sub frame 1. \\n"]
    #[doc = "In AWR1243/xWR1443: Program this as 1. \\n"]
    #[doc = "Exception: Can be > 1 as in 16xx if CP/CQ is not needed. Useful for chirp"]
    #[doc = "stitching use case. \\n"]
    #[doc = "In xWR1642/xWR1843(For reference only): The ADC samples corresponding to one or"]
    #[doc = "more chirps can be grouped and sent to the DSP as a single packet. Program this"]
    #[doc = "as the corresponding number of chirps per packet. \\n"]
    #[doc = "Maximum value = 8. \\n"]
    #[doc = "Note on maximum size: 8 chirps for CP and BPM."]
    pub numChirpsInDataPacket: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlSubFrameDataCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlSubFrameDataCfg>(),
        8usize,
        concat!("Size of: ", stringify!(rlSubFrameDataCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlSubFrameDataCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlSubFrameDataCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSubFrameDataCfg>())).totalChirps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameDataCfg),
            "::",
            stringify!(totalChirps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlSubFrameDataCfg>())).numAdcSamples as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameDataCfg),
            "::",
            stringify!(numAdcSamples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlSubFrameDataCfg>())).numChirpsInDataPacket as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameDataCfg),
            "::",
            stringify!(numChirpsInDataPacket)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSubFrameDataCfg>())).reserved as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameDataCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlSubFrameDataCfg_t = rlSubFrameDataCfg;
#[doc = " \\brief"]
#[doc = " Advance Frame data config API parameters."]
#[doc = " This structure is only applicable when mmWaveLink instance is running on"]
#[doc = " External Host and connected to AWR1243 device."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlAdvFrameDataCfg {
    #[doc = " @brief  Number of Sub Frames, Valid Range (1 - 4)"]
    pub numSubFrames: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  Sub Frame data configuration array."]
    pub subframeDataCfg: [rlSubFrameDataCfg_t; 4usize],
}
#[test]
fn bindgen_test_layout_rlAdvFrameDataCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlAdvFrameDataCfg>(),
        36usize,
        concat!("Size of: ", stringify!(rlAdvFrameDataCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlAdvFrameDataCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlAdvFrameDataCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdvFrameDataCfg>())).numSubFrames as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameDataCfg),
            "::",
            stringify!(numSubFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdvFrameDataCfg>())).reserved0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameDataCfg),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdvFrameDataCfg>())).reserved1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameDataCfg),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAdvFrameDataCfg>())).subframeDataCfg as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameDataCfg),
            "::",
            stringify!(subframeDataCfg)
        )
    );
}
pub type rlAdvFrameDataCfg_t = rlAdvFrameDataCfg;
#[doc = " \\brief"]
#[doc = " Advance Frame Sequence config API parameters rlAdvFrameCfg, 148 bytes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlAdvFrameCfg {
    #[doc = " @brief  Advance Frame sequence and Subframe configuration"]
    pub frameSeq: rlAdvFrameSeqCfg_t,
    #[doc = " @brief  Advance Frame data configuration. Applicable with AWR1243 device only"]
    pub frameData: rlAdvFrameDataCfg_t,
}
#[test]
fn bindgen_test_layout_rlAdvFrameCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlAdvFrameCfg>(),
        184usize,
        concat!("Size of: ", stringify!(rlAdvFrameCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlAdvFrameCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlAdvFrameCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdvFrameCfg>())).frameSeq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameCfg),
            "::",
            stringify!(frameSeq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAdvFrameCfg>())).frameData as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAdvFrameCfg),
            "::",
            stringify!(frameData)
        )
    );
}
pub type rlAdvFrameCfg_t = rlAdvFrameCfg;
#[doc = " \\brief"]
#[doc = " Continous Mode config API parameters"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlContModeCfg {
    #[doc = " @brief  Start frequency \\n"]
    #[doc = "For 77GHz devices (76 - 81 GHz): \\n"]
    #[doc = "1 LSB = 3.6e9 / 2^26 Hz = 53.644 Hz \\n"]
    #[doc = "Valid range: 0x5471C71B to 0x5A000000 \\n"]
    #[doc = "For 60GHz devices (57 - 64 GHz): \\n"]
    #[doc = "1 LSB = 2.7e9 / 2^26 Hz = 40.233 Hz \\n"]
    #[doc = "Valid range: Only even numbers from 0x5471C71C to 0x5ED097B4 \\n"]
    pub startFreqConst: rlUInt32_t,
    #[doc = " @brief  Concatenated code for output power backoff for TX0, TX1, TX2 \\n"]
    #[doc = "b7:0 TX0 output power back off \\n"]
    #[doc = "b15:8 TX1 output power back off \\n"]
    #[doc = "b23:16 TX2 output power back off \\n"]
    #[doc = "b31:24 Reserved \\n"]
    #[doc = "This field defines how much the transmit power should be reduced from the \\n"]
    #[doc = "maximum. \\n"]
    #[doc = "1 LSB = 1 dB \\n"]
    pub txOutPowerBackoffCode: rlUInt32_t,
    #[doc = " @brief  Concatenated phase shift for TX0/1/2, \\n"]
    #[doc = "Bit       Description \\n"]
    #[doc = "b1:0      Reserved (set to 0b00) \\n"]
    #[doc = "b7:2      TX0 phase shift value \\n"]
    #[doc = "b9:8      Reserved (set to 0b00) \\n"]
    #[doc = "b15:10    TX1 phase shift value \\n"]
    #[doc = "b17:16    Reserved (set to 0b00) \\n"]
    #[doc = "b23:18    TX2 phase shift value \\n"]
    #[doc = "b31:24    Reserved \\n"]
    #[doc = "1 LSB = 360/2^6 = 5.625 degrees \\n"]
    #[doc = "This field defines the additional phase shift to be introduced on each \\n"]
    #[doc = "transmitter output. \\n"]
    #[doc = "In IWR6843 ES1.0, only 0 degree phase is supported. \\n"]
    pub txPhaseShifter: rlUInt32_t,
    #[doc = " @brief  ADC Sampling rate for each profile is encoded in \\n"]
    #[doc = "2 bytes (16 bit unsigned number) \\n"]
    #[doc = "1 LSB = 1 ksps \\n"]
    #[doc = "Valid range 2000 to 37500 \\n"]
    pub digOutSampleRate: rlUInt16_t,
    #[doc = " @brief  Code for HPF1 corner frequency \\n"]
    #[doc = "0x00 175 kHz \\n"]
    #[doc = "0x01 235 kHz \\n"]
    #[doc = "0x02 350 kHz \\n"]
    #[doc = "0x03 700 kHz \\n"]
    pub hpfCornerFreq1: rlUInt8_t,
    #[doc = " @brief  Code for HPF2 corner frequency \\n"]
    #[doc = "0x00 350 kHz \\n"]
    #[doc = "0x01 700 kHz \\n"]
    #[doc = "0x02 1.4 MHz \\n"]
    #[doc = "0x03 2.8 MHz \\n"]
    pub hpfCornerFreq2: rlUInt8_t,
    #[doc = " @brief  This field defines RX gain for continuous streaming mode."]
    #[doc = "Bit Definition"]
    #[doc = "[5:0] RX_GAIN"]
    #[doc = "This field defines RX gain for each profile. 1 LSB = 1 dB"]
    #[doc = "Valid values:"]
    #[doc = "For xWR1xxx : all even values from 24 to 52"]
    #[doc = "For xWR6x43 : all even values from 30 to 48"]
    #[doc = "[7:6] RF_GAIN_TARGET (Not applicable for IWR6843 ES1.0, In IWR6843 ES1.0 \\n"]
    #[doc = "RF gain is fixed to 36 dB) \\n"]
    #[doc = "For xWR1243/xWR1443/xWR1642/xWR1843:"]
    #[doc = "Value   RF gain target"]
    #[doc = "00     30 dB \\n"]
    #[doc = "01     34 dB \\n"]
    #[doc = "10     RESERVED \\n"]
    #[doc = "11     26 dB \\n"]
    #[doc = "For xWR6843 ES 2.0:"]
    #[doc = "Value   RF gain target"]
    #[doc = "00     30 dB \\n"]
    #[doc = "01     33 dB \\n"]
    #[doc = "10     36 dB \\n"]
    #[doc = "11     RESERVED \\n"]
    pub rxGain: rlUInt8_t,
    #[doc = " @brief Bit   Description"]
    #[doc = "b0  FORCE_VCO_SEL"]
    #[doc = "0 - Use internal VCO selection"]
    #[doc = "1 - Forced external VCO selection"]
    #[doc = "b1  VCO_SEL"]
    #[doc = "0 - VCO1 (77G:76 - 78 GHz or 60G:57 - 60.75 GHz)"]
    #[doc = "1 - VCO2 (77G:77 - 81 GHz or 60G:60 - 64 GHz)"]
    #[doc = "b7:2    RESERVED"]
    pub vcoSelect: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlContModeCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlContModeCfg>(),
        20usize,
        concat!("Size of: ", stringify!(rlContModeCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlContModeCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlContModeCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlContModeCfg>())).startFreqConst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlContModeCfg),
            "::",
            stringify!(startFreqConst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlContModeCfg>())).txOutPowerBackoffCode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlContModeCfg),
            "::",
            stringify!(txOutPowerBackoffCode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlContModeCfg>())).txPhaseShifter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlContModeCfg),
            "::",
            stringify!(txPhaseShifter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlContModeCfg>())).digOutSampleRate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlContModeCfg),
            "::",
            stringify!(digOutSampleRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlContModeCfg>())).hpfCornerFreq1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rlContModeCfg),
            "::",
            stringify!(hpfCornerFreq1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlContModeCfg>())).hpfCornerFreq2 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(rlContModeCfg),
            "::",
            stringify!(hpfCornerFreq2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlContModeCfg>())).rxGain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlContModeCfg),
            "::",
            stringify!(rxGain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlContModeCfg>())).vcoSelect as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(rlContModeCfg),
            "::",
            stringify!(vcoSelect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlContModeCfg>())).reserved as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rlContModeCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlContModeCfg_t = rlContModeCfg;
#[doc = " \\brief"]
#[doc = " Continous Mode Enable API parameters"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlContModeEn {
    #[doc = " @brief  Enable continuous steaming mode \\n"]
    #[doc = "0x00 Disable continuous streaming mode \\n"]
    #[doc = "0x01 Enable continuous streaming mode \\n"]
    pub contModeEn: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlContModeEn() {
    assert_eq!(
        ::core::mem::size_of::<rlContModeEn>(),
        4usize,
        concat!("Size of: ", stringify!(rlContModeEn))
    );
    assert_eq!(
        ::core::mem::align_of::<rlContModeEn>(),
        2usize,
        concat!("Alignment of ", stringify!(rlContModeEn))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlContModeEn>())).contModeEn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlContModeEn),
            "::",
            stringify!(contModeEn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlContModeEn>())).reserved as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlContModeEn),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlContModeEn_t = rlContModeEn;
#[doc = " \\brief"]
#[doc = " Frame Trigger API parameters RL_RF_FRAMESTARTSTOP_CONF_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlFrameTrigger {
    #[doc = " @brief  Start/Stop Frame \\n"]
    #[doc = "0x0000 - Stop the transmission of frames after the current frame is over at the"]
    #[doc = "frame boundary \\n"]
    #[doc = "0x0001 - Trigger a frame in software triggered mode. In hardware SYNC_IN \\n"]
    #[doc = "triggered mode, this command allows subsequent SYNC_IN trigger to \\n"]
    #[doc = "be honored \\n"]
    pub startStop: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlFrameTrigger() {
    assert_eq!(
        ::core::mem::size_of::<rlFrameTrigger>(),
        4usize,
        concat!("Size of: ", stringify!(rlFrameTrigger))
    );
    assert_eq!(
        ::core::mem::align_of::<rlFrameTrigger>(),
        2usize,
        concat!("Alignment of ", stringify!(rlFrameTrigger))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameTrigger>())).startStop as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameTrigger),
            "::",
            stringify!(startStop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlFrameTrigger>())).reserved as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlFrameTrigger),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlFrameTrigger_t = rlFrameTrigger;
#[doc = " \\brief"]
#[doc = " The Object position and signal strength parameter structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlTestSourceObject {
    #[doc = " @brief  Relative position in Cartesian coordinate from sensor to objects \\n"]
    #[doc = "X position of object 1lsb = 1cm, -32768cm to 32767cm \\n"]
    pub posX: rlInt16_t,
    #[doc = " @brief  Relative position in Cartesian coordinate from sensor to objects \\n"]
    #[doc = "Y position of object 1lsb = 1cm, 0 -32767 cm \\n"]
    pub posY: rlInt16_t,
    #[doc = " @brief  Relative position in Cartesian coordinate from sensor to objects \\n"]
    #[doc = "Z position of object 1lsb = 1cm, -32768cm to 32767cm \\n"]
    pub posZ: rlInt16_t,
    #[doc = " @brief  Relative velocity in Cartesian coordinate \\n"]
    #[doc = "X velocity of object 1lsb = 1 cm/s, Valid Range -5000 to +5000 \\n"]
    pub velX: rlInt16_t,
    #[doc = " @brief  Relative velocity in Cartesian coordinate \\n"]
    #[doc = "Y velocity of object 1lsb = 1cm/s, Valid Range -5000 to +5000 \\n"]
    pub velY: rlInt16_t,
    #[doc = " @brief  Relative velocity in Cartesian coordinate \\n"]
    #[doc = "Z velocity of object 1lsb = 1cm/s, Valid Range -5000 to +5000 \\n"]
    pub velZ: rlInt16_t,
    #[doc = " @brief  Reflecting obj' sig level at ADC o/p, relative to ADC Full Scale \\n"]
    #[doc = "1 LSB = -0.1 dBFS, Valid Range 0 to 950 \\n"]
    pub sigLvl: rlUInt16_t,
    #[doc = " @brief  Boundary min limit, Obj location resets to posX if cross boundary \\n"]
    #[doc = "X position of min boundary 1lsb = 1cm, -32768cm to 32767cm \\n"]
    pub posXMin: rlInt16_t,
    #[doc = " @brief  Boundary min limit, Obj location resets to posY if cross boundary \\n"]
    #[doc = "Y position of min boundary 1lsb = 1cm, 0 to 32767cm \\n"]
    pub posYMin: rlInt16_t,
    #[doc = " @brief  Boundary min limit, Obj location resets to posZ if cross boundary \\n"]
    #[doc = "Z position of min boundary 1lsb = 1cm, -32768cm to 32767cm \\n"]
    pub posZMin: rlInt16_t,
    #[doc = " @brief  Boundary max limit, Obj location resets to posX if cross boundary \\n"]
    #[doc = "X position of max boundary 1lsb = 1cm, -32768cm to 32767cm \\n"]
    pub posXMax: rlInt16_t,
    #[doc = " @brief  Boundary max limit, Obj location resets to posX if cross boundary \\n"]
    #[doc = "Y position of max boundary 1lsb = 1cm, 0 to 32767cm \\n"]
    pub posYMax: rlInt16_t,
    #[doc = " @brief  Boundary max limit, Obj location resets to posX if cross boundary \\n"]
    #[doc = "Z position of max boundary 1lsb = 1cm, -32768cm to 32767cm \\n"]
    pub posZMax: rlInt16_t,
}
#[test]
fn bindgen_test_layout_rlTestSourceObject() {
    assert_eq!(
        ::core::mem::size_of::<rlTestSourceObject>(),
        26usize,
        concat!("Size of: ", stringify!(rlTestSourceObject))
    );
    assert_eq!(
        ::core::mem::align_of::<rlTestSourceObject>(),
        2usize,
        concat!("Alignment of ", stringify!(rlTestSourceObject))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceObject>())).posX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceObject),
            "::",
            stringify!(posX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceObject>())).posY as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceObject),
            "::",
            stringify!(posY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceObject>())).posZ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceObject),
            "::",
            stringify!(posZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceObject>())).velX as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceObject),
            "::",
            stringify!(velX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceObject>())).velY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceObject),
            "::",
            stringify!(velY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceObject>())).velZ as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceObject),
            "::",
            stringify!(velZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceObject>())).sigLvl as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceObject),
            "::",
            stringify!(sigLvl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceObject>())).posXMin as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceObject),
            "::",
            stringify!(posXMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceObject>())).posYMin as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceObject),
            "::",
            stringify!(posYMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceObject>())).posZMin as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceObject),
            "::",
            stringify!(posZMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceObject>())).posXMax as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceObject),
            "::",
            stringify!(posXMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceObject>())).posYMax as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceObject),
            "::",
            stringify!(posYMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceObject>())).posZMax as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceObject),
            "::",
            stringify!(posZMax)
        )
    );
}
pub type rlTestSourceObject_t = rlTestSourceObject;
#[doc = " \\brief"]
#[doc = " The Antenna position parameter structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlTestSourceAntPos {
    #[doc = " @brief  Antenna position X 1lsb=wavelength/8 Valid range = +/-15 wave lengths"]
    pub antPosX: rlInt8_t,
    #[doc = " @brief  Antenna position Z 1lsb=wavelength/8 Valid range = +/-15 wave lengths"]
    pub antPosZ: rlInt8_t,
}
#[test]
fn bindgen_test_layout_rlTestSourceAntPos() {
    assert_eq!(
        ::core::mem::size_of::<rlTestSourceAntPos>(),
        2usize,
        concat!("Size of: ", stringify!(rlTestSourceAntPos))
    );
    assert_eq!(
        ::core::mem::align_of::<rlTestSourceAntPos>(),
        1usize,
        concat!("Alignment of ", stringify!(rlTestSourceAntPos))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceAntPos>())).antPosX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceAntPos),
            "::",
            stringify!(antPosX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceAntPos>())).antPosZ as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceAntPos),
            "::",
            stringify!(antPosZ)
        )
    );
}
pub type rlTestSourceAntPos_t = rlTestSourceAntPos;
#[doc = " \\brief"]
#[doc = " Test source config API parameters E_API_AR_TEST_SOURCE_CONF_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlTestSource {
    #[doc = " @brief  Arary of test Objects"]
    pub testObj: [rlTestSourceObject_t; 2usize],
    #[doc = " @brief  Simulated Position of Rx Antennas"]
    pub rxAntPos: [rlTestSourceAntPos_t; 4usize],
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlTestSource() {
    assert_eq!(
        ::core::mem::size_of::<rlTestSource>(),
        68usize,
        concat!("Size of: ", stringify!(rlTestSource))
    );
    assert_eq!(
        ::core::mem::align_of::<rlTestSource>(),
        4usize,
        concat!("Alignment of ", stringify!(rlTestSource))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSource>())).testObj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSource),
            "::",
            stringify!(testObj)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSource>())).rxAntPos as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSource),
            "::",
            stringify!(rxAntPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSource>())).reserved0 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSource),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSource>())).reserved1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSource),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlTestSource_t = rlTestSource;
#[doc = " \\brief"]
#[doc = " Test source Enable API parameters RL_RF_TEST_SOURCE_ENABLE_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlTestSourceEn {
    #[doc = " @brief  Test source Enable - 1, Disable - 0"]
    pub tsEnable: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlTestSourceEn() {
    assert_eq!(
        ::core::mem::size_of::<rlTestSourceEn>(),
        4usize,
        concat!("Size of: ", stringify!(rlTestSourceEn))
    );
    assert_eq!(
        ::core::mem::align_of::<rlTestSourceEn>(),
        2usize,
        concat!("Alignment of ", stringify!(rlTestSourceEn))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceEn>())).tsEnable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceEn),
            "::",
            stringify!(tsEnable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTestSourceEn>())).reserved as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTestSourceEn),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlTestSourceEnable_t = rlTestSourceEn;
#[doc = " \\brief"]
#[doc = " RF characterization Time and Temperature data structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfTempData {
    #[doc = " @brief  radarSS local Time from device powerup. 1 LSB = 1 ms"]
    pub time: rlUInt32_t,
    #[doc = " @brief  RX0 temperature sensor reading (signed value). 1 LSB = 1 deg C"]
    pub tmpRx0Sens: rlInt16_t,
    #[doc = " @brief  RX1 temperature sensor reading (signed value). 1 LSB = 1 deg C"]
    pub tmpRx1Sens: rlInt16_t,
    #[doc = " @brief  RX2 temperature sensor reading (signed value). 1 LSB = 1 deg C"]
    pub tmpRx2Sens: rlInt16_t,
    #[doc = " @brief  RX3 temperature sensor reading (signed value). 1 LSB = 1 deg C"]
    pub tmpRx3Sens: rlInt16_t,
    #[doc = " @brief  TX0 temperature sensor reading (signed value). 1 LSB = 1 deg C"]
    pub tmpTx0Sens: rlInt16_t,
    #[doc = " @brief  TX1 temperature sensor reading (signed value). 1 LSB = 1 deg C"]
    pub tmpTx1Sens: rlInt16_t,
    #[doc = " @brief  TX2 temperature sensor reading (signed value). 1 LSB = 1 deg C"]
    pub tmpTx2Sens: rlInt16_t,
    #[doc = " @brief  PM temperature sensor reading (signed value). 1 LSB = 1 deg C"]
    pub tmpPmSens: rlInt16_t,
    #[doc = " @brief  Digital temp sensor reading (signed value). 1 LSB = 1 deg C"]
    pub tmpDig0Sens: rlInt16_t,
    #[doc = " @brief  Second digital temp sensor reading (signed value).( applicable only in \\n"]
    #[doc = "         xWR1642/xWR6843/xWR1843.) \\n"]
    #[doc = "         1 LSB = 1 deg C \\n"]
    pub tmpDig1Sens: rlInt16_t,
}
#[test]
fn bindgen_test_layout_rlRfTempData() {
    assert_eq!(
        ::core::mem::size_of::<rlRfTempData>(),
        24usize,
        concat!("Size of: ", stringify!(rlRfTempData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfTempData>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRfTempData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfTempData>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTempData),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfTempData>())).tmpRx0Sens as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTempData),
            "::",
            stringify!(tmpRx0Sens)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfTempData>())).tmpRx1Sens as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTempData),
            "::",
            stringify!(tmpRx1Sens)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfTempData>())).tmpRx2Sens as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTempData),
            "::",
            stringify!(tmpRx2Sens)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfTempData>())).tmpRx3Sens as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTempData),
            "::",
            stringify!(tmpRx3Sens)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfTempData>())).tmpTx0Sens as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTempData),
            "::",
            stringify!(tmpTx0Sens)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfTempData>())).tmpTx1Sens as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTempData),
            "::",
            stringify!(tmpTx1Sens)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfTempData>())).tmpTx2Sens as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTempData),
            "::",
            stringify!(tmpTx2Sens)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfTempData>())).tmpPmSens as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTempData),
            "::",
            stringify!(tmpPmSens)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfTempData>())).tmpDig0Sens as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTempData),
            "::",
            stringify!(tmpDig0Sens)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfTempData>())).tmpDig1Sens as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTempData),
            "::",
            stringify!(tmpDig1Sens)
        )
    );
}
pub type rlRfTempData_t = rlRfTempData;
#[doc = " \\brief"]
#[doc = " The DFE Statistics for Rx Channel for particular profile"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDfeRxdStatReport {
    #[doc = " @brief  Average DC value in I chain for profile x, RX channel x"]
    pub iAvgDC: rlInt16_t,
    #[doc = " @brief  Average DC value in Q chain for profile x, RX channel x"]
    pub qAvgDC: rlInt16_t,
    #[doc = " @brief  Average power in I chain for profile x, RX channel x"]
    pub iAvgPwr: rlUInt16_t,
    #[doc = " @brief  Average power in Q chain for profile x, RX channel x"]
    pub qAvgPwr: rlUInt16_t,
    #[doc = " @brief  Average cross correlation between I and Q chains for profile x, RX channel x"]
    pub iqAvgCroCorrel: rlInt32_t,
}
#[test]
fn bindgen_test_layout_rlDfeRxdStatReport() {
    assert_eq!(
        ::core::mem::size_of::<rlDfeRxdStatReport>(),
        12usize,
        concat!("Size of: ", stringify!(rlDfeRxdStatReport))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDfeRxdStatReport>(),
        4usize,
        concat!("Alignment of ", stringify!(rlDfeRxdStatReport))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDfeRxdStatReport>())).iAvgDC as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDfeRxdStatReport),
            "::",
            stringify!(iAvgDC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDfeRxdStatReport>())).qAvgDC as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDfeRxdStatReport),
            "::",
            stringify!(qAvgDC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDfeRxdStatReport>())).iAvgPwr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDfeRxdStatReport),
            "::",
            stringify!(iAvgPwr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDfeRxdStatReport>())).qAvgPwr as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDfeRxdStatReport),
            "::",
            stringify!(qAvgPwr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDfeRxdStatReport>())).iqAvgCroCorrel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDfeRxdStatReport),
            "::",
            stringify!(iqAvgCroCorrel)
        )
    );
}
pub type rlDfeRxStatReport_t = rlDfeRxdStatReport;
#[doc = " \\brief"]
#[doc = " The DFE Statistics Report Contents"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDfeStatReport {
    #[doc = " @brief Contain DFE statistic report for all profile and receiver"]
    pub dfeStatRepo: [[rlDfeRxStatReport_t; 4usize]; 4usize],
}
#[test]
fn bindgen_test_layout_rlDfeStatReport() {
    assert_eq!(
        ::core::mem::size_of::<rlDfeStatReport>(),
        192usize,
        concat!("Size of: ", stringify!(rlDfeStatReport))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDfeStatReport>(),
        4usize,
        concat!("Alignment of ", stringify!(rlDfeStatReport))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDfeStatReport>())).dfeStatRepo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDfeStatReport),
            "::",
            stringify!(dfeStatRepo)
        )
    );
}
pub type rlDfeStatReport_t = rlDfeStatReport;
#[doc = " \\brief"]
#[doc = " Dynamic power saving API parameters"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDynPwrSave {
    #[doc = " @brief  Enable dynamic power saving during inter-chirp IDLE times by \\n"]
    #[doc = "          turning off various circuits e.g. TX, RX, LO. 3 LSB is vaild \\n"]
    #[doc = "          b0 Enable power save by switching off TX  during inter-chirp IDLE period \\n"]
    #[doc = "             0    Disable \\n"]
    #[doc = "             1    Enable \\n"]
    #[doc = "          b1 Enable power save by switching off RX  during inter-chirp IDLE period \\n"]
    #[doc = "             0    Disable \\n"]
    #[doc = "             1    Enable \\n"]
    #[doc = "          b2 Enable power save by switching off LO distribution  during inter-chirp IDLE\\n"]
    #[doc = "          period \\n"]
    #[doc = "             0    Disable \\n"]
    #[doc = "             1    Enable \\n"]
    pub blkCfg: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlDynPwrSave() {
    assert_eq!(
        ::core::mem::size_of::<rlDynPwrSave>(),
        4usize,
        concat!("Size of: ", stringify!(rlDynPwrSave))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDynPwrSave>(),
        2usize,
        concat!("Alignment of ", stringify!(rlDynPwrSave))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDynPwrSave>())).blkCfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDynPwrSave),
            "::",
            stringify!(blkCfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDynPwrSave>())).reserved as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDynPwrSave),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlDynPwrSave_t = rlDynPwrSave;
#[doc = " \\brief"]
#[doc = " API RF device Config SBC M_API_AR_RF_DEV_CONF_SBC"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfDevCfg {
    #[doc = " @brief Bit Definition \\n"]
    #[doc = "        b1:0 Global Async event direction \\n"]
    #[doc = "             00 - radarSS to MSS   01 - radarSS to HOST\\n"]
    #[doc = "             10 - radarSS to DSS   11 - RESERVED   \\n"]
    #[doc = "             The ASYNC_EVENT_DIR controls the direction for following ASYNC_EVENTS \\n"]
    #[doc = "             [1.] CPU_FAULT [2.] ESM_FAULT [3.] ANALOG_FAULT \\n"]
    #[doc = "             All other ASYNC_EVENTs are sent to the subsystem which issues the API \\n"]
    #[doc = "        b3:2 Monitoring Async Event direction"]
    #[doc = "             00 - radarSS to MSS   01 - radarSS to HOST\\n"]
    #[doc = "             10 - radarSS to DSS   11 - RESERVED   \\n"]
    #[doc = "        b31:4 Reserved"]
    pub aeDirection: rlUInt32_t,
    #[doc = " @brief Bit Definition \\n"]
    #[doc = "       b0: FRAME_START_ASYNC_EVENT_DIS        \\n"]
    #[doc = "           0 Frame Start async event enable   \\n"]
    #[doc = "           1 Frame Start async event disable  \\n"]
    #[doc = "       b1: FRAME_STOP_ASYNC_EVENT_DIS         \\n"]
    #[doc = "           0 Frame Stop async event enable    \\n"]
    #[doc = "           1 Frame Stop async event disable   \\n"]
    #[doc = "       b7:2 Reserved"]
    pub aeControl: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt8_t,
    #[doc = " @brief Bit Definition \\n"]
    #[doc = "       b0: Watchdog enable/disable        \\n"]
    #[doc = "           0 Keep watchdog disabled   \\n"]
    #[doc = "           1 Enable watch dog  \\n"]
    #[doc = "       b7:1: Reserved \\n"]
    #[doc = "       @note :The Windowed WDT can be enabled only in SW triggered framing Mode or in \\n"]
    #[doc = "              cascade mode where frames of all the devices synchronized with same clock \\n"]
    #[doc = "              source, if frames are triggered from Hw trigger pulse generated from \\n"]
    #[doc = "              unsynchronized clock then WDT can not be enabled. \\n"]
    pub bssDigCtrl: rlUInt8_t,
    #[doc = " @brief CRC Config for Asynchornous event message \\n"]
    #[doc = "          Value  Description \\n"]
    #[doc = "           0     16 bit CRC for radarSS async events \\n"]
    #[doc = "           1     32 bit CRC for radarSS async events \\n"]
    #[doc = "           2     64 bit CRC for radarSS async events \\n"]
    #[doc = ""]
    pub aeCrcConfig: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved3: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlRfDevCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlRfDevCfg>(),
        12usize,
        concat!("Size of: ", stringify!(rlRfDevCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfDevCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRfDevCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDevCfg>())).aeDirection as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDevCfg),
            "::",
            stringify!(aeDirection)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDevCfg>())).aeControl as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDevCfg),
            "::",
            stringify!(aeControl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDevCfg>())).reserved0 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDevCfg),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDevCfg>())).reserved1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDevCfg),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDevCfg>())).bssDigCtrl as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDevCfg),
            "::",
            stringify!(bssDigCtrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDevCfg>())).aeCrcConfig as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDevCfg),
            "::",
            stringify!(aeCrcConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDevCfg>())).reserved2 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDevCfg),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDevCfg>())).reserved3 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDevCfg),
            "::",
            stringify!(reserved3)
        )
    );
}
pub type rlRfDevCfg_t = rlRfDevCfg;
#[doc = " \\brief"]
#[doc = "  Num of samples to collect for API GPADC sensors"]
#[doc = "  sampleCnt    : Number of samples to collect @625KHz"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlGpAdcSamples {
    #[doc = " @brief  Number of samples to collect"]
    pub sampleCnt: rlUInt8_t,
    #[doc = " @brief  Number of samples to skip before collecting the data"]
    #[doc = "         1 LSB = 0.8 us, Valid range: 0 to 12 us"]
    pub settlingTime: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlGpAdcSamples() {
    assert_eq!(
        ::core::mem::size_of::<rlGpAdcSamples>(),
        2usize,
        concat!("Size of: ", stringify!(rlGpAdcSamples))
    );
    assert_eq!(
        ::core::mem::align_of::<rlGpAdcSamples>(),
        1usize,
        concat!("Alignment of ", stringify!(rlGpAdcSamples))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlGpAdcSamples>())).sampleCnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlGpAdcSamples),
            "::",
            stringify!(sampleCnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlGpAdcSamples>())).settlingTime as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlGpAdcSamples),
            "::",
            stringify!(settlingTime)
        )
    );
}
pub type rlGpAdcSamples_t = rlGpAdcSamples;
#[doc = " \\brief"]
#[doc = " API radarSS GPADC API MEAS SET SBC M_API_AR_RF_GPADC_API_SET_SB"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlGpAdcCfg {
    #[doc = " @brief  Enable different sensors \\n"]
    #[doc = "[b0] 1: ANATEST1 Enable,  0: ANATEST1 Disable \\n"]
    #[doc = "[b1] 1: ANATEST2 Enable,  0: ANATEST2 Disable \\n"]
    #[doc = "[b2] 1: ANATEST3 Enable,  0: ANATEST3 Disable \\n"]
    #[doc = "[b3] 1: ANATEST4 Enable,  0: ANATEST4 Disable \\n"]
    #[doc = "[b4] 1: ANAMUX   Enable,  0: ANAMUX   Disable \\n"]
    #[doc = "[b5] 1: VSENSE   Enable,  0: VSENSE   Disable \\n"]
    #[doc = "[b7:6]   Reserved \\n"]
    pub enable: rlUInt8_t,
    #[doc = " @brief  Enable buffer for each input \\n"]
    #[doc = "[b0] 1: ANATEST1 buffer enable,  0: ANATEST1 buffer disable \\n"]
    #[doc = "[b1] 1: ANATEST2 buffer enable,  0: ANATEST2 buffer disable \\n"]
    #[doc = "[b2] 1: ANATEST3 buffer enable,  0: ANATEST3 buffer disable \\n"]
    #[doc = "[b3] 1: ANATEST4 buffer enable,  0: ANATEST4 buffer disable \\n"]
    #[doc = "[b4] 1: ANAMUX   buffer enable,  0: ANAMUX   buffer disable \\n"]
    #[doc = "[b7:5]   Reserved \\n"]
    pub bufferEnable: rlUInt8_t,
    #[doc = " @brief  Configure number of sample to be \\n"]
    #[doc = "collected for each sensor This array of numOfSamples is for the sensors \\n"]
    #[doc = "which are enabled in above parameter 'enable' \\n"]
    pub numOfSamples: [rlGpAdcSamples_t; 6usize],
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: [rlUInt32_t; 3usize],
}
#[test]
fn bindgen_test_layout_rlGpAdcCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlGpAdcCfg>(),
        28usize,
        concat!("Size of: ", stringify!(rlGpAdcCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlGpAdcCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlGpAdcCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlGpAdcCfg>())).enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlGpAdcCfg),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlGpAdcCfg>())).bufferEnable as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlGpAdcCfg),
            "::",
            stringify!(bufferEnable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlGpAdcCfg>())).numOfSamples as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlGpAdcCfg),
            "::",
            stringify!(numOfSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlGpAdcCfg>())).reserved0 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rlGpAdcCfg),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlGpAdcCfg>())).reserved1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlGpAdcCfg),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlGpAdcCfg_t = rlGpAdcCfg;
#[doc = " \\brief"]
#[doc = " Radar RF LDO bypass enable/disable configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfLdoBypassCfg {
    #[doc = " @brief  Enable LDO bypass \\n"]
    #[doc = "[b0] 1: RF LDO bypassed, Should be used only when 1.0V RF supply is provided"]
    #[doc = "0: RF LDO not bypassed(default), Should be used only when 1.3V RF supply"]
    #[doc = "is provided \\n"]
    #[doc = "[b1] 0: PA LDO input is enabled\\n"]
    #[doc = "1: PA LDO input is disabled (3 TX use case)."]
    #[doc = "(To be used only when VIN_RF2 is shorted to VOUT_PA on board and VIN_RF2 is"]
    #[doc = "1.0V) \\n"]
    #[doc = "[b15:2] Reserved \\n"]
    #[doc = "usecase                                            LDO bypass    PA LDO disable \\n"]
    #[doc = "1.3V RF supply 1 and 1.3V RF supply 2                 0               0"]
    #[doc = "1.0V RF supply 1 and 1.0V RF supply 2                 1               0"]
    #[doc = "1.0V RF supply 1 and 1.0V RF supply 2                 1               1"]
    #[doc = "and RF supply 1 shorted to Vout PA"]
    #[doc = ""]
    pub ldoBypassEnable: rlUInt16_t,
    #[doc = " @brief  IR drop is the voltage drop from the PMIC output to the device pin. The user"]
    #[doc = "should program the voltage drop in percentage units which will be used for"]
    #[doc = "measuring the external supplies.  \\n"]
    #[doc = "Value  Description   \\n"]
    #[doc = "0      IR drop of 0% \\n"]
    #[doc = "1      IR drop of 3% \\n"]
    #[doc = "2      IR drop of 6% \\n"]
    #[doc = "3      IR drop of 9% \\n"]
    pub supplyMonIrDrop: rlUInt8_t,
    #[doc = " @brief  IO supply indicator. This is used to indicate the IO supply to the MMIC device"]
    #[doc = "         for setting the correct voltage monitor thresholds"]
    #[doc = "         Value   Description \\n"]
    #[doc = "          0      3.3 V IO supply \\n"]
    #[doc = "          1      1.8 V IO supply \\n"]
    pub ioSupplyIndicator: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlRfLdoBypassCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlRfLdoBypassCfg>(),
        4usize,
        concat!("Size of: ", stringify!(rlRfLdoBypassCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfLdoBypassCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlRfLdoBypassCfg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfLdoBypassCfg>())).ldoBypassEnable as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfLdoBypassCfg),
            "::",
            stringify!(ldoBypassEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfLdoBypassCfg>())).supplyMonIrDrop as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfLdoBypassCfg),
            "::",
            stringify!(supplyMonIrDrop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfLdoBypassCfg>())).ioSupplyIndicator as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfLdoBypassCfg),
            "::",
            stringify!(ioSupplyIndicator)
        )
    );
}
pub type rlRfLdoBypassCfg_t = rlRfLdoBypassCfg;
#[doc = " \\brief"]
#[doc = " Radar RF Phase Shift enable/disable configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfPhaseShiftCfg {
    #[doc = " @brief  Chirp Start Index, Valid Range 0 -511"]
    pub chirpStartIdx: rlUInt16_t,
    #[doc = " @brief  Chirp End Index, Valid Range from chirpStartIdx to 511"]
    pub chirpEndIdx: rlUInt16_t,
    #[doc = " @brief  TX0 phase shift definition \\n"]
    #[doc = "[b1:0] reserved (set it to 0b00) \\n"]
    #[doc = "[b7:2] TX0 phase shift value \\n"]
    #[doc = "1 LSB = 360/2^6 = 5.625 degrees\\n"]
    #[doc = "Valid range: 0 to 63 \\n"]
    pub tx0PhaseShift: rlUInt8_t,
    #[doc = " @brief  TX1 phase shift definition \\n"]
    #[doc = "[b1:0] reserved (set it to 0b00) \\n"]
    #[doc = "[b7:2] TX1 phase shift value \\n"]
    #[doc = "1 LSB = 360/2^6 = 5.625 degrees\\n"]
    #[doc = "Valid range: 0 to 63 \\n"]
    pub tx1PhaseShift: rlUInt8_t,
    #[doc = " @brief  TX2 phase shift definition \\n"]
    #[doc = "[b1:0] reserved (set it to 0b00) \\n"]
    #[doc = "[b7:2] TX2 phase shift value \\n"]
    #[doc = "1 LSB = 360/2^6 = 5.625 degrees\\n"]
    #[doc = "Valid range: 0 to 63 \\n"]
    pub tx2PhaseShift: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlRfPhaseShiftCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlRfPhaseShiftCfg>(),
        8usize,
        concat!("Size of: ", stringify!(rlRfPhaseShiftCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfPhaseShiftCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlRfPhaseShiftCfg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfPhaseShiftCfg>())).chirpStartIdx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPhaseShiftCfg),
            "::",
            stringify!(chirpStartIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfPhaseShiftCfg>())).chirpEndIdx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPhaseShiftCfg),
            "::",
            stringify!(chirpEndIdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfPhaseShiftCfg>())).tx0PhaseShift as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPhaseShiftCfg),
            "::",
            stringify!(tx0PhaseShift)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfPhaseShiftCfg>())).tx1PhaseShift as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPhaseShiftCfg),
            "::",
            stringify!(tx1PhaseShift)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfPhaseShiftCfg>())).tx2PhaseShift as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPhaseShiftCfg),
            "::",
            stringify!(tx2PhaseShift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfPhaseShiftCfg>())).reserved as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPhaseShiftCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlRfPhaseShiftCfg_t = rlRfPhaseShiftCfg;
#[doc = " \\brief"]
#[doc = " Radar RF PA loopback configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfPALoopbackCfg {
    #[doc = " @brief  value is a 100MHz divider which sets the loopback frequency \\n"]
    #[doc = "For e.g. for a 1 MHz frequency, set this to 10 \\n"]
    #[doc = "For a 2 MHz frequency, set this to 50 \\n"]
    #[doc = "@note : To ensure no leakage of signal power, user has to ensure that \\n"]
    #[doc = "100MHz/LOOPBACK_FREQ is an integer multiple of bin width For e.g. if user \\n"]
    #[doc = "choses 25Msps sampling rate and 2048 samples/chirp, then \\n"]
    #[doc = "LOOPBACK_FREQ of 64 (=1.5625MHz) will ensure no leakage \\n"]
    pub paLoopbackFreq: rlUInt16_t,
    #[doc = " @brief  Enable/Disable PA loopback \\n"]
    #[doc = "1: PA loopback Enable,  0: PA loopback Disable \\n"]
    pub paLoopbackEn: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlRfPALoopbackCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlRfPALoopbackCfg>(),
        4usize,
        concat!("Size of: ", stringify!(rlRfPALoopbackCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfPALoopbackCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlRfPALoopbackCfg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfPALoopbackCfg>())).paLoopbackFreq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPALoopbackCfg),
            "::",
            stringify!(paLoopbackFreq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfPALoopbackCfg>())).paLoopbackEn as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPALoopbackCfg),
            "::",
            stringify!(paLoopbackEn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfPALoopbackCfg>())).reserved as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPALoopbackCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlRfPALoopbackCfg_t = rlRfPALoopbackCfg;
#[doc = " \\brief"]
#[doc = " Radar RF Phase shift loopback configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfPSLoopbackCfg {
    #[doc = " @brief  Loop back frequency in kHz, 1 LSB = 1kHz"]
    pub psLoopbackFreq: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  Enable/Disable PA loopback \\n"]
    #[doc = "1: PS loopback Enable,  0: PS loopback Disable \\n"]
    pub psLoopbackEn: rlUInt8_t,
    #[doc = " @brief  Tx used for loopback \\n"]
    #[doc = "          [b0] 1: Tx0 is used for loopback \\n"]
    #[doc = "          [b1] 1: Tx1 is used for loopback \\n"]
    #[doc = "          [b7:2] : reserved \\n"]
    pub psLoopbackTxId: rlUInt8_t,
    #[doc = " @brief  PGA gain value \\n"]
    #[doc = "           0 : PGA is OFF  \\n"]
    #[doc = "           1 : -22 dB      \\n"]
    #[doc = "           2 : -16 dB      \\n"]
    #[doc = "           3 : -15 dB      \\n"]
    #[doc = "           4 : -14 dB      \\n"]
    #[doc = "           5 : -13 dB       \\n"]
    #[doc = "           6 : -12 dB       \\n"]
    #[doc = "           7 : -11 dB       \\n"]
    #[doc = "           8 : -10 dB       \\n"]
    #[doc = "           9 : -9 dB       \\n"]
    #[doc = "           10: -8 dB       \\n"]
    #[doc = "           11: -7 dB       \\n"]
    #[doc = "           12: -6 dB       \\n"]
    #[doc = "           13: -5 dB       \\n"]
    #[doc = "           14: -4 dB       \\n"]
    #[doc = "           15: -3 dB       \\n"]
    #[doc = "           16: -2 dB       \\n"]
    #[doc = "           17: -1 dB       \\n"]
    #[doc = "           18:  0 dB       \\n"]
    #[doc = "           19:  1 dB       \\n"]
    #[doc = "           20:  2 dB       \\n"]
    #[doc = "           21:  3 dB       \\n"]
    #[doc = "           22:  4 dB       \\n"]
    #[doc = "           23:  5 dB       \\n"]
    #[doc = "           24:  6 dB       \\n"]
    #[doc = "           25:  7 dB       \\n"]
    #[doc = "           26:  8 dB       \\n"]
    #[doc = "           27:  9 dB       \\n"]
    #[doc = "           255-28:RESERVED \\n"]
    pub pgaGainIndex: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlRfPSLoopbackCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlRfPSLoopbackCfg>(),
        8usize,
        concat!("Size of: ", stringify!(rlRfPSLoopbackCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfPSLoopbackCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlRfPSLoopbackCfg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfPSLoopbackCfg>())).psLoopbackFreq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPSLoopbackCfg),
            "::",
            stringify!(psLoopbackFreq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfPSLoopbackCfg>())).reserved0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPSLoopbackCfg),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfPSLoopbackCfg>())).psLoopbackEn as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPSLoopbackCfg),
            "::",
            stringify!(psLoopbackEn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfPSLoopbackCfg>())).psLoopbackTxId as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPSLoopbackCfg),
            "::",
            stringify!(psLoopbackTxId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfPSLoopbackCfg>())).pgaGainIndex as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPSLoopbackCfg),
            "::",
            stringify!(pgaGainIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfPSLoopbackCfg>())).reserved1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfPSLoopbackCfg),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlRfPSLoopbackCfg_t = rlRfPSLoopbackCfg;
#[doc = " \\brief"]
#[doc = " Radar RF IF loopback configuration."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfIFLoopbackCfg {
    #[doc = " @brief  IF loopback frequency value \\n"]
    #[doc = "           0: 180 kHz    \\n"]
    #[doc = "           1 : 240 kHz   \\n"]
    #[doc = "           2 : 360 kiHz  \\n"]
    #[doc = "           3 : 720 kHz   \\n"]
    #[doc = "           4 : 1 MHz     \\n"]
    #[doc = "           5 : 2 MHz     \\n"]
    #[doc = "           6 : 2.5 MHz   \\n"]
    #[doc = "           7 : 3 MHz     \\n"]
    #[doc = "           8 : 4.017857 MHz \\n"]
    #[doc = "           9 : 5 MHz     \\n"]
    #[doc = "           10 : 6 MHz     \\n"]
    #[doc = "           11: 8.035714 MHz  \\n"]
    #[doc = "           12: 9 MHz     \\n"]
    #[doc = "           13: 10 MHz    \\n"]
    #[doc = "           65535-14:RESERVED \\n"]
    pub ifLoopbackFreq: rlUInt16_t,
    #[doc = " @brief  Enable/Disable IF loopback \\n"]
    #[doc = "          [b7:0] 1: IF loopback Enable,  0: IF loopback Disable \\n"]
    pub ifLoopbackEn: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlRfIFLoopbackCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlRfIFLoopbackCfg>(),
        4usize,
        concat!("Size of: ", stringify!(rlRfIFLoopbackCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfIFLoopbackCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlRfIFLoopbackCfg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfIFLoopbackCfg>())).ifLoopbackFreq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfIFLoopbackCfg),
            "::",
            stringify!(ifLoopbackFreq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfIFLoopbackCfg>())).ifLoopbackEn as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfIFLoopbackCfg),
            "::",
            stringify!(ifLoopbackEn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfIFLoopbackCfg>())).reserved as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfIFLoopbackCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlRfIFLoopbackCfg_t = rlRfIFLoopbackCfg;
#[doc = " \\brief"]
#[doc = " Array of coefficients for the RF programmable filter"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rlRfProgFiltCoeff {
    #[doc = " @brief  The array of coefficients for the programmable filter, across all profiles, to"]
    #[doc = "be stored in the coefficient RAM. Each tap is a 16-bit signed number. The"]
    #[doc = "exact set of taps to be used for a given profile can be specified through"]
    #[doc = "rlRfProgFiltConf. \\n"]
    #[doc = "For each profile Maximum of 26 taps can be configured. If multiple profiles"]
    #[doc = "are used, all the filter taps across profiles are to be provided in one shot. \\n"]
    #[doc = "There is a HW constraint that each profile's filter taps should start at"]
    #[doc = "an even address. \\n"]
    #[doc = ""]
    #[doc = "For e.g If b[i,j] is filter coefficient For Profile i(0,1,2,3) and tap j(0...25),"]
    #[doc = "if numProfile = 4 and below is configured in rlRfProgFiltConf \\n"]
    #[doc = "rlRfProgFiltConf[profileId = 0]. progFiltLen = 26 \\n"]
    #[doc = "rlRfProgFiltConf[profileId = 1]. progFiltLen = 26, \\n"]
    #[doc = "rlRfProgFiltConf[profileId = 2]. progFiltLen = 26, \\n"]
    #[doc = "rlRfProgFiltConf[profileId = 3]. progFiltLen = 26, \\n"]
    #[doc = ""]
    #[doc = "rlRfProgFiltConf[profileId = 0]. coeffStartIdx = 0 \\n"]
    #[doc = "rlRfProgFiltConf[profileId = 1]. coeffStartIdx = 26 \\n"]
    #[doc = "rlRfProgFiltConf[profileId = 2]. coeffStartIdx = 52 \\n"]
    #[doc = "rlRfProgFiltConf[profileId = 3]. coeffStartIdx = 78 \\n"]
    #[doc = "one need to define this array as following:\\n"]
    #[doc = "coeffArray[0:103] = b[0,0], b[0,1]....b[0,25],b[1,0],b[1,1]...."]
    #[doc = "b[1,25],b[2,0],b[2,1]....b[2,25],b[3,0],b[3,1]....b[3,25]\\n"]
    #[doc = ""]
    #[doc = "if numProfile = 1 and below is configured in rlRfProgFiltConf \\n"]
    #[doc = "rlRfProgFiltConf[profileId = 0]. coeffStartIdx = 0 \\n"]
    #[doc = "rlRfProgFiltConf[profileId = 0]. progFiltLen = 10, \\n"]
    #[doc = "then one need to define this array as following: \\n"]
    #[doc = "coeffArray[0:103] = b[0,0], b[0,1]....b[0,9],0,0,0,.....0 \\n"]
    #[doc = ""]
    #[doc = "if numProfile = 2 and below is configured in rlRfProgFiltConf \\n"]
    #[doc = "rlRfProgFiltConf[profileId = 0]. progFiltLen = 10, \\n"]
    #[doc = "rlRfProgFiltConf[profileId = 1]. progFiltLen = 20, \\n"]
    #[doc = "rlRfProgFiltConf[profileId = 1]. coeffStartIdx = 10 \\n"]
    #[doc = "then one need to define this array as following: \\n"]
    #[doc = "coeffArray[0:103] = b[0,0], b[0,1]....b[0,9], b[1,0],b[1,1]....b[1,29],0,0,0...0 \\n"]
    #[doc = "@note : All the filter taps across profiles are to be provided in one shot. \\n"]
    #[doc = "There is a HW constraint that each profile’s filter taps should start \\n"]
    #[doc = "at four 32-bit word aligned address (i.e., the coefficients corresp- \\n"]
    #[doc = "onding to any profile should start at array index which is a multiple \\n"]
    #[doc = "of 8). \\n"]
    pub coeffArray: [rlInt16_t; 104usize],
}
#[test]
fn bindgen_test_layout_rlRfProgFiltCoeff() {
    assert_eq!(
        ::core::mem::size_of::<rlRfProgFiltCoeff>(),
        208usize,
        concat!("Size of: ", stringify!(rlRfProgFiltCoeff))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfProgFiltCoeff>(),
        2usize,
        concat!("Alignment of ", stringify!(rlRfProgFiltCoeff))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfProgFiltCoeff>())).coeffArray as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfProgFiltCoeff),
            "::",
            stringify!(coeffArray)
        )
    );
}
impl Default for rlRfProgFiltCoeff {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlRfProgFiltCoeff_t = rlRfProgFiltCoeff;
#[doc = " \\brief"]
#[doc = " Radar RF programmable filter configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfProgFiltConf {
    #[doc = " @brief  Profile Index for which this configuration applies."]
    pub profileId: rlUInt8_t,
    #[doc = " @brief  The index of the first coefficient of the programmable filter taps corresponding"]
    #[doc = "to this profile in the coefficient RAM programmed using rlRfProgFiltCoeff"]
    #[doc = "@note 1: This has to be an even number. For odd-length filters, a 0 (zero) tap"]
    #[doc = "needs to be appended at the end to make the length even. This is a HW"]
    #[doc = "constraint."]
    #[doc = "@note 2: The profile’s filter tap start index shall be 8 tap aligned (four 32-bit"]
    #[doc = "word aligned address)."]
    pub coeffStartIdx: rlUInt8_t,
    #[doc = " @brief  The length (number of taps) of the filter corresponding  to this profile. Together"]
    #[doc = "with the previous field, this determines the set of coefficients picked up from the"]
    #[doc = "coefficient RAM to form the filter taps for this profile."]
    #[doc = "@note :  This has to be an even number. For odd-length filters, a 0 (zero) tap"]
    #[doc = "needs to be appended at the end to make the length even. This is a HW"]
    #[doc = "constraint."]
    pub progFiltLen: rlUInt8_t,
    #[doc = " @brief  Determines the magnitude of the frequency shift do be done before filtering using"]
    #[doc = "the real-coefficient programmable filter."]
    #[doc = "1 LSB = 0.01*Fs shift, where Fs is the output sampling rate,"]
    #[doc = "specified as rlProfileCfg_t.digOutSampleRate"]
    #[doc = "@note : Applicable only on the Complex output mode"]
    pub progFiltFreqShift: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlRfProgFiltConf() {
    assert_eq!(
        ::core::mem::size_of::<rlRfProgFiltConf>(),
        4usize,
        concat!("Size of: ", stringify!(rlRfProgFiltConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfProgFiltConf>(),
        1usize,
        concat!("Alignment of ", stringify!(rlRfProgFiltConf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfProgFiltConf>())).profileId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfProgFiltConf),
            "::",
            stringify!(profileId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfProgFiltConf>())).coeffStartIdx as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfProgFiltConf),
            "::",
            stringify!(coeffStartIdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfProgFiltConf>())).progFiltLen as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfProgFiltConf),
            "::",
            stringify!(progFiltLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfProgFiltConf>())).progFiltFreqShift as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfProgFiltConf),
            "::",
            stringify!(progFiltFreqShift)
        )
    );
}
pub type rlRfProgFiltConf_t = rlRfProgFiltConf;
#[doc = " \\brief"]
#[doc = " Radar RF Miscconfiguration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfMiscConf {
    #[doc = " @brief  b0 PERCHIRP_PHASESHIFTER_EN \\n"]
    #[doc = "          0 Per chirp phase shifter is disabled \\n"]
    #[doc = "          1 Per chirp phase shifter is enabled \\n"]
    #[doc = "          This control is applicable only in devices which support phase shifter. \\n"]
    #[doc = "          For other devices, this is a RESERVED bit and should be set to 0."]
    pub miscCtl: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRfMiscConf() {
    assert_eq!(
        ::core::mem::size_of::<rlRfMiscConf>(),
        8usize,
        concat!("Size of: ", stringify!(rlRfMiscConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfMiscConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRfMiscConf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfMiscConf>())).miscCtl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfMiscConf),
            "::",
            stringify!(miscCtl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfMiscConf>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfMiscConf),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlRfMiscConf_t = rlRfMiscConf;
#[doc = " \\brief"]
#[doc = " Radar RF Calibration monitoring time unit configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfCalMonTimeUntConf {
    #[doc = " @brief  Defines the basic time unit, in terms of which calibration and/or monitoring \\n"]
    #[doc = "periodicities are to be defined. \\n"]
    #[doc = "If any monitoring functions are desired and enabled, the monitoring infrastructure"]
    #[doc = "automatically inherits this time unit as the period over which the various monitors"]
    #[doc = "are cyclically executed; so this should be set to the desired FTTI. \\n"]
    #[doc = "For calibrations, a separate rlRunTimeCalibConf.calibPeriodicity can be specified,"]
    #[doc = "as a multiple of this time unit, in rlRfRunTimeCalibConfig. \\n"]
    #[doc = "1 LSB = Duration of one frame. \\n"]
    #[doc = "@note : Even though calibrations many not be desired every time unit, every time unit shall"]
    #[doc = "be made long enough to include active chirping time, time required for all enabled"]
    #[doc = "calibrations and monitoring functions."]
    #[doc = "Default value in device: 100 \\n"]
    #[doc = "Valid range : 40ms to 250ms (Derive actual count value from programmed frame \\n"]
    #[doc = "period) \\n"]
    pub calibMonTimeUnit: rlUInt16_t,
    #[doc = " @brief  Defines the number of cascaded devices. For non-cascade systems (single-chip),"]
    #[doc = "         use the default value of 1"]
    pub numOfCascadeDev: rlUInt8_t,
    #[doc = " @brief  Applicable only only in cascaded mode, default value = 0"]
    pub devId: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRfCalMonTimeUntConf() {
    assert_eq!(
        ::core::mem::size_of::<rlRfCalMonTimeUntConf>(),
        8usize,
        concat!("Size of: ", stringify!(rlRfCalMonTimeUntConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfCalMonTimeUntConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRfCalMonTimeUntConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfCalMonTimeUntConf>())).calibMonTimeUnit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfCalMonTimeUntConf),
            "::",
            stringify!(calibMonTimeUnit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfCalMonTimeUntConf>())).numOfCascadeDev as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfCalMonTimeUntConf),
            "::",
            stringify!(numOfCascadeDev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfCalMonTimeUntConf>())).devId as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfCalMonTimeUntConf),
            "::",
            stringify!(devId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfCalMonTimeUntConf>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfCalMonTimeUntConf),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlRfCalMonTimeUntConf_t = rlRfCalMonTimeUntConf;
#[doc = " \\brief"]
#[doc = " Radar RF Calibration monitoring Frequency Limit configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfCalMonFreqLimitConf {
    #[doc = " @brief  The sensor's lower frequency limit for calibrations and monitoring is encoded \\n"]
    #[doc = "          in 2 bytes (16 bit unsigned number) \\n"]
    #[doc = "          1 LSB = 100 MHz \\n"]
    #[doc = "          For 77GHz devices(76GHz to 81GHz) \\n"]
    #[doc = "              Valid range: 760 to 810"]
    #[doc = "              Default value : 760 (If API is not issued)"]
    #[doc = "          For 60GHz devices(57GHz to 64GHz) \\n"]
    #[doc = "              Valid range: 570 to 640"]
    #[doc = "              Default value : 570 (If API is not issued)"]
    pub freqLimitLow: rlUInt16_t,
    #[doc = " @brief  The sensor's higher frequency limit for calibrations and monitoring is encoded \\n"]
    #[doc = "          in 2 bytes (16 bit unsigned number) \\n"]
    #[doc = "          1 LSB = 100 MHz \\n"]
    #[doc = "          For 77GHz devices(76GHz to 81GHz) \\n"]
    #[doc = "              Valid range: 760 to 810"]
    #[doc = "              Default value : 810 (If API is not issued)"]
    #[doc = "          For 60GHz devices(57GHz to 64GHz) \\n"]
    #[doc = "              Valid range: 570 to 640"]
    #[doc = "              Default value : 640 (If API is not issued)"]
    #[doc = "          @note : FREQ_LIMIT_HIGH should be strictly greater than FREQ_LIMIT_LOW \\n"]
    pub freqLimitHigh: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRfCalMonFreqLimitConf() {
    assert_eq!(
        ::core::mem::size_of::<rlRfCalMonFreqLimitConf>(),
        12usize,
        concat!("Size of: ", stringify!(rlRfCalMonFreqLimitConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfCalMonFreqLimitConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRfCalMonFreqLimitConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfCalMonFreqLimitConf>())).freqLimitLow as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfCalMonFreqLimitConf),
            "::",
            stringify!(freqLimitLow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfCalMonFreqLimitConf>())).freqLimitHigh as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfCalMonFreqLimitConf),
            "::",
            stringify!(freqLimitHigh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfCalMonFreqLimitConf>())).reserved0 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfCalMonFreqLimitConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfCalMonFreqLimitConf>())).reserved1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfCalMonFreqLimitConf),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlRfCalMonFreqLimitConf_t = rlRfCalMonFreqLimitConf;
#[doc = " \\brief"]
#[doc = " Radar RF Init Calibration configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfInitCalConf {
    #[doc = " @brief  Allowed values = 0x000 or 0xFFF Normally, upon receiving RF INIT message, the \\n"]
    #[doc = "         radarSS performs all relevant initial calibrations. This step can be disabled \\n"]
    #[doc = "         by the host by setting this field to 0x00. If disabled, the host needs to send \\n"]
    #[doc = "         the INJECT CALIB DATA message so that the radarSS can operate using the \\n"]
    #[doc = "         calibration data thus injected. Each of these calibrations can be selectively \\n"]
    #[doc = "         disabled by issuing this message before RF INIT message. \\n"]
    #[doc = ""]
    #[doc = "         Bit Calibration \\n"]
    #[doc = "         0   [Reserved] \\n"]
    #[doc = "         1   [Reserved] \\n"]
    #[doc = "         2   [Reserved] \\n"]
    #[doc = "         3   [Reserved] \\n"]
    #[doc = "         4   Enable LODIST calibration \\n"]
    #[doc = "         5   Enable RX ADC DC offset calibration \\n"]
    #[doc = "         6   Enable HPF cutoff calibration \\n"]
    #[doc = "         7   Enable LPF cutoff calibration \\n"]
    #[doc = "         8   Enable Peak detector calibration \\n"]
    #[doc = "         9   Enable TX Power calibration \\n"]
    #[doc = "         10  Enable RX gain calibration \\n"]
    #[doc = "         11  Enable TX phase calibration (Device dependent feature, please refer data"]
    #[doc = "             sheet) \\n"]
    #[doc = "         12  Enable RX IQMM calibration \\n"]
    #[doc = "         31:13   [Reserved] \\n"]
    #[doc = "         @note : If calibrations are disabled then it is mandatory to restore the same. \\n"]
    pub calibEnMask: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved3: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRfInitCalConf() {
    assert_eq!(
        ::core::mem::size_of::<rlRfInitCalConf>(),
        12usize,
        concat!("Size of: ", stringify!(rlRfInitCalConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfInitCalConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRfInitCalConf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfInitCalConf>())).calibEnMask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfInitCalConf),
            "::",
            stringify!(calibEnMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfInitCalConf>())).reserved0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfInitCalConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfInitCalConf>())).reserved1 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfInitCalConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfInitCalConf>())).reserved2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfInitCalConf),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfInitCalConf>())).reserved3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfInitCalConf),
            "::",
            stringify!(reserved3)
        )
    );
}
pub type rlRfInitCalConf_t = rlRfInitCalConf;
#[doc = " \\brief"]
#[doc = " Radar RF Run time calibration configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRunTimeCalibConf {
    #[doc = " @brief   Upon receiving this trigger message, one time calibration of various RF/analog \\n"]
    #[doc = "          aspects are triggered if the corresponding bits in this field are set to 1. The \\n"]
    #[doc = "          response is in the form of an asynchronous event sent to the host. The \\n"]
    #[doc = "          calibrations, if enabled, are performed after the completion of any ongoing \\n"]
    #[doc = "          calibration cycle, and the calibration results take event from the frame that \\n"]
    #[doc = "          begins after the asynchronous event response is sent from the BSS. \\n"]
    #[doc = "          APLL and SYNTH calibrations are done always internally irrespective of bits are \\n"]
    #[doc = "          enabled or not, the time required for these calibrations must be allocated. \\n"]
    #[doc = "          Bit: Calibration \\n"]
    #[doc = "            0:[Reserved]  \\n"]
    #[doc = "            1:[Reserved]  \\n"]
    #[doc = "            2:[Reserved]  \\n"]
    #[doc = "            3:[Reserved]  \\n"]
    #[doc = "            4: Enable LODIST calibration  \\n"]
    #[doc = "            5: [Reserved]  \\n"]
    #[doc = "            6: [Reserved]  \\n"]
    #[doc = "            7: [Reserved]  \\n"]
    #[doc = "            8: Enable PD_CALIBRATION_EN \\n"]
    #[doc = "            9: Enable TX Power calibration \\n"]
    #[doc = "            10:Enable RX gain calibration  \\n"]
    #[doc = "            11:[Reserved]  \\n"]
    #[doc = "            12:[Reserved]  \\n"]
    #[doc = "            31:13:[Reserved] \\n"]
    #[doc = "          NOTE: In IWR6843 ES 1.0, only internal calibrations (APLL & SYNTH) and LODIST \\n"]
    #[doc = "                 calibrations are supported. \\n"]
    pub oneTimeCalibEnMask: rlUInt32_t,
    #[doc = " @brief  Automatic periodic triggering of calibrations of various RF/analog aspects. \\n"]
    #[doc = "It has same bit definition as above \\n"]
    pub periodicCalibEnMask: rlUInt32_t,
    #[doc = " @brief  This field is applicable only for those calibrations which are enabled to be \\n"]
    #[doc = "         done periodically in the periodicCalibEnMask field. This field indicates the \\n"]
    #[doc = "         desired periodicity of calibrations. If this field is set to N, the results of \\n"]
    #[doc = "         the first calibration (based on oneTimeCalibEnMask) are applicable for the first \\n"]
    #[doc = "         N calibMonTimeUnits. The results of the next calibration are applicable for \\n"]
    #[doc = "         the next N calibMonTimeUnits, and so on."]
    #[doc = "         Recommendation: Set calibPeriodicity such that frequency of calibrations is \\n"]
    #[doc = "         greater than or equal to 1 second. 1 LSB = 1 calibMonTimeUnit, as specified \\n"]
    #[doc = "         in rlRfSetCalMonTimeUnitConfig. If the user does not wish to receive \\n"]
    #[doc = "         calibration reports when periodic calibrations are not enabled, then the user \\n"]
    #[doc = "         should set calibPeriodicity to 0."]
    #[doc = "         Default value: 0"]
    #[doc = "         Valid Range: 0 (Disable), 4 to 100 (value 1 is not a valid value, this will cause \\n"]
    #[doc = "         internal APLL and SYNTH calibrations to stop)"]
    pub calibPeriodicity: rlUInt32_t,
    #[doc = " @brief  Calibration Report Enable Configuration \\n"]
    #[doc = "[b0]  Enable Calibration Reports Bitmap \\n"]
    #[doc = "0 -  Disable Calibration Reports \\n"]
    #[doc = "1 -  Enable Calibration Reports \\n"]
    #[doc = "[b7:1] Reserved \\n"]
    #[doc = "@note 1: If calibration reports are enabled, the reports will be sent every 1"]
    #[doc = "second whenever internal calibrations (APLL and SYNTH) are triggered \\n"]
    #[doc = "and at every CALIBRATION PERIODICITY when the user enabled calibrations"]
    #[doc = "are triggered. \\n"]
    #[doc = "@note 2: If user has not enabled any one time calibrations, but if calibration"]
    #[doc = "report is enabled, then after issuing this API, the firmware will \\n"]
    #[doc = "attempt to run the APLL and SYNTH calibrations and the calibration report"]
    #[doc = "will be immediately sent out. \\n"]
    pub reportEn: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  TX Power Calibration Mode"]
    #[doc = "[b0]  Enable Calibration Reports Bitmap (Not valid for IWR6843 ES1.0) \\n"]
    #[doc = "0 - Update TX gain setting from LUT and do a closed loop calibration \\n"]
    #[doc = "(OLPC + CLPC) \\n"]
    #[doc = "1 - Update TX gain settings from LUT only (OLPC only) \\n"]
    #[doc = "OLPC: Open Loop Power Control. In this mode the TX stage codes are set \\n"]
    #[doc = "based on a coarse measurement and a LUT generated for every temperature \\n"]
    #[doc = "and the stage codes are picked from the LUT CLPC: Closed Loop Power \\n"]
    #[doc = "Control. In this mode the TX stage codes are picked from the coarse LUT \\n"]
    #[doc = "as generated in OLPC step. Later the TX power is measured and the TX \\n"]
    #[doc = "stage codes are corrected to achieve the desired TX power accuracy. \\n"]
    #[doc = "Default value: 0 \\n"]
    #[doc = "[b7:1] Reserved \\n"]
    pub txPowerCalMode: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRunTimeCalibConf() {
    assert_eq!(
        ::core::mem::size_of::<rlRunTimeCalibConf>(),
        20usize,
        concat!("Size of: ", stringify!(rlRunTimeCalibConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRunTimeCalibConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRunTimeCalibConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRunTimeCalibConf>())).oneTimeCalibEnMask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRunTimeCalibConf),
            "::",
            stringify!(oneTimeCalibEnMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRunTimeCalibConf>())).periodicCalibEnMask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRunTimeCalibConf),
            "::",
            stringify!(periodicCalibEnMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRunTimeCalibConf>())).calibPeriodicity as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRunTimeCalibConf),
            "::",
            stringify!(calibPeriodicity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRunTimeCalibConf>())).reportEn as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRunTimeCalibConf),
            "::",
            stringify!(reportEn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRunTimeCalibConf>())).reserved0 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRunTimeCalibConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRunTimeCalibConf>())).txPowerCalMode as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRunTimeCalibConf),
            "::",
            stringify!(txPowerCalMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRunTimeCalibConf>())).reserved1 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRunTimeCalibConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRunTimeCalibConf>())).reserved2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRunTimeCalibConf),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type rlRunTimeCalibConf_t = rlRunTimeCalibConf;
#[doc = " \\brief"]
#[doc = " RX gain temperature LUT read"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRxGainTempLutReadReq {
    #[doc = " @brief  This field indicates the profile Index for which this configuration applies."]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlRxGainTempLutReadReq() {
    assert_eq!(
        ::core::mem::size_of::<rlRxGainTempLutReadReq>(),
        4usize,
        concat!("Size of: ", stringify!(rlRxGainTempLutReadReq))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRxGainTempLutReadReq>(),
        2usize,
        concat!("Alignment of ", stringify!(rlRxGainTempLutReadReq))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxGainTempLutReadReq>())).profileIndx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainTempLutReadReq),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxGainTempLutReadReq>())).reserved0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainTempLutReadReq),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxGainTempLutReadReq>())).reserved1 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainTempLutReadReq),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlRxGainTempLutReadReq_t = rlRxGainTempLutReadReq;
#[doc = " \\brief"]
#[doc = " TX gain temperature LUT read"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlTxGainTempLutReadReq {
    #[doc = " @brief  This field indicates the profile Index for which this configuration applies."]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlTxGainTempLutReadReq() {
    assert_eq!(
        ::core::mem::size_of::<rlTxGainTempLutReadReq>(),
        4usize,
        concat!("Size of: ", stringify!(rlTxGainTempLutReadReq))
    );
    assert_eq!(
        ::core::mem::align_of::<rlTxGainTempLutReadReq>(),
        2usize,
        concat!("Alignment of ", stringify!(rlTxGainTempLutReadReq))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainTempLutReadReq>())).profileIndx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainTempLutReadReq),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainTempLutReadReq>())).reserved0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainTempLutReadReq),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainTempLutReadReq>())).reserved1 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainTempLutReadReq),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlTxGainTempLutReadReq_t = rlTxGainTempLutReadReq;
#[doc = " \\brief"]
#[doc = " RX gain temperature LUT inject"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRxGainTempLutData {
    #[doc = " @brief  This field indicates the profile Index for which this configuration applies."]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Byte0: RX gain code for temperature < -30 deg C \\n"]
    #[doc = "         Byte1: RX gain code for temperature [-30, -20) deg C \\n"]
    #[doc = "         Byte2: RX gain code for temperature [-20, -10) deg C \\n"]
    #[doc = "         Byte3: RX gain code for temperature [-10, 0) deg C \\n"]
    #[doc = "         Byte4: RX gain code for temperature [0, 10) deg C \\n"]
    #[doc = "         Byte5: RX gain code for temperature [10, 20) deg C \\n"]
    #[doc = "         Byte6: RX gain code for temperature [20, 30) deg C \\n"]
    #[doc = "         Byte7: RX gain code for temperature [30, 40) deg C \\n"]
    #[doc = "         Byte8: RX gain code for temperature [40, 50) deg C \\n"]
    #[doc = "         Byte9: RX gain code for temperature [50, 60) deg C \\n"]
    #[doc = "         Byte10: RX gain code for temperature [60, 70) deg C \\n"]
    #[doc = "         Byte11: RX gain code for temperature [70, 80) deg C \\n"]
    #[doc = "         Byte12: RX gain code for temperature [80, 90) deg C \\n"]
    #[doc = "         Byte13: RX gain code for temperature [90, 100) deg C \\n"]
    #[doc = "         Byte14: RX gain code for temperature [100, 110) deg C \\n"]
    #[doc = "         Byte15: RX gain code for temperature [110, 120) deg C \\n"]
    #[doc = "         Byte16: RX gain code for temperature [120, 130) deg C \\n"]
    #[doc = "         Byte17: RX gain code for temperature [130, 140) deg C \\n"]
    #[doc = "         Byte18: RX gain code for temperature >= 140 deg C \\n"]
    #[doc = "         Byte19: RESERVED. Set it to 0x00 \\n"]
    #[doc = "         Each byte is encoded as follows \\n"]
    #[doc = "         Bits Definition\\n"]
    #[doc = "             [4:0]   IF_GAIN_CODE \\n"]
    #[doc = "                     IF gain is IF_GAIN_CODE * 2 - 6 dB \\n"]
    #[doc = "                     Valid values for xWR1xxx devices : 0 to 17 \\n"]
    #[doc = "                     Valid values for xWR6x43 device : \\n"]
    #[doc = "                     For temperatures < 10C, the max IFA gain supported is 12 (24dBm). \\n"]
    #[doc = "                     For temperatures >=10C, the max IFA gain supported is 15 (30dBm). \\n"]
    #[doc = "                     1 LSB = 2 dB \\n"]
    #[doc = "             [7:5]   RF_GAIN_CODE \\n"]
    #[doc = "                     For xWR1xxx devices: \\n"]
    #[doc = "                     Value    RF Gain \\n"]
    #[doc = "                     0     Maximum RF gain \\n"]
    #[doc = "                     1     Maximum RF gain -2dB \\n"]
    #[doc = "                     2     Maximum RF gain -4dB \\n"]
    #[doc = "                     3     Maximum RF gain -6dB \\n"]
    #[doc = "                     4     Maximum RF gain -8dB \\n"]
    #[doc = "                     For xWR6843 ES2.0: \\n"]
    #[doc = "                     Value    RF Gain \\n"]
    #[doc = "                     0     Maximum RF gain \\n"]
    #[doc = "                     1     Maximum RF gain -3.5dB \\n"]
    #[doc = "                     2     Maximum RF gain -6dB \\n"]
    pub rxGainTempLut: [rlUInt8_t; 20usize],
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlRxGainTempLutData() {
    assert_eq!(
        ::core::mem::size_of::<rlRxGainTempLutData>(),
        24usize,
        concat!("Size of: ", stringify!(rlRxGainTempLutData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRxGainTempLutData>(),
        2usize,
        concat!("Alignment of ", stringify!(rlRxGainTempLutData))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxGainTempLutData>())).profileIndx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainTempLutData),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxGainTempLutData>())).reserved0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainTempLutData),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxGainTempLutData>())).rxGainTempLut as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainTempLutData),
            "::",
            stringify!(rxGainTempLut)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxGainTempLutData>())).reserved1 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainTempLutData),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlRxGainTempLutData_t = rlRxGainTempLutData;
#[doc = " \\brief"]
#[doc = " TX gain temperature LUT inject"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlTxGainTempLutData {
    #[doc = " @brief  This field indicates the profile Index for which this configuration applies."]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Gain code for Tx0/1/2 \\n"]
    #[doc = "          Byte0: TX gain code for temperature < -30 deg C \\n"]
    #[doc = "          Byte1: TX gain code for temperature [-30, -20) deg C \\n"]
    #[doc = "          Byte2: TX gain code for temperature [-20, -10) deg C \\n"]
    #[doc = "          Byte3: TX gain code for temperature [-10, 0) deg C \\n"]
    #[doc = "          Byte4: TX gain code for temperature [0, 10) deg C \\n"]
    #[doc = "          Byte5: TX gain code for temperature [10, 20) deg C \\n"]
    #[doc = "          Byte6: TX gain code for temperature [20, 30) deg C \\n"]
    #[doc = "          Byte7: TX gain code for temperature [30, 40) deg C \\n"]
    #[doc = "          Byte8: TX gain code for temperature [40, 50) deg C \\n"]
    #[doc = "          Byte9: TX gain code for temperature [50, 60) deg C \\n"]
    #[doc = "          Byte10: TX gain code for temperature [60, 70) deg C \\n"]
    #[doc = "          Byte11: TX gain code for temperature [70, 80) deg C \\n"]
    #[doc = "          Byte12: TX gain code for temperature [80, 90) deg C \\n"]
    #[doc = "          Byte13: TX gain code for temperature [90, 100) deg C \\n"]
    #[doc = "          Byte14: TX gain code for temperature [100, 110) deg C \\n"]
    #[doc = "          Byte15: TX gain code for temperature [110, 120) deg C \\n"]
    #[doc = "          Byte16: TX gain code for temperature [120, 130) deg C \\n"]
    #[doc = "          Byte17: TX gain code for temperature [130, 140) deg C \\n"]
    #[doc = "          Byte18: TX gain code for temperature >= 140 deg C \\n"]
    #[doc = "          Byte19: RESERVED. Set it to 0x00 \\n"]
    #[doc = "         Each byte is encoded as follows \\n"]
    #[doc = "         Bits Definition \\n"]
    #[doc = "         [5:0]  STG_CODE \\n"]
    #[doc = "                Higher values for higher gain \\n"]
    #[doc = "         [7:6]  RESERVED \\n"]
    pub txGainTempLut: [[rlUInt8_t; 20usize]; 3usize],
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlTxGainTempLutData() {
    assert_eq!(
        ::core::mem::size_of::<rlTxGainTempLutData>(),
        64usize,
        concat!("Size of: ", stringify!(rlTxGainTempLutData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlTxGainTempLutData>(),
        2usize,
        concat!("Alignment of ", stringify!(rlTxGainTempLutData))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainTempLutData>())).profileIndx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainTempLutData),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxGainTempLutData>())).reserved0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainTempLutData),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainTempLutData>())).txGainTempLut as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainTempLutData),
            "::",
            stringify!(txGainTempLut)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxGainTempLutData>())).reserved1 as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainTempLutData),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlTxGainTempLutData_t = rlTxGainTempLutData;
#[doc = " \\brief"]
#[doc = " Tx freq and power limit configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfTxFreqPwrLimitMonConf {
    #[doc = " @ brief  The sensor's lower frequency limit for calibrations and monitoring for TX0 is \\n"]
    #[doc = "encoded in 2 bytes (16 bit unsigned number) \\n"]
    #[doc = "1 LSB = 10 MHz \\n"]
    #[doc = "For 77GHz devices(76GHz to 81GHz) \\n"]
    #[doc = "Valid range: 7600 to 8100"]
    #[doc = "Default value : 7600 (If API is not issued)"]
    #[doc = "For 60GHz devices(57GHz to 64GHz) \\n"]
    #[doc = "Valid range: 5700 to 6400"]
    #[doc = "Default value : 5700 (If API is not issued)"]
    pub freqLimitLowTx0: rlUInt16_t,
    #[doc = " @ brief  The sensor's lower frequency limit for calibrations and monitoring for TX1 is \\n"]
    #[doc = "encoded in 2 bytes (16 bit unsigned number) \\n"]
    #[doc = "1 LSB = 10 MHz \\n"]
    #[doc = "For 77GHz devices(76GHz to 81GHz) \\n"]
    #[doc = "Valid range: 7600 to 8100"]
    #[doc = "Default value : 7600 (If API is not issued)"]
    #[doc = "For 60GHz devices(57GHz to 64GHz) \\n"]
    #[doc = "Valid range: 5700 to 6400"]
    #[doc = "Default value : 5700 (If API is not issued)"]
    pub freqLimitLowTx1: rlUInt16_t,
    #[doc = " @ brief  The sensor's lower frequency limit for calibrations and monitoring for TX2 is \\n"]
    #[doc = "encoded in 2 bytes (16 bit unsigned number) \\n"]
    #[doc = "1 LSB = 10 MHz \\n"]
    #[doc = "For 77GHz devices(76GHz to 81GHz) \\n"]
    #[doc = "Valid range: 7600 to 8100"]
    #[doc = "Default value : 7600 (If API is not issued)"]
    #[doc = "For 60GHz devices(57GHz to 64GHz) \\n"]
    #[doc = "Valid range: 5700 to 6400"]
    #[doc = "Default value : 5700 (If API is not issued)"]
    pub freqLimitLowTx2: rlUInt16_t,
    #[doc = " @brief  The sensor's higher frequency limit for calibrations and monitoring for TX0 is \\n"]
    #[doc = "encoded in 2 bytes (16 bit unsigned number) \\n"]
    #[doc = "1 LSB = 10 MHz \\n"]
    #[doc = "For 77GHz devices(76GHz to 81GHz) \\n"]
    #[doc = "Valid range: 7600 to 8100"]
    #[doc = "Default value : 8100 (If API is not issued)"]
    #[doc = "For 60GHz devices(57GHz to 64GHz) \\n"]
    #[doc = "Valid range: 5700 to 6400"]
    #[doc = "Default value : 6400 (If API is not issued)"]
    #[doc = "@note : FREQ_LIMIT_HIGH_TXn should be strictly greater than FREQ_LIMIT_LOW_TXn \\n"]
    pub freqLimitHighTx0: rlUInt16_t,
    #[doc = " @brief  The sensor's higher frequency limit for calibrations and monitoring for TX1 is \\n"]
    #[doc = "encoded in 2 bytes (16 bit unsigned number) \\n"]
    #[doc = "1 LSB = 10 MHz \\n"]
    #[doc = "For 77GHz devices(76GHz to 81GHz) \\n"]
    #[doc = "Valid range: 7600 to 8100"]
    #[doc = "Default value : 8100 (If API is not issued)"]
    #[doc = "For 60GHz devices(57GHz to 64GHz) \\n"]
    #[doc = "Valid range: 5700 to 6400"]
    #[doc = "Default value : 6400 (If API is not issued)"]
    #[doc = "@note : FREQ_LIMIT_HIGH_TXn should be strictly greater than FREQ_LIMIT_LOW_TXn \\n"]
    pub freqLimitHighTx1: rlUInt16_t,
    #[doc = " @brief  The sensor's higher frequency limit for calibrations and monitoring for TX2 is \\n"]
    #[doc = "encoded in 2 bytes (16 bit unsigned number) \\n"]
    #[doc = "1 LSB = 10 MHz \\n"]
    #[doc = "For 77GHz devices(76GHz to 81GHz) \\n"]
    #[doc = "Valid range: 7600 to 8100"]
    #[doc = "Default value : 8100 (If API is not issued)"]
    #[doc = "For 60GHz devices(57GHz to 64GHz) \\n"]
    #[doc = "Valid range: 5700 to 6400"]
    #[doc = "Default value : 6400 (If API is not issued)"]
    #[doc = "@note : FREQ_LIMIT_HIGH_TXn should be strictly greater than FREQ_LIMIT_LOW_TXn \\n"]
    pub freqLimitHighTx2: rlUInt16_t,
    #[doc = " @brief  TX0 output power back off \\n"]
    #[doc = "1LSB = 1dB"]
    #[doc = "Valid Value: 0, 3, 6, 9"]
    pub tx0PwrBackOff: rlUInt8_t,
    #[doc = " @brief  TX1 output power back off \\n"]
    #[doc = "1LSB = 1dB"]
    #[doc = "Valid Value: 0, 3, 6, 9"]
    pub tx1PwrBackOff: rlUInt8_t,
    #[doc = " @brief  TX2 output power back off \\n"]
    #[doc = "1LSB = 1dB"]
    #[doc = "Valid Value: 0, 3, 6, 9"]
    pub tx2PwrBackOff: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved3: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved4: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlRfTxFreqPwrLimitMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlRfTxFreqPwrLimitMonConf>(),
        24usize,
        concat!("Size of: ", stringify!(rlRfTxFreqPwrLimitMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfTxFreqPwrLimitMonConf>(),
        2usize,
        concat!("Alignment of ", stringify!(rlRfTxFreqPwrLimitMonConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfTxFreqPwrLimitMonConf>())).freqLimitLowTx0 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTxFreqPwrLimitMonConf),
            "::",
            stringify!(freqLimitLowTx0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfTxFreqPwrLimitMonConf>())).freqLimitLowTx1 as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTxFreqPwrLimitMonConf),
            "::",
            stringify!(freqLimitLowTx1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfTxFreqPwrLimitMonConf>())).freqLimitLowTx2 as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTxFreqPwrLimitMonConf),
            "::",
            stringify!(freqLimitLowTx2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfTxFreqPwrLimitMonConf>())).freqLimitHighTx0 as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTxFreqPwrLimitMonConf),
            "::",
            stringify!(freqLimitHighTx0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfTxFreqPwrLimitMonConf>())).freqLimitHighTx1 as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTxFreqPwrLimitMonConf),
            "::",
            stringify!(freqLimitHighTx1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfTxFreqPwrLimitMonConf>())).freqLimitHighTx2 as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTxFreqPwrLimitMonConf),
            "::",
            stringify!(freqLimitHighTx2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfTxFreqPwrLimitMonConf>())).tx0PwrBackOff as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTxFreqPwrLimitMonConf),
            "::",
            stringify!(tx0PwrBackOff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfTxFreqPwrLimitMonConf>())).tx1PwrBackOff as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTxFreqPwrLimitMonConf),
            "::",
            stringify!(tx1PwrBackOff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfTxFreqPwrLimitMonConf>())).tx2PwrBackOff as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTxFreqPwrLimitMonConf),
            "::",
            stringify!(tx2PwrBackOff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfTxFreqPwrLimitMonConf>())).reserved0 as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTxFreqPwrLimitMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfTxFreqPwrLimitMonConf>())).reserved1 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTxFreqPwrLimitMonConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfTxFreqPwrLimitMonConf>())).reserved2 as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTxFreqPwrLimitMonConf),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfTxFreqPwrLimitMonConf>())).reserved3 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTxFreqPwrLimitMonConf),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfTxFreqPwrLimitMonConf>())).reserved4 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfTxFreqPwrLimitMonConf),
            "::",
            stringify!(reserved4)
        )
    );
}
pub type rlRfTxFreqPwrLimitMonConf_t = rlRfTxFreqPwrLimitMonConf;
#[doc = " \\brief"]
#[doc = " Loopback burst set configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlLoopbackBurst {
    #[doc = " @brief Loopback selection  \\n"]
    #[doc = "          Value Definition  \\n"]
    #[doc = "          0     No loopback \\n"]
    #[doc = "          1     IF loopback \\n"]
    #[doc = "          2     PS loopback \\n"]
    #[doc = "          3     PA loopback \\n"]
    #[doc = "          Others RESERVED   \\n"]
    pub loopbackSel: rlUInt8_t,
    #[doc = " @brief Base profile used for loopback chirps \\n"]
    #[doc = "         Valid values 0 to 3 \\n"]
    pub baseProfileIndx: rlUInt8_t,
    #[doc = " @brief Indicates the index of the burst in the loopback sub-frame for which \\n"]
    #[doc = "          this configuration applies \\n"]
    #[doc = "          Valid values 0 to 15       \\n"]
    pub burstIndx: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Start frequency for loopback \\n"]
    #[doc = "           For 77GHz devices (76 GHz to 81 GHz): \\n"]
    #[doc = "               1 LSB = 3.6e9 / 2^26 Hz = 53.644 Hz \\n"]
    #[doc = "               Valid range: 0x5471C71B to 0x5A000000 \\n"]
    #[doc = "           For 60GHz devices (57 GHz to 64 GHz): \\n"]
    #[doc = "               1 LSB = 2.7e9 / 2^26 Hz = 40.233 Hz \\n"]
    #[doc = "               Valid range: Only even numbers from 0x5471C71C to 0x5ED097B4 \\n"]
    pub freqConst: rlUInt32_t,
    #[doc = " @brief  Ramp slope for loopback burst \\n"]
    #[doc = "           For 77GHz devices (76 GHz to 81 GHz): \\n"]
    #[doc = "               1 LSB = (3.6e6 * 900) / 2^26 = 48.279 kHz/uS \\n"]
    #[doc = "               Valid range: -2072 to 2072 (Max 100MHz/uS) \\n"]
    #[doc = "           For 60GHz devices (57 GHz to 64 GHz): \\n"]
    #[doc = "               1 LSB = (2.7e6 * 900) / 2^26 = 36.21 kHz/uS \\n"]
    #[doc = "               Valid range: Only even numbers between -6905 and 6905 (Max 250 MHz/uS) \\n"]
    pub slopeConst: rlInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  Concatenated code for output power backoff for TX0, TX1, TX2\\n"]
    #[doc = "b7:0 TX0 output power back off \\n"]
    #[doc = "b15:8 TX1 output power back off \\n"]
    #[doc = "b23:16 TX2 output power back off \\n"]
    #[doc = "b31:24 Reserved \\n"]
    #[doc = "This setting is applicable only in PA loop-back mode. \\n"]
    pub txBackoff: rlUInt32_t,
    #[doc = " @brief  Bit Definition \\n"]
    #[doc = "         5:0 Rx gain    \\n"]
    #[doc = "             This field defined RX gain for each profile \\n"]
    #[doc = "             1 LSB = 1 dB \\n"]
    #[doc = "             For xWR1xxx : all even values from 24 to 52 \\n"]
    #[doc = "             For xWR6x43 : all even values from 30 to 48 \\n"]
    #[doc = "         7:6 RF Gain Target        \\n"]
    #[doc = "             For xWR1243/xWR1443/xWR1642/xWR1843:"]
    #[doc = "                 Value   RF gain target"]
    #[doc = "                  00     30 dB \\n"]
    #[doc = "                  01     34 dB \\n"]
    #[doc = "                  10     RESERVED \\n"]
    #[doc = "                  11     26 dB \\n"]
    #[doc = "             For xWR6843 ES 2.0:"]
    #[doc = "                 Value   RF gain target"]
    #[doc = "                  00     30 dB \\n"]
    #[doc = "                  01     33 dB \\n"]
    #[doc = "                  10     36 dB \\n"]
    #[doc = "                  11     RESERVED \\n"]
    #[doc = "        15:8 Reserved              \\n"]
    pub rxGain: rlUInt16_t,
    #[doc = " @brief  Tx enable selection bit mask \\n"]
    #[doc = "          b0 Enable TX0  \\n"]
    #[doc = "           0 Tx0 Disable \\n"]
    #[doc = "           1 Tx0 Enable  \\n"]
    #[doc = "          b1 Enable TX1  \\n"]
    #[doc = "           0 Tx1 Disable \\n"]
    #[doc = "           1 Tx1 Enable  \\n"]
    #[doc = "          b2 Enable TX2 (PS LB not supported for TX2) \\n"]
    #[doc = "           0 Tx2 Disable \\n"]
    #[doc = "           1 Tx2 Enable  \\n"]
    #[doc = "         This setting is applicable in all loop-back modes. \\n"]
    pub txEn: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt8_t,
    #[doc = " @brief   Bit Definition              \\n"]
    #[doc = "          b0  CONST_BPM_VAL_TX0_OFF   \\n"]
    #[doc = "               Value of Binary Phase Shift value for TX0, during idle time  \\n"]
    #[doc = "          b1  CONST_BPM_VAL_TX0_ON    \\n"]
    #[doc = "               Value of Binary Phase Shift value for TX0, during chirp      \\n"]
    #[doc = "          b2  CONST_BPM_VAL_TX1_OFF   \\n"]
    #[doc = "               Value of Binary Phase Shift value for TX1, during idle time  \\n"]
    #[doc = "          b3  CONST_BPM_VAL_TX1_ON    \\n"]
    #[doc = "               Value of Binary Phase Shift value for TX1, during chirp      \\n"]
    #[doc = "          b4  CONST_BPM_VAL_TX2_OFF   \\n"]
    #[doc = "               Value of Binary Phase Shift value for TX2, during idle time  \\n"]
    #[doc = "          b5  CONST_BPM_VAL_TX2_ON    \\n"]
    #[doc = "               Value of Binary Phase Shift value for TX2, during chirp      \\n"]
    #[doc = "       b15:6  RESERVED                \\n"]
    #[doc = "       This setting is applicable only in PA and PS loop-back modes. \\n"]
    pub bpmConfig: rlUInt16_t,
    #[doc = " @brief  Bits  Digital corrections      \\n"]
    #[doc = "b0  IQMM correction disable  \\n"]
    #[doc = "0 - Enable, 1- Disable  \\n"]
    #[doc = "b1  RX Gain and Phase correction disable \\n"]
    #[doc = "0 - Enable, 1- Disable  \\n"]
    #[doc = "b15:2  RESERVED \\n"]
    #[doc = "This setting is applicable in all loop-back modes \\n"]
    pub digCorrDis: rlUInt16_t,
    #[doc = " @brief   Value   IF Loopback frequency value \\n"]
    #[doc = "          0       180 kHz   \\n"]
    #[doc = "          1       240 kHz   \\n"]
    #[doc = "          2       360 kHz   \\n"]
    #[doc = "          3       720 kHz   \\n"]
    #[doc = "          4       1 MHz     \\n"]
    #[doc = "          5       2 MHz     \\n"]
    #[doc = "          6       2.5 MHz   \\n"]
    #[doc = "          7       3 MHz     \\n"]
    #[doc = "          8       4.02 MHz  \\n"]
    #[doc = "          9       5 MHz     \\n"]
    #[doc = "          10      6 MHz     \\n"]
    #[doc = "          11      8.03 MHz  \\n"]
    #[doc = "          12      9 MHz     \\n"]
    #[doc = "          13      10 MHz    \\n"]
    #[doc = "          255-14  RESERVED  \\n"]
    pub ifLbFreq: rlUInt8_t,
    #[doc = " @brief   1 LSB = 10 mV"]
    #[doc = "Valid range: 1 to 63"]
    pub ifLbMag: rlUInt8_t,
    #[doc = " @brief Value PGA gain value \\n"]
    #[doc = "          0   PGA is OFF     \\n"]
    #[doc = "          1   -22 dB         \\n"]
    #[doc = "          2   -16 dB         \\n"]
    #[doc = "          3   -15 dB         \\n"]
    #[doc = "          4   -14 dB         \\n"]
    #[doc = "          5   -13 dB         \\n"]
    #[doc = "          6   -12 dB         \\n"]
    #[doc = "          7   -11 dB         \\n"]
    #[doc = "          8   -10 dB         \\n"]
    #[doc = "          9    -9 dB         \\n"]
    #[doc = "          10   -8 dB         \\n"]
    #[doc = "          11   -7 dB         \\n"]
    #[doc = "          12   -6 dB         \\n"]
    #[doc = "          13   -5 dB         \\n"]
    #[doc = "          14   -4 dB         \\n"]
    #[doc = "          15   -3 dB         \\n"]
    #[doc = "          16   -2 dB         \\n"]
    #[doc = "          17   -1 dB         \\n"]
    #[doc = "          18    0 dB         \\n"]
    #[doc = "          19    1 dB         \\n"]
    #[doc = "          20    2 dB         \\n"]
    #[doc = "          21    3 dB         \\n"]
    #[doc = "          22    4 dB         \\n"]
    #[doc = "          23    5 dB         \\n"]
    #[doc = "          24    6 dB         \\n"]
    #[doc = "          25    7 dB         \\n"]
    #[doc = "          26    8 dB         \\n"]
    #[doc = "          27    9 dB         \\n"]
    #[doc = "          255-28   RESERVED  \\n"]
    pub ps1PgaIndx: rlUInt8_t,
    #[doc = " @brief Same as above definition"]
    pub ps2PgaIndx: rlUInt8_t,
    #[doc = " @brief Phase shifter loop back frequency in kHz\\n"]
    #[doc = "1 LSB = 1 kHz                         \\n"]
    #[doc = "Bits    Definition                    \\n"]
    #[doc = "b15:0   TX0 Loopback Frequency        \\n"]
    #[doc = "b31:16  TX1 Loopback Frequency        \\n"]
    pub psLbFreq: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved3: rlUInt32_t,
    #[doc = " @brief This value is a 100MHz divider which sets the loopback frequency \\n"]
    #[doc = "For e.g. for a 1 MHz frequency, set this to 100 \\n"]
    #[doc = "for a 2 MHz frequency, set this to 50  \\n"]
    #[doc = "@note : To ensure no leakage of signal power, user has to ensure that"]
    #[doc = "100MHz/LOOPBACK_FREQ is an integer multiple of bin width. \\n"]
    #[doc = "For e.g. if user choses 25Msps sampling rate and 2048 samples/chirp,"]
    #[doc = "then LOOPBACK_FREQ of 64 (=1.5625MHz) will ensure no leakage."]
    pub paLbFreq: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved4: [rlUInt16_t; 3usize],
}
#[test]
fn bindgen_test_layout_rlLoopbackBurst() {
    assert_eq!(
        ::core::mem::size_of::<rlLoopbackBurst>(),
        44usize,
        concat!("Size of: ", stringify!(rlLoopbackBurst))
    );
    assert_eq!(
        ::core::mem::align_of::<rlLoopbackBurst>(),
        4usize,
        concat!("Alignment of ", stringify!(rlLoopbackBurst))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).loopbackSel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(loopbackSel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlLoopbackBurst>())).baseProfileIndx as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(baseProfileIndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).burstIndx as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(burstIndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).reserved0 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).freqConst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(freqConst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).slopeConst as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(slopeConst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).reserved1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).txBackoff as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(txBackoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).rxGain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(rxGain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).txEn as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(txEn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).reserved2 as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).bpmConfig as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(bpmConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).digCorrDis as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(digCorrDis)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).ifLbFreq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(ifLbFreq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).ifLbMag as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(ifLbMag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).ps1PgaIndx as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(ps1PgaIndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).ps2PgaIndx as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(ps2PgaIndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).psLbFreq as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(psLbFreq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).reserved3 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).paLbFreq as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(paLbFreq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlLoopbackBurst>())).reserved4 as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rlLoopbackBurst),
            "::",
            stringify!(reserved4)
        )
    );
}
pub type rlLoopbackBurst_t = rlLoopbackBurst;
#[doc = " \\brief"]
#[doc = " Chirp row configuration, radarSS stores each chirp config in memory in 3 rows."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlChirpRow {
    #[doc = " @brief Nth Chirp config Row 1"]
    #[doc = "Bits Definition"]
    #[doc = "3:0 PROFILE_INDX"]
    #[doc = "Valid range 0 to 3"]
    #[doc = "7:4 RESERVED"]
    #[doc = "13:8 FREQ_SLOPE_VAR"]
    #[doc = "For 77GHz Devices (76GHz to 81GHz):"]
    #[doc = "1 LSB = 3.6e9*900 /2^26  ~48.279kHz"]
    #[doc = "Valid range: 0 to 63"]
    #[doc = "For 60GHz Devices (57GHz to 64GHz):"]
    #[doc = "1 LSB = 2.7e9*900 /2^26  ~36.21kHz"]
    #[doc = "Valid range: Only even numbers from 0 to 63"]
    #[doc = "15:14 RESERVED"]
    #[doc = "18:16 TX_ENABLE"]
    #[doc = "Bit Definition"]
    #[doc = "b0 TX0 Enable"]
    #[doc = "b1 TX1 Enable"]
    #[doc = "b2 TX2 Enable"]
    #[doc = "23:19 RESERVED"]
    #[doc = "29:24 BPM_CONSTANT_BITS"]
    #[doc = "Bit Definition"]
    #[doc = "b0 CONST_BPM_VAL_TX0_OFF"]
    #[doc = "Value of Binary Phase Shift value for TX0, when during idle time"]
    #[doc = "b1 CONST_BPM_VAL_TX0_ON"]
    #[doc = "Value of Binary Phase Shift value for TX0, during chirp"]
    #[doc = "b2 CONST_BPM_VAL_TX1_OFF"]
    #[doc = "For TX1"]
    #[doc = "b3 CONST_BPM_VAL_TX1_ON"]
    #[doc = "For TX1"]
    #[doc = "b4 CONST_BPM_VAL_TX2_OFF"]
    #[doc = "For TX2"]
    #[doc = "b5 CONST_BPM_VAL_TX2_ON"]
    #[doc = "For TX2"]
    #[doc = "31:30 RESERVED"]
    pub chirpNR1: rlUInt32_t,
    #[doc = " @brief Nth Chirp config Row 2"]
    #[doc = "Bits Definition"]
    #[doc = "b22:0 FREQ_START_VAR"]
    #[doc = "For 77GHz Devices (76GHz to 81GHz):"]
    #[doc = "1 LSB = 3.6e9/2^26  ~53.644 Hz"]
    #[doc = "Valid range: 0 to 8388607"]
    #[doc = "For 60GHz Devices (57GHz to 64GHz):"]
    #[doc = "1 LSB = 2.7e9 /2^26  ~40.233 Hz"]
    #[doc = "Valid range: Only even numbers from 0 to 8388607"]
    #[doc = "b31:23 RESERVED"]
    pub chirpNR2: rlUInt32_t,
    #[doc = " @brief Nth Chirp config Row 3"]
    #[doc = "Bits Definition"]
    #[doc = "b11:0 IDLE_TIME_VAR"]
    #[doc = "1 LSB = 10 ns"]
    #[doc = "Valid range: 0 to 4095"]
    #[doc = "b15:12 RESERVED"]
    #[doc = "b27:16 ADC_START_TIME_VAR"]
    #[doc = "1 LSB = 10 ns"]
    #[doc = "Valid range: 0 to 4095"]
    #[doc = "b31:28 RESERVED"]
    pub chirpNR3: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlChirpRow() {
    assert_eq!(
        ::core::mem::size_of::<rlChirpRow>(),
        12usize,
        concat!("Size of: ", stringify!(rlChirpRow))
    );
    assert_eq!(
        ::core::mem::align_of::<rlChirpRow>(),
        4usize,
        concat!("Alignment of ", stringify!(rlChirpRow))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChirpRow>())).chirpNR1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpRow),
            "::",
            stringify!(chirpNR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChirpRow>())).chirpNR2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpRow),
            "::",
            stringify!(chirpNR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlChirpRow>())).chirpNR3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpRow),
            "::",
            stringify!(chirpNR3)
        )
    );
}
pub type rlChirpRow_t = rlChirpRow;
#[doc = " \\brief"]
#[doc = " Dynamic chirp configuration for 16 chirp configurations."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDynChirpCfg {
    #[doc = " @brief  Reserved for Future use"]
    #[doc = "Bits   Definition"]
    #[doc = "b3:0   Reserved"]
    #[doc = "b7:4   If user does not wish to reconfigure all 3 chirp rows, then the following \\n"]
    #[doc = "mode can be used to configure only one row per chirp which enables the \\n"]
    #[doc = "user to configure 48 chirps in one API, efectively saving on the \\n"]
    #[doc = "reconfiguration time. If chirpRowSelect[b7:4] is non-zero, then the API \\n"]
    #[doc = "parameters chirp_xR1, chirp_xR2 and chirp_xR3 for 1 <= x <= 16 in this \\n"]
    #[doc = "API would mean CHIRP(3x - 2)Ry, CHIRP(3x - 1) Ry and CHIRP(3x)Ry where y \\n"]
    #[doc = "is as per the below table \\n"]
    #[doc = "Value         Definition \\n"]
    #[doc = "0b0000        Enables all 3 chirp rows to be reconfigured \\n"]
    #[doc = "0b0001        Enables only chirp row 1 to be reconfigured \\n"]
    #[doc = "0b0010        Enables only chirp row 2 to be reconfigured \\n"]
    #[doc = "0b0011        Enables only chirp row 3 to be reconfigured \\n"]
    #[doc = "Others        Reserved \\n"]
    #[doc = "@note : Value(1 - 3) is not applcicable in xWR6843."]
    pub chirpRowSelect: rlUInt8_t,
    #[doc = " @brief Indicates the segment of the chirp RAM that the 16 chirps definitions in this sub \\n"]
    #[doc = "         block map to any of one segment out of 32 segments of SW chirp RAM."]
    #[doc = "         Valid range 0 to 31."]
    pub chirpSegSel: rlUInt8_t,
    #[doc = " @brief  Indicates when the configuration needs to be applied \\n"]
    #[doc = "         Bit    Definition \\n"]
    #[doc = "          0     Program the new configuration when rlSetDynChirpEn API is issued \\n"]
    #[doc = "          1     Program the new configuration immediately \\n"]
    #[doc = "                @note : User has to ensure that the chirps which are being reconfigured are"]
    #[doc = "                not the ones which are currently in use for chirping"]
    pub programMode: rlUInt16_t,
    #[doc = " @brief Chirp row configurations for 16 chirps."]
    pub chirpRow: [rlChirpRow_t; 16usize],
}
#[test]
fn bindgen_test_layout_rlDynChirpCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlDynChirpCfg>(),
        196usize,
        concat!("Size of: ", stringify!(rlDynChirpCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDynChirpCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlDynChirpCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDynChirpCfg>())).chirpRowSelect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDynChirpCfg),
            "::",
            stringify!(chirpRowSelect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDynChirpCfg>())).chirpSegSel as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDynChirpCfg),
            "::",
            stringify!(chirpSegSel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDynChirpCfg>())).programMode as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDynChirpCfg),
            "::",
            stringify!(programMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDynChirpCfg>())).chirpRow as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDynChirpCfg),
            "::",
            stringify!(chirpRow)
        )
    );
}
pub type rlDynChirpCfg_t = rlDynChirpCfg;
#[doc = " \\brief"]
#[doc = " Dynamic chirp enable configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDynChirpEnCfg {
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlDynChirpEnCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlDynChirpEnCfg>(),
        4usize,
        concat!("Size of: ", stringify!(rlDynChirpEnCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDynChirpEnCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlDynChirpEnCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDynChirpEnCfg>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDynChirpEnCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlDynChirpEnCfg_t = rlDynChirpEnCfg;
#[doc = " \\brief"]
#[doc = " Dynamic per chirp phase shifter configuration for each TX"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlChirpPhShiftPerTx {
    #[doc = " @brief Nth Chirp TX0 phase shift value"]
    #[doc = "Bits TX0 phase shift definition"]
    #[doc = "b1:0 RESERVED (set it to 0b00)"]
    #[doc = "b7:2 TX0 phase shift value"]
    #[doc = "1 LSB = 360/2^6 = 5.625 (degree)"]
    #[doc = "Valid range: 0 to 63"]
    pub chirpNTx0PhaseShifter: rlUInt8_t,
    #[doc = " @brief Nth Chirp TX1 phase shift value"]
    #[doc = "Bits TX1 phase shift definition"]
    #[doc = "b1:0 RESERVED (set it to 0b00)"]
    #[doc = "b7:2 TX1 phase shift value"]
    #[doc = "1 LSB = 360/2^6 = 5.625 (degree)"]
    #[doc = "Valid range: 0 to 63"]
    pub chirpNTx1PhaseShifter: rlUInt8_t,
    #[doc = " @brief Nth Chirp TX2 phase shift value   \\n"]
    #[doc = "Bits TX2 phase shift definition \\n"]
    #[doc = "b1:0 RESERVED (set it to 0b00)  \\n"]
    #[doc = "b7:2 TX2 phase shift value"]
    #[doc = "1 LSB = 360/2^6 = 5.625 (degree)"]
    #[doc = "Valid range: 0 to 63"]
    pub chirpNTx2PhaseShifter: rlUInt8_t,
}
#[test]
fn bindgen_test_layout_rlChirpPhShiftPerTx() {
    assert_eq!(
        ::core::mem::size_of::<rlChirpPhShiftPerTx>(),
        3usize,
        concat!("Size of: ", stringify!(rlChirpPhShiftPerTx))
    );
    assert_eq!(
        ::core::mem::align_of::<rlChirpPhShiftPerTx>(),
        1usize,
        concat!("Alignment of ", stringify!(rlChirpPhShiftPerTx))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlChirpPhShiftPerTx>())).chirpNTx0PhaseShifter as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpPhShiftPerTx),
            "::",
            stringify!(chirpNTx0PhaseShifter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlChirpPhShiftPerTx>())).chirpNTx1PhaseShifter as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpPhShiftPerTx),
            "::",
            stringify!(chirpNTx1PhaseShifter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlChirpPhShiftPerTx>())).chirpNTx2PhaseShifter as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlChirpPhShiftPerTx),
            "::",
            stringify!(chirpNTx2PhaseShifter)
        )
    );
}
pub type rlChirpPhShiftPerTx_t = rlChirpPhShiftPerTx;
#[doc = " \\brief"]
#[doc = " Dynamic per chirp phase shifter configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDynPerChirpPhShftCfg {
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt8_t,
    #[doc = " @brief Indicates the segment of the chirp RAM that the 16 chirps definitions in this sub \\n"]
    #[doc = "         block map to any of one segment out of 32 segments of SW chirp RAM. \\n"]
    #[doc = "         Valid range 0 to 31."]
    pub chirpSegSel: rlUInt8_t,
    #[doc = " @brief Tx phase shifter configurations for 16 chirps."]
    #[doc = "@note : User need to take care of data for endianess."]
    pub phShiftPerTx: [rlChirpPhShiftPerTx_t; 16usize],
    #[doc = " @brief  Indicates when the configuration needs to be applied \\n"]
    #[doc = "         Bit    Definition \\n"]
    #[doc = "          0     Program the new configuration when rlSetDynChirpEn API is issued \\n"]
    #[doc = "          1     Program the new configuration immediately \\n"]
    #[doc = "                @note : User has to ensure that the chirps which are being reconfigured are"]
    #[doc = "                not the ones which are currently in use for chirping"]
    pub programMode: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlDynPerChirpPhShftCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlDynPerChirpPhShftCfg>(),
        52usize,
        concat!("Size of: ", stringify!(rlDynPerChirpPhShftCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDynPerChirpPhShftCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlDynPerChirpPhShftCfg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDynPerChirpPhShftCfg>())).reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDynPerChirpPhShftCfg),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDynPerChirpPhShftCfg>())).chirpSegSel as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDynPerChirpPhShftCfg),
            "::",
            stringify!(chirpSegSel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDynPerChirpPhShftCfg>())).phShiftPerTx as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDynPerChirpPhShftCfg),
            "::",
            stringify!(phShiftPerTx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDynPerChirpPhShftCfg>())).programMode as *const _ as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDynPerChirpPhShftCfg),
            "::",
            stringify!(programMode)
        )
    );
}
pub type rlDynPerChirpPhShftCfg_t = rlDynPerChirpPhShftCfg;
#[doc = " \\brief"]
#[doc = " Get calibration data configuration structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlCalDataGetCfg {
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt16_t,
    #[doc = " @brief Get Calibration Data Chunk Id"]
    pub chunkId: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlCalDataGetCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlCalDataGetCfg>(),
        4usize,
        concat!("Size of: ", stringify!(rlCalDataGetCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlCalDataGetCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlCalDataGetCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCalDataGetCfg>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCalDataGetCfg),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCalDataGetCfg>())).chunkId as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCalDataGetCfg),
            "::",
            stringify!(chunkId)
        )
    );
}
pub type rlCalDataGetCfg_t = rlCalDataGetCfg;
#[doc = " \\brief"]
#[doc = " Calibration data which application will receive from radarSS and will feed in to the Device"]
#[doc = " in next power up to avoid calibration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rlCalDataStore {
    #[doc = " @brief Number of calibration data chunks Available in device"]
    pub numOfChunk: rlUInt16_t,
    #[doc = " @brief Current Calibration Data Chunk Id. Valid range 0-2"]
    pub chunkId: rlUInt16_t,
    #[doc = " @brief Calibration data chunk which was stored in non-volatile memory \\n"]
    pub calData: [rlUInt8_t; 224usize],
}
#[test]
fn bindgen_test_layout_rlCalDataStore() {
    assert_eq!(
        ::core::mem::size_of::<rlCalDataStore>(),
        228usize,
        concat!("Size of: ", stringify!(rlCalDataStore))
    );
    assert_eq!(
        ::core::mem::align_of::<rlCalDataStore>(),
        2usize,
        concat!("Alignment of ", stringify!(rlCalDataStore))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCalDataStore>())).numOfChunk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCalDataStore),
            "::",
            stringify!(numOfChunk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCalDataStore>())).chunkId as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCalDataStore),
            "::",
            stringify!(chunkId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCalDataStore>())).calData as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCalDataStore),
            "::",
            stringify!(calData)
        )
    );
}
impl Default for rlCalDataStore {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlCalDataStore_t = rlCalDataStore;
#[doc = " \\brief"]
#[doc = " Structure to store all Calibration data chunks which device provides in response of"]
#[doc = " rlRfCalibDataStore API. Applcation needs to provide same structure to rlRfCalibDataRestore API"]
#[doc = " to restore calibration data to the device. \\n"]
#[doc = " Accumulative calData for 3 chunks (3 * 224 bytes) looks like as mentioned. \\n"]
#[doc = " For xWR1243/xWR1443/xWR1642/xWR1843 devices:"]
#[doc = " Field Name     Num.of bytes  Description \\n"]
#[doc = " calValidStatus     4         This field indicates the status of each calibration (0 – FAIL,"]
#[doc = "                              1 – PASS). If a particular calibration was not enabled, then its"]
#[doc = "                              corresponding field should be ignored. \\n"]
#[doc = "                              Bit   Definition (0 – FAIL, 1 – PASS) \\n"]
#[doc = "                              b0    RESERVED \\n"]
#[doc = "                              b1    APLL tuning (Ignore while restore) \\n"]
#[doc = "                              b2    SYNTH VCO1 tuning (Ignore while restore) \\n"]
#[doc = "                              b3    SYNTH VCO2 tuning (Ignore while restore) \\n"]
#[doc = "                              b4    LODIST calibration (Ignore while restore) \\n"]
#[doc = "                              b5    RX ADC DC offset calibration \\n"]
#[doc = "                              b6    HPF cutoff calibration \\n"]
#[doc = "                              b7    LPF cutoff calibration \\n"]
#[doc = "                              b8    Peak detector calibration (optional) \\n"]
#[doc = "                              b9    TX Power calibration (optional) \\n"]
#[doc = "                              b10   RX gain calibration \\n"]
#[doc = "                              b11   TX Phase calibration (Ignore while restore) \\n"]
#[doc = "                              b12   RX IQMM calibration \\n"]
#[doc = "                              b31:13 RESERVED"]
#[doc = "                              The recommended Validity status bits while restoring"]
#[doc = "                              is 0x000014E0, assuming only rxAdcDcCalData,"]
#[doc = "                              hpfCalData, lpfCalData, rxRfGainCalData and IQMM"]
#[doc = "                              iqmmCalData are stored and restored. \\n"]
#[doc = " calValidStatusCpy 4          Redundant calValidStatus value, this value should match with"]
#[doc = "                              calValidStatus. \\n"]
#[doc = " ifStageCalStatus  4          This field indicates the status of IF stage calibration (0 – FAIL,"]
#[doc = "                              1 – PASS). If a particular calibration was not enabled, then its"]
#[doc = "                              corresponding field should be ignored. \\n"]
#[doc = "                              Bit Definition (0 – FAIL, 1 – PASS) \\n"]
#[doc = "                              b0  HPF1 \\n"]
#[doc = "                              b1  HPF2 \\n"]
#[doc = "                              b2  LPF1 \\n"]
#[doc = "                              b3  LPF2 \\n"]
#[doc = "                              b31:4 RESERVED \\n"]
#[doc = "                              This value shall be set to 0xF if HPF and LPF"]
#[doc = "                              calibration validity status are PASS. \\n"]
#[doc = " reserved          4          Reserved for Future use \\n"]
#[doc = " calTemperature    2          Temperature at which boot calibration is done. \\n"]
#[doc = " reserved          14         Reserved for Future use \\n"]
#[doc = " rxAdcDcCalibData  16         RX chain ADC DC calibration data \\n"]
#[doc = " hpf1CalData       1          HPF1 calibration data \\n"]
#[doc = " hpf2CalData       1          HPF2 calibration data \\n"]
#[doc = " reserved          2          Reserved for Future use \\n"]
#[doc = " lpf1CalData       24         LPF1 calibration data \\n"]
#[doc = " lpf2CalData       24         LPF2 calibration data \\n"]
#[doc = " rxRfGainCalData   12         RX RF gain calibration data \\n"]
#[doc = " iqmmCalibData     72         RX IQMM calibration data \\n"]
#[doc = " txPowCalData      84         TX Power calibration data \\n"]
#[doc = " powDetCalData     348        Power detector calibration data \\n"]
#[doc = " reserved          56         Reserved for Future use \\n"]
#[doc = ""]
#[doc = " For xWR6843 device:"]
#[doc = " Field Name     Num.of bytes  Description \\n"]
#[doc = " calValidStatus     4         This field indicates the status of each calibration (0 – FAIL,"]
#[doc = "                              1 – PASS). If a particular calibration was not enabled, then its"]
#[doc = "                              corresponding field should be ignored. \\n"]
#[doc = "                              Bit   Definition (0 – FAIL, 1 – PASS) \\n"]
#[doc = "                              b0    RESERVED \\n"]
#[doc = "                              b1    APLL tuning (Ignore while restore) \\n"]
#[doc = "                              b2    SYNTH VCO1 tuning (Ignore while restore) \\n"]
#[doc = "                              b3    SYNTH VCO2 tuning (Ignore while restore) \\n"]
#[doc = "                              b4    LODIST calibration (Ignore while restore) \\n"]
#[doc = "                              b5    RX ADC DC offset calibration \\n"]
#[doc = "                              b6    HPF cutoff calibration \\n"]
#[doc = "                              b7    LPF cutoff calibration \\n"]
#[doc = "                              b8    Peak detector calibration (optional) \\n"]
#[doc = "                              b9    TX Power calibration (optional) \\n"]
#[doc = "                              b10   RX gain calibration \\n"]
#[doc = "                              b11   TX Phase calibration (optional) \\n"]
#[doc = "                              b12   RX IQMM calibration \\n"]
#[doc = "                              b31:13 RESERVED"]
#[doc = "                              The recommended Validity status bits while restoring"]
#[doc = "                              is 0x000014E0, assuming only rxAdcDcCalData,"]
#[doc = "                              hpfCalData, lpfCalData, rxRfGainCalData and IQMM"]
#[doc = "                              iqmmCalData are stored and restored. \\n"]
#[doc = " calValidStatusCpy 4          Redundant calValidStatus value, this value should match with"]
#[doc = "                              calValidStatus. \\n"]
#[doc = " reserved          8          Reserved for Future use \\n"]
#[doc = " calTemperature    2          Temperature at which boot calibration is done. \\n"]
#[doc = " reserved          14         Reserved for Future use \\n"]
#[doc = " rxAdcDcCalibData  16         RX chain ADC DC calibration data \\n"]
#[doc = " hpf1CalData       1          HPF1 calibration data \\n"]
#[doc = " hpf2CalData       1          HPF2 calibration data \\n"]
#[doc = " loDistBiasCode    1          LODIST calibration data \\n"]
#[doc = " reserved          1          Reserved for Future use \\n"]
#[doc = " rxRfGainCalData   8          RX RF gain calibration data \\n"]
#[doc = " iqmmCalibData     104        RX IQMM calibration data \\n"]
#[doc = " txPowCalData      122        TX Power calibration data \\n"]
#[doc = " powDetCalData     344        Power detector calibration data \\n"]
#[doc = " reserved          42         Reserved for Future use \\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rlCalibrationData {
    pub calibChunk: [rlCalDataStore_t; 3usize],
}
#[test]
fn bindgen_test_layout_rlCalibrationData() {
    assert_eq!(
        ::core::mem::size_of::<rlCalibrationData>(),
        684usize,
        concat!("Size of: ", stringify!(rlCalibrationData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlCalibrationData>(),
        2usize,
        concat!("Alignment of ", stringify!(rlCalibrationData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlCalibrationData>())).calibChunk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlCalibrationData),
            "::",
            stringify!(calibChunk)
        )
    );
}
impl Default for rlCalibrationData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlCalibrationData_t = rlCalibrationData;
#[doc = " \\brief"]
#[doc = " Inter-Rx gain and phase offset configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlInterRxGainPhConf {
    #[doc = " @brief  This field indicates the profile Index for which this configuration applies."]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  One byte per RX (8-bit signed number) \\n"]
    #[doc = "Byte    Assignment \\n"]
    #[doc = "0       RX0 digital gain \\n"]
    #[doc = "1       RX1 digital gain \\n"]
    #[doc = "2       RX2 digital gain \\n"]
    #[doc = "3       RX3 digital gain \\n"]
    #[doc = "1 LSB = 0.1 dB \\n"]
    #[doc = "Valid Range: -120 to 119 \\n"]
    pub digRxGain: [rlInt8_t; 4usize],
    #[doc = " @brief  Two bytes per RX \\n"]
    #[doc = "Bits         Assignment \\n"]
    #[doc = "b15:0        RX0 digital phase shift \\n"]
    #[doc = "b31:16       RX1 digital phase shift \\n"]
    #[doc = "b47:32       RX2 digital phase shift \\n"]
    #[doc = "b63:48       RX3 digital phase shift \\n"]
    #[doc = "1 LSB = 360 degree / 2^16  ~ 0.0055 (degree) \\n"]
    #[doc = "Valid Range: 0 to 65535 \\n"]
    #[doc = "NOTE: This field is NOT applicable when ADC_OUT_FMT is 00 (real output) \\n"]
    pub digRxPhShift: [rlUInt16_t; 4usize],
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved3: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlInterRxGainPhConf() {
    assert_eq!(
        ::core::mem::size_of::<rlInterRxGainPhConf>(),
        24usize,
        concat!("Size of: ", stringify!(rlInterRxGainPhConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlInterRxGainPhConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlInterRxGainPhConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterRxGainPhConf>())).profileIndx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterRxGainPhConf),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlInterRxGainPhConf>())).reserved0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterRxGainPhConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlInterRxGainPhConf>())).reserved1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterRxGainPhConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlInterRxGainPhConf>())).digRxGain as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterRxGainPhConf),
            "::",
            stringify!(digRxGain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterRxGainPhConf>())).digRxPhShift as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterRxGainPhConf),
            "::",
            stringify!(digRxPhShift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlInterRxGainPhConf>())).reserved2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterRxGainPhConf),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlInterRxGainPhConf>())).reserved3 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterRxGainPhConf),
            "::",
            stringify!(reserved3)
        )
    );
}
pub type rlInterRxGainPhConf_t = rlInterRxGainPhConf;
#[doc = " \\brief"]
#[doc = " BSS Bootup status data structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfBootStatusCfg {
    #[doc = " @brief radarSS bootup status"]
    #[doc = "Bit     definition [1: pass, 0: fail]"]
    #[doc = "0       image CRC validation"]
    #[doc = "1       CPU and VIM self-test status"]
    #[doc = "2       Reserved"]
    #[doc = "3       VIM test"]
    #[doc = "4       STC self-test"]
    #[doc = "5       CR4 STC"]
    #[doc = "6       CRC test"]
    #[doc = "7       Pampgen ECC"]
    #[doc = "8       DFE Parity (RESERVED in xWR6x43 devices)"]
    #[doc = "9       DFE ECC"]
    #[doc = "10      Rampgen Lockstep"]
    #[doc = "11      FRC lockstep"]
    #[doc = "12      DFE PBIST"]
    #[doc = "13      Rampgen lockstep"]
    #[doc = "14      PBIST test"]
    #[doc = "15      WDT test"]
    #[doc = "16      ESM test"]
    #[doc = "17      DFE STC"]
    #[doc = "18      FRC test"]
    #[doc = "19      TCM ECC"]
    #[doc = "20      TCM parity"]
    #[doc = "21      DCC test"]
    #[doc = "22      SOCC test"]
    #[doc = "23      GPADC test"]
    #[doc = "24      FFT test"]
    #[doc = "25      RTI test"]
    #[doc = "26      PCR test"]
    #[doc = "31:27   reserved"]
    pub bssSysStatus: rlUInt32_t,
    #[doc = " @brief RF BIST SS power up time \\n"]
    #[doc = "1 LSB = 5ns"]
    pub bssBootUpTime: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRfBootStatusCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlRfBootStatusCfg>(),
        16usize,
        concat!("Size of: ", stringify!(rlRfBootStatusCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfBootStatusCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRfBootStatusCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfBootStatusCfg>())).bssSysStatus as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfBootStatusCfg),
            "::",
            stringify!(bssSysStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfBootStatusCfg>())).bssBootUpTime as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfBootStatusCfg),
            "::",
            stringify!(bssBootUpTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfBootStatusCfg>())).reserved0 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfBootStatusCfg),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfBootStatusCfg>())).reserved1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfBootStatusCfg),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlRfBootStatusCfg_t = rlRfBootStatusCfg;
#[doc = " \\brief"]
#[doc = " Inter Chirp block control configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlInterChirpBlkCtrlCfg {
    #[doc = " @brief Time to wait after ramp end before turning off RX0 and RX2 RF stages. \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub rx02RfTurnOffTime: rlInt16_t,
    #[doc = " @brief Time to wait after ramp end before turning off RX1 and RX3 RF stages. \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub rx13RfTurnOffTime: rlInt16_t,
    #[doc = " @brief Time to wait after ramp end before turning off RX0 and RX2 baseband stages. \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub rx02BbTurnOffTime: rlInt16_t,
    #[doc = " @brief Time to wait after ramp end before turning off RX1 and RX3 baseband stages. \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub rx12BbTurnOffTime: rlInt16_t,
    #[doc = " @brief Time before TX Start Time when RX0 and RX2 RF stages are to be put in"]
    #[doc = "fast-charge state.          \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub rx02RfPreEnTime: rlInt16_t,
    #[doc = " @brief Time before TX Start Time when RX1 and RX3 RF stages are to be put in"]
    #[doc = "fast-charge state.          \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub rx13RfPreEnTime: rlInt16_t,
    #[doc = " @brief Time before TX Start Time when RX0 and RX2 baseband stages are to be put in"]
    #[doc = "fast-charge state.          \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub rx02BbPreEnTime: rlInt16_t,
    #[doc = " @brief Time before TX Start Time when RX1 and RX3 baseband stages are to be put in"]
    #[doc = "fast-charge state.          \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub rx13BbPreEnTime: rlInt16_t,
    #[doc = " @brief Time before TX Start Time when RX0 and RX2 RF stages are to be enabled. \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub rx02RfTurnOnTime: rlInt16_t,
    #[doc = " @brief Time before TX Start Time when RX1 and RX3 RF stages are to be enabled. \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub rx13RfTurnOnTime: rlInt16_t,
    #[doc = " @brief Time before TX Start Time when RX0 and RX2 baseband stages are to be enabled. \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub rx02BbTurnOnTime: rlInt16_t,
    #[doc = " @brief Time before TX Start Time when RX1 and RX3 baseband stages are to be enabled. \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub rx13BbTurnOnTime: rlInt16_t,
    #[doc = " @brief Time to wait after ramp end before turning off RX LO chain. \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub rxLoChainTurnOffTime: rlInt16_t,
    #[doc = " @brief Time to wait after ramp end before turning off TX LO chain. \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub txLoChainTurnOffTime: rlInt16_t,
    #[doc = " @brief Time to wait after ramp end before turning on RX LO chain. \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub rxLoChainTurnOnTime: rlInt16_t,
    #[doc = " @brief Time to wait after ramp end before turning on TX LO chain. \\n"]
    #[doc = "1 LSB = 10 ns               \\n"]
    #[doc = "Valid range: -1024 to 1023  \\n"]
    pub txLoChainTurnOnTime: rlInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlInt32_t,
}
#[test]
fn bindgen_test_layout_rlInterChirpBlkCtrlCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlInterChirpBlkCtrlCfg>(),
        40usize,
        concat!("Size of: ", stringify!(rlInterChirpBlkCtrlCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlInterChirpBlkCtrlCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlInterChirpBlkCtrlCfg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).rx02RfTurnOffTime as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(rx02RfTurnOffTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).rx13RfTurnOffTime as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(rx13RfTurnOffTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).rx02BbTurnOffTime as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(rx02BbTurnOffTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).rx12BbTurnOffTime as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(rx12BbTurnOffTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).rx02RfPreEnTime as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(rx02RfPreEnTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).rx13RfPreEnTime as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(rx13RfPreEnTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).rx02BbPreEnTime as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(rx02BbPreEnTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).rx13BbPreEnTime as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(rx13BbPreEnTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).rx02RfTurnOnTime as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(rx02RfTurnOnTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).rx13RfTurnOnTime as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(rx13RfTurnOnTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).rx02BbTurnOnTime as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(rx02BbTurnOnTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).rx13BbTurnOnTime as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(rx13BbTurnOnTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).rxLoChainTurnOffTime as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(rxLoChainTurnOffTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).txLoChainTurnOffTime as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(txLoChainTurnOffTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).rxLoChainTurnOnTime as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(rxLoChainTurnOnTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).txLoChainTurnOnTime as *const _
                as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(txLoChainTurnOnTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).reserved0 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlInterChirpBlkCtrlCfg>())).reserved1 as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rlInterChirpBlkCtrlCfg),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlInterChirpBlkCtrlCfg_t = rlInterChirpBlkCtrlCfg;
#[doc = " \\brief"]
#[doc = " Sub-frame trigger API"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlSubFrameStartCfg {
    #[doc = " @brief Command for sub-frame trigger     \\n"]
    #[doc = "Value 0 = No effect               \\n"]
    #[doc = "Value 1 = Trigger next sub-frame  \\n"]
    pub startCmd: rlUInt16_t,
    #[doc = " @brief Reserved for future use"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlSubFrameStartCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlSubFrameStartCfg>(),
        4usize,
        concat!("Size of: ", stringify!(rlSubFrameStartCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlSubFrameStartCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlSubFrameStartCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSubFrameStartCfg>())).startCmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameStartCfg),
            "::",
            stringify!(startCmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSubFrameStartCfg>())).reserved as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSubFrameStartCfg),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlSubFrameStartCfg_t = rlSubFrameStartCfg;
#[doc = " \\brief"]
#[doc = " Get phase shift calibration data configuration structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlPhShiftCalDataGetCfg {
    #[doc = " @brief  Index of the transmitter channel for which the phase shift is desired \\n"]
    #[doc = "Valid range: 0 to (Number of Tx channels enabled at rlSetChannelConfig) - 1 \\n"]
    #[doc = "e.g: 0 to 1 (For xWR1642), 0 to 2 (For xWR1843, xWR1443 & xWR1243 & xWR6x43). \\n"]
    pub txIndex: rlUInt8_t,
    #[doc = " @brief Reserved for future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief Reserved for future use"]
    pub reserved1: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlPhShiftCalDataGetCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlPhShiftCalDataGetCfg>(),
        4usize,
        concat!("Size of: ", stringify!(rlPhShiftCalDataGetCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlPhShiftCalDataGetCfg>(),
        2usize,
        concat!("Alignment of ", stringify!(rlPhShiftCalDataGetCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlPhShiftCalDataGetCfg>())).txIndex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPhShiftCalDataGetCfg),
            "::",
            stringify!(txIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPhShiftCalDataGetCfg>())).reserved0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPhShiftCalDataGetCfg),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPhShiftCalDataGetCfg>())).reserved1 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPhShiftCalDataGetCfg),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlPhShiftCalDataGetCfg_t = rlPhShiftCalDataGetCfg;
#[doc = " \\brief"]
#[doc = " Phase shift calibration data which application will receive from radarSS and will feed in to the"]
#[doc = " Device in next power up to avoid calibration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rlPhShiftCalibrationStore {
    #[doc = " @brief  Index of the transmitter channel for which the phase shift is desired \\n"]
    #[doc = "Valid range: 0 to (Number of Tx channels enabled at rlSetChannelConfig) - 1 \\n"]
    #[doc = "e.g: 0 to 1 (For xWR1642), 0 to 2 (For xWR1843, xWR1443 & xWR1243). \\n"]
    pub txIndex: rlUInt8_t,
    #[doc = " @brief Set this to 1 after injecting calibration data for all Txs to enable the firmware \\n"]
    #[doc = "calibration. For example, if we need to inject calibration data for 3 TX channels, \\n"]
    #[doc = "we would have to issue the RL_RF_STATIC_CONF_SET_MSG with \\n"]
    #[doc = "RL_RF_PH_SHIFT_CAL_DATA_RD_WR_SB three times, each time with the calibration data \\n"]
    #[doc = "for one TX channel. We need to ensure that for the first two instances of the API, \\n"]
    #[doc = "we set the calibApply field to '0'. When issuing the last instance of the API, \\n"]
    #[doc = "when the radarss has complete calibration data for all 3 TX channels, set the \\n"]
    #[doc = "calibApply field to '1'. \\n"]
    pub calibApply: rlUInt8_t,
    #[doc = " @brief Observed phase shift corresponding to each desired phase shift. Index n \\n"]
    #[doc = "corresponds to desired phase shift of n * 5.625 degree. \\n"]
    #[doc = "For TX0, for phase shifter setting/index n=0 to 63 corresponding to functional APIs"]
    #[doc = "(e.g. Profile Config, Per Chirp Phase Shifter, etc), the calibration data needs to be"]
    #[doc = "retrieved from/restored to following byte locations of TX0 phase calibration data"]
    #[doc = "save/restore API: \\n"]
    #[doc = "n     Desired phase shift   Observed phase shift is injected in the following bytes \\n"]
    #[doc = "17    17*5.625 degrees               byte[1], byte[0]     \\n"]
    #[doc = "18    18*5.625 degrees               byte[3], byte[2]     \\n"]
    #[doc = ":          :                                :             \\n"]
    #[doc = ":          :                                :             \\n"]
    #[doc = "62    62*5.625 degrees               byte[91], byte[90]   \\n"]
    #[doc = "63    63*5.625 degrees               byte[93], byte[92]   \\n"]
    #[doc = "0      0*5.625 degrees               byte[95], byte[94]   \\n"]
    #[doc = "1      1*5.625 degrees               byte[97], byte[96]   \\n"]
    #[doc = ":          :                                :             \\n"]
    #[doc = ":          :                                :             \\n"]
    #[doc = "15    15*5.625 degrees               byte[125], byte[124] \\n"]
    #[doc = "16    16*5.625 degrees               byte[127], byte[126] \\n"]
    #[doc = "For TX1 and TX2, for phase shifter setting/index n=0 to 63 corresponding to functional"]
    #[doc = "APIs (e.g. Profile Config, Per Chirp Phase Shifter, etc), the calibration data needs to"]
    #[doc = "be retrieved from/restored to following byte locations of TX1 and TX2 phase calibration"]
    #[doc = "data save/restore API: \\n"]
    #[doc = "n     Desired phase shift   Observed phase shift is injected in the following bytes \\n"]
    #[doc = "49    49*5.625 degrees               byte[1], byte[0]     \\n"]
    #[doc = "50    50*5.625 degrees               byte[3], byte[2]     \\n"]
    #[doc = ":          :                                :             \\n"]
    #[doc = ":          :                                :             \\n"]
    #[doc = "62    62*5.625 degrees               byte[27], byte[26]   \\n"]
    #[doc = "63    63*5.625 degrees               byte[29], byte[28]   \\n"]
    #[doc = "0      0*5.625 degrees               byte[31], byte[30]   \\n"]
    #[doc = "1      1*5.625 degrees               byte[33], byte[32]   \\n"]
    #[doc = ":          :                                :             \\n"]
    #[doc = ":          :                                :             \\n"]
    #[doc = "47    47*5.625 degrees               byte[125], byte[124] \\n"]
    #[doc = "48    48*5.625 degrees               byte[127], byte[126] \\n"]
    #[doc = "1 LSB = (360 degree)/pow(2,10). \\n"]
    pub observedPhShiftData: [rlUInt8_t; 128usize],
    #[doc = " @brief Reserved for future use"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlPhShiftCalibrationStore() {
    assert_eq!(
        ::core::mem::size_of::<rlPhShiftCalibrationStore>(),
        132usize,
        concat!("Size of: ", stringify!(rlPhShiftCalibrationStore))
    );
    assert_eq!(
        ::core::mem::align_of::<rlPhShiftCalibrationStore>(),
        2usize,
        concat!("Alignment of ", stringify!(rlPhShiftCalibrationStore))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPhShiftCalibrationStore>())).txIndex as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPhShiftCalibrationStore),
            "::",
            stringify!(txIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPhShiftCalibrationStore>())).calibApply as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPhShiftCalibrationStore),
            "::",
            stringify!(calibApply)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPhShiftCalibrationStore>())).observedPhShiftData as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPhShiftCalibrationStore),
            "::",
            stringify!(observedPhShiftData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPhShiftCalibrationStore>())).reserved as *const _ as usize
        },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPhShiftCalibrationStore),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for rlPhShiftCalibrationStore {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlPhShiftCalibrationStore_t = rlPhShiftCalibrationStore;
#[doc = " \\brief"]
#[doc = " Structure to store all Phase shifter calibration data chunks which device provides in response of"]
#[doc = " rlRfPhShiftCalibDataStore API. Applcation needs to provide same structure to"]
#[doc = " rlRfPhShiftCalibDataRestore API to restore calibration data to the device."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rlPhShiftCalibrationData {
    pub PhShiftcalibChunk: [rlPhShiftCalibrationStore_t; 3usize],
}
#[test]
fn bindgen_test_layout_rlPhShiftCalibrationData() {
    assert_eq!(
        ::core::mem::size_of::<rlPhShiftCalibrationData>(),
        396usize,
        concat!("Size of: ", stringify!(rlPhShiftCalibrationData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlPhShiftCalibrationData>(),
        2usize,
        concat!("Alignment of ", stringify!(rlPhShiftCalibrationData))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPhShiftCalibrationData>())).PhShiftcalibChunk as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPhShiftCalibrationData),
            "::",
            stringify!(PhShiftcalibChunk)
        )
    );
}
impl Default for rlPhShiftCalibrationData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlPhShiftCalibrationData_t = rlPhShiftCalibrationData;
#[doc = " \\brief"]
#[doc = " Die ID data structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfDieIdCfg {
    #[doc = " @brief Lot number"]
    pub lotNo: rlUInt32_t,
    #[doc = " @brief Wafer number"]
    pub waferNo: rlUInt32_t,
    #[doc = " @brief X cordinate of the die in the wafer"]
    pub devX: rlUInt32_t,
    #[doc = " @brief Y cordinate of the die in the wafer"]
    pub devY: rlUInt32_t,
    #[doc = " @brief Reserved for future use"]
    pub reserved0: rlUInt32_t,
    #[doc = " @brief Reserved for future use"]
    pub reserved1: rlUInt32_t,
    #[doc = " @brief Reserved for future use"]
    pub reserved2: rlUInt32_t,
    #[doc = " @brief Reserved for future use"]
    pub reserved3: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRfDieIdCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlRfDieIdCfg>(),
        32usize,
        concat!("Size of: ", stringify!(rlRfDieIdCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfDieIdCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRfDieIdCfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDieIdCfg>())).lotNo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDieIdCfg),
            "::",
            stringify!(lotNo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDieIdCfg>())).waferNo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDieIdCfg),
            "::",
            stringify!(waferNo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDieIdCfg>())).devX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDieIdCfg),
            "::",
            stringify!(devX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDieIdCfg>())).devY as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDieIdCfg),
            "::",
            stringify!(devY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDieIdCfg>())).reserved0 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDieIdCfg),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDieIdCfg>())).reserved1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDieIdCfg),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDieIdCfg>())).reserved2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDieIdCfg),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRfDieIdCfg>())).reserved3 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfDieIdCfg),
            "::",
            stringify!(reserved3)
        )
    );
}
pub type rlRfDieIdCfg_t = rlRfDieIdCfg;
#[doc = " \\brief"]
#[doc = " APLL Synthesizer Bandwidth Control"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRfApllSynthBwControl {
    #[doc = " @brief  Synth ICP trim code \\n"]
    pub synthIcpTrim: rlUInt8_t,
    #[doc = " @brief  Synth RZ trim code \\n"]
    pub synthRzTrim: rlUInt8_t,
    #[doc = " @brief  APLL ICP trim code \\n"]
    pub apllIcpTrim: rlUInt8_t,
    #[doc = " @brief  APLL RZ trim LPF code \\n"]
    pub apllRzTrimLpf: rlUInt8_t,
    #[doc = " @brief  APLL RZ trim VCO code \\n"]
    pub apllRzTrimVco: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: [rlUInt16_t; 5usize],
}
#[test]
fn bindgen_test_layout_rlRfApllSynthBwControl() {
    assert_eq!(
        ::core::mem::size_of::<rlRfApllSynthBwControl>(),
        16usize,
        concat!("Size of: ", stringify!(rlRfApllSynthBwControl))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfApllSynthBwControl>(),
        2usize,
        concat!("Alignment of ", stringify!(rlRfApllSynthBwControl))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfApllSynthBwControl>())).synthIcpTrim as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfApllSynthBwControl),
            "::",
            stringify!(synthIcpTrim)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfApllSynthBwControl>())).synthRzTrim as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfApllSynthBwControl),
            "::",
            stringify!(synthRzTrim)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfApllSynthBwControl>())).apllIcpTrim as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfApllSynthBwControl),
            "::",
            stringify!(apllIcpTrim)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfApllSynthBwControl>())).apllRzTrimLpf as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfApllSynthBwControl),
            "::",
            stringify!(apllRzTrimLpf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfApllSynthBwControl>())).apllRzTrimVco as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfApllSynthBwControl),
            "::",
            stringify!(apllRzTrimVco)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfApllSynthBwControl>())).reserved0 as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfApllSynthBwControl),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfApllSynthBwControl>())).reserved as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfApllSynthBwControl),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlRfApllSynthBwControl_t = rlRfApllSynthBwControl;
extern "C" {
    #[doc = " FUNCTION DECLARATIONS"]
    #[doc = ""]
    pub fn rlSetChannelConfig(deviceMap: rlUInt8_t, data: *mut rlChanCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetAdcOutConfig(deviceMap: rlUInt8_t, data: *mut rlAdcOutCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetLowPowerModeConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlLowPowerModeCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfInit(deviceMap: rlUInt8_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlGetProfileConfig(
        deviceMap: rlUInt8_t,
        profileId: rlUInt16_t,
        data: *mut rlProfileCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetProfileConfig(
        deviceMap: rlUInt8_t,
        cnt: rlUInt16_t,
        data: *mut rlProfileCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlGetChirpConfig(
        deviceMap: rlUInt8_t,
        chirpStartIdx: rlUInt16_t,
        chirpEndIdx: rlUInt16_t,
        data: *mut rlChirpCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetChirpConfig(
        deviceMap: rlUInt8_t,
        cnt: rlUInt16_t,
        data: *mut rlChirpCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetMultiChirpCfg(
        deviceMap: rlUInt8_t,
        cnt: rlUInt16_t,
        data: *mut *mut rlChirpCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlGetFrameConfig(deviceMap: rlUInt8_t, data: *mut rlFrameCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetFrameConfig(deviceMap: rlUInt8_t, data: *mut rlFrameCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSensorStart(deviceMap: rlUInt8_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSensorStop(deviceMap: rlUInt8_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlGetAdvFrameConfig(deviceMap: rlUInt8_t, data: *mut rlAdvFrameCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetAdvFrameConfig(deviceMap: rlUInt8_t, data: *mut rlAdvFrameCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetContModeConfig(deviceMap: rlUInt8_t, data: *mut rlContModeCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlEnableContMode(deviceMap: rlUInt8_t, data: *mut rlContModeEn_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetBpmCommonConfig(deviceMap: rlUInt8_t, data: *mut rlBpmCommonCfg_t)
        -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetBpmChirpConfig(deviceMap: rlUInt8_t, data: *mut rlBpmChirpCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetMultiBpmChirpConfig(
        deviceMap: rlUInt8_t,
        cnt: rlUInt16_t,
        data: *mut *mut rlBpmChirpCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetTestSourceConfig(deviceMap: rlUInt8_t, data: *mut rlTestSource_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlTestSourceEnable(
        deviceMap: rlUInt8_t,
        data: *mut rlTestSourceEnable_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfGetTemperatureReport(
        deviceMap: rlUInt8_t,
        data: *mut rlRfTempData_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfDfeRxStatisticsReport(
        deviceMap: rlUInt8_t,
        data: *mut rlDfeStatReport_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfDynamicPowerSave(deviceMap: rlUInt8_t, data: *mut rlDynPwrSave_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfSetDeviceCfg(deviceMap: rlUInt8_t, data: *mut rlRfDevCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetGpAdcConfig(deviceMap: rlUInt8_t, data: *mut rlGpAdcCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfSetLdoBypassConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRfLdoBypassCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfSetPhaseShiftConfig(
        deviceMap: rlUInt8_t,
        cnt: rlUInt16_t,
        data: *mut rlRfPhaseShiftCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfSetPALoopbackConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRfPALoopbackCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfSetPSLoopbackConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRfPSLoopbackCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfSetIFLoopbackConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRfIFLoopbackCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfSetProgFiltCoeffRam(
        deviceMap: rlUInt8_t,
        data: *mut rlRfProgFiltCoeff_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfSetProgFiltConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRfProgFiltConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfSetMiscConfig(deviceMap: rlUInt8_t, data: *mut rlRfMiscConf_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfSetCalMonTimeUnitConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRfCalMonTimeUntConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfSetCalMonFreqLimitConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRfCalMonFreqLimitConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfInitCalibConfig(deviceMap: rlUInt8_t, data: *mut rlRfInitCalConf_t)
        -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfRunTimeCalibConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRunTimeCalibConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRxGainTempLutSet(
        deviceMap: rlUInt8_t,
        data: *mut rlRxGainTempLutData_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRxGainTempLutGet(
        deviceMap: rlUInt8_t,
        inData: *mut rlRxGainTempLutReadReq_t,
        outData: *mut rlRxGainTempLutData_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlTxGainTempLutSet(
        deviceMap: rlUInt8_t,
        data: *mut rlTxGainTempLutData_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlTxGainTempLutGet(
        deviceMap: rlUInt8_t,
        inData: *mut rlTxGainTempLutReadReq_t,
        outData: *mut rlTxGainTempLutData_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfTxFreqPwrLimitConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRfTxFreqPwrLimitMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetLoopBckBurstCfg(
        deviceMap: rlUInt8_t,
        data: *mut rlLoopbackBurst_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetDynChirpCfg(
        deviceMap: rlUInt8_t,
        segCnt: rlUInt16_t,
        data: *mut *mut rlDynChirpCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetDynChirpEn(deviceMap: rlUInt8_t, data: *mut rlDynChirpEnCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetDynPerChirpPhShifterCfg(
        deviceMap: rlUInt8_t,
        segCnt: rlUInt16_t,
        data: *mut *mut rlDynPerChirpPhShftCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfCalibDataStore(
        deviceMap: rlUInt8_t,
        data: *mut rlCalibrationData_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfCalibDataRestore(
        deviceMap: rlUInt8_t,
        data: *mut rlCalibrationData_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfInterRxGainPhaseConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlInterRxGainPhConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlGetRfBootupStatus(
        deviceMap: rlUInt8_t,
        data: *mut rlRfBootStatusCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetInterChirpBlkCtrl(
        deviceMap: rlUInt8_t,
        data: *mut rlInterChirpBlkCtrlCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetSubFrameStart(
        deviceMap: rlUInt8_t,
        data: *mut rlSubFrameStartCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfPhShiftCalibDataStore(
        deviceMap: rlUInt8_t,
        data: *mut rlPhShiftCalibrationData_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfPhShiftCalibDataRestore(
        deviceMap: rlUInt8_t,
        data: *mut rlPhShiftCalibrationData_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlGetRfDieId(deviceMap: rlUInt8_t, data: *mut rlRfDieIdCfg_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfGetEsmFault(deviceMap: rlUInt8_t, data: *mut rlBssEsmFault_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfGetCpuFault(deviceMap: rlUInt8_t, data: *mut rlCpuFault_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfApllSynthBwCtlConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRfApllSynthBwControl_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlSetPowerSaveModeConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlPowerSaveModeCfg_t,
    ) -> rlReturnVal_t;
}
#[doc = " \\brief"]
#[doc = " Digital monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonDigEnables {
    #[doc = " @brief  Bit: Dig Monitoring \\n"]
    #[doc = "0 Reserved \\n"]
    #[doc = "1 CR4 and VIM lockstep test of diagnostic \\n"]
    #[doc = "2 Reserved \\n"]
    #[doc = "3 VIM test (Not supported in 1st Gen devices, refer latest release note) \\n"]
    #[doc = "4 Reserved \\n"]
    #[doc = "5 Reserved \\n"]
    #[doc = "6 CRC test of diagnostic \\n"]
    #[doc = "7 RAMPGEN memory ECC test of diagnostic (Not supported in 1st Gen devices,"]
    #[doc = "refer latest release note) \\n"]
    #[doc = "8 DFE Parity test of diagnostic (RESERVED in xWR6x43 devices) \\n"]
    #[doc = "9 DFE memory ECC test of diagnostic \\n"]
    #[doc = "10 RAMPGEN lockstep test of diagnostic \\n"]
    #[doc = "11 FRC lockstep test of diagnostic \\n"]
    #[doc = "12 Reserved \\n"]
    #[doc = "13 Reserved \\n"]
    #[doc = "14 Reserved \\n"]
    #[doc = "15 Reserved \\n"]
    #[doc = "16 ESM test of diagnostic \\n"]
    #[doc = "17 DFE STC \\n"]
    #[doc = "18 Reserved \\n"]
    #[doc = "19 ATCM, BTCM ECC test of diagnostic \\n"]
    #[doc = "20 ATCM, BTCM parity test of diagnostic \\n"]
    #[doc = "21 Reserved \\n"]
    #[doc = "22 Reserved \\n"]
    #[doc = "23 Reserved \\n"]
    #[doc = "24 FFT test of diagnostic \\n"]
    #[doc = "25 RTI test of diagnostic \\n"]
    #[doc = "31:26 RESERVED \\n"]
    pub enMask: rlUInt32_t,
    #[doc = " @brief  Value    Definition \\n"]
    #[doc = "0     Production mode. Latent faults are tested and  any failures are reported \\n"]
    #[doc = "1     Characterization mode. Faults are injected and failures are reported"]
    #[doc = "which allows testing of the failure reporting path  \\n"]
    pub testMode: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonDigEnables() {
    assert_eq!(
        ::core::mem::size_of::<rlMonDigEnables>(),
        12usize,
        concat!("Size of: ", stringify!(rlMonDigEnables))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonDigEnables>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonDigEnables))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonDigEnables>())).enMask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonDigEnables),
            "::",
            stringify!(enMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonDigEnables>())).testMode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonDigEnables),
            "::",
            stringify!(testMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonDigEnables>())).reserved0 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonDigEnables),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonDigEnables>())).reserved1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonDigEnables),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonDigEnables>())).reserved2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonDigEnables),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type rlMonDigEnables_t = rlMonDigEnables;
#[doc = " \\brief"]
#[doc = " Digital monitoring latent fault reporting configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDigMonPeriodicConf {
    #[doc = " @brief  Value    Definition \\n"]
    #[doc = "0     Report is sent every monitoring period \\n"]
    #[doc = "1     Report is sent only on a failure \\n"]
    #[doc = "2     RESERVED \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  Bit     Monitoring \\n"]
    #[doc = "0      PERIODIC_CONFG_REGISTER_READ_EN \\n"]
    #[doc = "1      RESERVED \\n"]
    #[doc = "2      DFE_STC_EN \\n"]
    #[doc = "3      FRAME_TIMING_MONITORING_EN \\n"]
    #[doc = "31:4   RESERVED \\n"]
    pub periodicEnableMask: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlDigMonPeriodicConf() {
    assert_eq!(
        ::core::mem::size_of::<rlDigMonPeriodicConf>(),
        12usize,
        concat!("Size of: ", stringify!(rlDigMonPeriodicConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDigMonPeriodicConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlDigMonPeriodicConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDigMonPeriodicConf>())).reportMode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDigMonPeriodicConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDigMonPeriodicConf>())).reserved0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDigMonPeriodicConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDigMonPeriodicConf>())).reserved1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDigMonPeriodicConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDigMonPeriodicConf>())).periodicEnableMask as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDigMonPeriodicConf),
            "::",
            stringify!(periodicEnableMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDigMonPeriodicConf>())).reserved2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDigMonPeriodicConf),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type rlDigMonPeriodicConf_t = rlDigMonPeriodicConf;
#[doc = " \\brief"]
#[doc = " Analog monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlMonAnaEnables {
    #[doc = " @brief  Bit   Analog monitoring control \\n"]
    #[doc = "0   TEMPERATURE_MONITOR_EN \\n"]
    #[doc = "1   RX_GAIN_PHASE_MONITOR_EN \\n"]
    #[doc = "2   RX_NOISE_MONITOR_EN \\n"]
    #[doc = "3   RX_IFSTAGE_MONITOR_EN \\n"]
    #[doc = "4   TX0_POWER_MONITOR_EN \\n"]
    #[doc = "5   TX1_POWER_MONITOR_EN \\n"]
    #[doc = "6   TX2_POWER_MONITOR_EN \\n"]
    #[doc = "7   TX0_BALLBREAK_MONITOR_EN \\n"]
    #[doc = "8   TX1_BALLBREAK_MONITOR_EN \\n"]
    #[doc = "9   TX2_BALLBREAK_MONITOR_EN \\n"]
    #[doc = "10  TX_GAIN_PHASE_MONITOR_EN \\n"]
    #[doc = "11  TX0_BPM_MONITOR_EN \\n"]
    #[doc = "12  TX1_BPM_MONITOR_EN \\n"]
    #[doc = "13  TX2_BPM_MONITOR_EN \\n"]
    #[doc = "14  SYNTH_FREQ_MONITOR_LIVE_EN \\n"]
    #[doc = "15  EXTERNAL_ANALOG_SIGNALS_MONITOR_EN \\n"]
    #[doc = "16  INTERNAL_TX0_SIGNALS_MONITOR_EN \\n"]
    #[doc = "17  INTERNAL_TX1_SIGNALS_MONITOR_EN \\n"]
    #[doc = "18  INTERNAL_TX2_SIGNALS_MONITOR_EN \\n"]
    #[doc = "19  INTERNAL_RX_SIGNALS_MONITOR_EN \\n"]
    #[doc = "20  INTERNAL_PMCLKLO_SIGNALS_MONITOR_EN \\n"]
    #[doc = "21  INTERNAL_GPADC_SIGNALS_MONITOR_EN \\n"]
    #[doc = "22  PLL_CONTROL_VOLTAGE_MONITOR_EN \\n"]
    #[doc = "23  DCC_CLOCK_FREQ_MONITOR_EN \\n"]
    #[doc = "24  RX_IF_SATURATION_MONITOR_EN \\n"]
    #[doc = "25  RX_SIG_IMG_BAND_MONITORING_EN \\n"]
    #[doc = "26  RX_MIXER_INPUT_POWER_MONITOR \\n"]
    #[doc = "27  RESERVED \\n"]
    #[doc = "28  SYNTH_FREQ_MONITOR_NON_LIVE_EN \\n"]
    #[doc = "31:29   RESERVED \\n"]
    pub enMask: rlUInt32_t,
    #[doc = " @brief  LDO short circuit monitoring enable. There are no reports for these monitors. \\n"]
    #[doc = "If there is any fault, the asyncevent RL_RF_AE_ANALOG_FAULT_SB will be sent. \\n"]
    #[doc = "Bit    Description \\n"]
    #[doc = "b0     APLL LDO short circuit monitoring \\n"]
    #[doc = "0 - disable, 1 - enable \\n"]
    #[doc = "b1     SYNTH VCO LDO short circuit monitoring \\n"]
    #[doc = "0 - disable, 1 - enable \\n"]
    #[doc = "b2     PA LDO short circuit monitoring \\n"]
    #[doc = "0 - disable, 1 - enable \\n"]
    #[doc = "b31:3 RESERVED \\n"]
    #[doc = "@note : This feature is not supported in DFP 1.x (1st generation devices). Please"]
    #[doc = "refer latest DFP release note for more details. \\n"]
    pub ldoScEn: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlMonAnaEnables() {
    assert_eq!(
        ::core::mem::size_of::<rlMonAnaEnables>(),
        8usize,
        concat!("Size of: ", stringify!(rlMonAnaEnables))
    );
    assert_eq!(
        ::core::mem::align_of::<rlMonAnaEnables>(),
        4usize,
        concat!("Alignment of ", stringify!(rlMonAnaEnables))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonAnaEnables>())).enMask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonAnaEnables),
            "::",
            stringify!(enMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlMonAnaEnables>())).ldoScEn as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlMonAnaEnables),
            "::",
            stringify!(ldoScEn)
        )
    );
}
pub type rlMonAnaEnables_t = rlMonAnaEnables;
#[doc = " \\brief"]
#[doc = " Temperature sensor monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlTempMonConf {
    #[doc = " @brief  Value    Definition \\n"]
    #[doc = "0      Report is sent every monitoring period without threshold check \\n"]
    #[doc = "1      Report is send only upon a failure (after checking for thresholds) \\n"]
    #[doc = "2      Report is sent every monitoring period with threshold check \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  The temperatures read from near the sensors near the RF analog modules"]
    #[doc = "are compared against a minimum threshold. The comparison result is part"]
    #[doc = "of the monitoring report message (Error bit is set if any measurement"]
    #[doc = "is outside this (minimum, maximum) range).\\n"]
    #[doc = "1 LSB = 1 degree Celsius, signed number \\n"]
    #[doc = "Valid range: -99 degree Celsius to 199 degree Celsius \\n"]
    pub anaTempThreshMin: rlInt16_t,
    #[doc = " @brief  The temperatures read from near the sensors near the RF analog modules"]
    #[doc = "are compared against a maximum threshold. The comparison result is part"]
    #[doc = "of the monitoring report message (Error bit is set if any measurement"]
    #[doc = "is outside this (minimum, maximum) range). \\n"]
    #[doc = "1 LSB = 1 degree Celsius, signed number \\n"]
    #[doc = "Valid range: -99 degree Celsius to 199 degree Celsius \\n"]
    pub anaTempThreshMax: rlInt16_t,
    #[doc = " @brief  The temperatures read from near the sensor near the digital module are"]
    #[doc = "compared against a minimum threshold. The comparison result is part of"]
    #[doc = "the monitoring report message (Error bit is set if any measurement is"]
    #[doc = "outside this (minimum, maximum) range). \\n"]
    #[doc = "1 LSB = 1 degree Celsius, signed number \\n"]
    #[doc = "Valid range: -99 degree Celsius to 199 degree Celsius \\n"]
    #[doc = "In xWR6x43, value 0 disables the monitor threshold check"]
    #[doc = "(together with DIG_TEMP_THRESH_MAX=0) \\n"]
    pub digTempThreshMin: rlInt16_t,
    #[doc = " @brief  The temperatures read from near the sensor near the digital module are"]
    #[doc = "compared against a maximum threshold. The comparison result is part of"]
    #[doc = "the monitoring report message (Error bit is set if any measurement is"]
    #[doc = "outside this (minimum, maximum) range). \\n"]
    #[doc = "1 LSB = 1 degree Celsius, signed number \\n"]
    #[doc = "Valid range: -99 degree Celsius to 199 degree Celsius \\n"]
    #[doc = "In xWR6x43, value 0 disables the monitor threshold check"]
    #[doc = "(together with DIG_TEMP_THRESH_MIN=0) \\n"]
    pub digTempThreshMax: rlInt16_t,
    #[doc = " @brief  The maximum difference across temperatures read from all the enabled"]
    #[doc = "sensors is compared against this threshold.The comparison result is part"]
    #[doc = "of the monitoring report message(Error bit is set if the measured difference"]
    #[doc = "exceeds this field). \\n"]
    #[doc = "1 LSB = 1o Celsius, unsigned number \\n"]
    #[doc = "Valid range: 0 degree Celsius to 100 degree Celsius \\n"]
    #[doc = "In xWR6x43, digital temperature sensors can be excluded from this check by"]
    #[doc = "setting DIG_TEMP_THRESH_MIN and DIG_TEMP_THRESH_MAX to value 0. \\n"]
    pub tempDiffThresh: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlTempMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlTempMonConf>(),
        20usize,
        concat!("Size of: ", stringify!(rlTempMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlTempMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlTempMonConf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTempMonConf>())).reportMode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTempMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTempMonConf>())).reserved0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTempMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTempMonConf>())).anaTempThreshMin as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTempMonConf),
            "::",
            stringify!(anaTempThreshMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTempMonConf>())).anaTempThreshMax as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTempMonConf),
            "::",
            stringify!(anaTempThreshMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTempMonConf>())).digTempThreshMin as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTempMonConf),
            "::",
            stringify!(digTempThreshMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTempMonConf>())).digTempThreshMax as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTempMonConf),
            "::",
            stringify!(digTempThreshMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTempMonConf>())).tempDiffThresh as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTempMonConf),
            "::",
            stringify!(tempDiffThresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTempMonConf>())).reserved1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTempMonConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTempMonConf>())).reserved2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTempMonConf),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type rlTempMonConf_t = rlTempMonConf;
#[doc = " \\brief"]
#[doc = " RX gain and phase monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRxGainPhaseMonConf {
    #[doc = " @brief  This field indicates the profile Index for which this configuration applies."]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  This field indicates the RF frequencies inside the profile's RF band at which to"]
    #[doc = "measure the required parameters. When each bit in this field is set, the"]
    #[doc = "measurement at the corresponding RF frequency is enabled w.r.t. the profile's"]
    #[doc = "RF band. \\n"]
    #[doc = "Bit number  RF frequency                        RF name \\n"]
    #[doc = "0       Lowest RF frequency                 RF1 \\n"]
    #[doc = "in profile's sweep bandwidth \\n"]
    #[doc = "1       Center RF frequency in profile's    RF2 \\n"]
    #[doc = "sweep bandwidth \\n"]
    #[doc = "2       Highest RF frequency in             RF3 \\n"]
    #[doc = "profile's sweep bandwidth \\n"]
    #[doc = "The RF name column is mentioned here to set the convention for the"]
    #[doc = "purpose of reporting and describing many monitoring packets. \\n"]
    pub rfFreqBitMask: rlUInt8_t,
    #[doc = " @brief  Value       Definition \\n"]
    #[doc = "0          Report is sent every monitoring period without threshold check \\n"]
    #[doc = "1          Report is send only upon a failure (after checking for thresholds) \\n"]
    #[doc = "@note : It is recommended not to use quiet mode, as Host has to compute"]
    #[doc = "actual RX gain and need to monitor Noise power to detect"]
    #[doc = "presence of interference. \\n"]
    #[doc = "2          Report is sent every monitoring period with threshold check  \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  Value     Definition \\n"]
    #[doc = "0       TX0 is used for generating loopback signal for RX gain measurement \\n"]
    #[doc = "1       TX1 is used for generating loopback signal for RX gain measurement. \\n"]
    pub txSel: rlUInt8_t,
    #[doc = " @brief  The magnitude of difference between the programmed and measured RX gain for each \\n"]
    #[doc = "enabled channel at each enabled RF frequency, is compared against this \\n"]
    #[doc = "threshold. The comparison result is part of the monitoring report message \\n"]
    #[doc = "(Error bit is set if any measurement is above this threshold). Before the \\n"]
    #[doc = "comparison, the measured gains for each RF and RX are adjusted by subtracting \\n"]
    #[doc = "the offset given in the RX_GAIN_MISMATCH_OFFSET_VALUE field \\n"]
    #[doc = "1 LSB = 0.1 dB \\n"]
    #[doc = "Valid range: 0 to 65535 (0 to 6553dB) \\n"]
    pub rxGainAbsThresh: rlUInt16_t,
    #[doc = " @brief  The magnitude of difference between measured RX gains across the enabled channels \\n"]
    #[doc = "at each enabled RF frequency is compared against this threshold. The comparison \\n"]
    #[doc = "result is part of the monitoring report message (Error bit is set if the \\n"]
    #[doc = "measurement is above this threshold). Before the comparison, the measured gains \\n"]
    #[doc = "for each RF and RX are adjusted by subtracting the offset given in the \\n"]
    #[doc = "RX_GAIN_MISMATCH_OFFSET_VALUE field. \\n"]
    #[doc = "1 LSB = 0.1 dB \\n"]
    #[doc = "Valid range: 0 to 65535 (0 to 6553dB) \\n"]
    pub rxGainMismatchErrThresh: rlUInt16_t,
    #[doc = " @brief  The magnitude of measured RX gain flatness error, for each enabled channel, is \\n"]
    #[doc = "compared against this threshold. The flatness error for a channel is defined as \\n"]
    #[doc = "the peak to peak variation across RF frequencies. The comparison result is part \\n"]
    #[doc = "of the monitoring report message (Error bit is set if any measurement is above \\n"]
    #[doc = "this threshold). Before the comparison, the measured gains for each RF and RX \\n"]
    #[doc = "are adjusted by subtracting the offset given in the \\n"]
    #[doc = "RX_GAIN_MISMATCH_OFFSET_VALUE field. \\n"]
    #[doc = "1 LSB = 0.1 dB \\n"]
    #[doc = "Valid range: 0 to 65535 (0 to 6553dB) \\n"]
    #[doc = "This flatness check is applicable only if multiple RF Frequencies are enabled,  \\n"]
    #[doc = "i.e., RF_FREQ_BITMASK has bit numbers 0,1,2 set \\n"]
    pub rxGainFlatnessErrThresh: rlUInt16_t,
    #[doc = " @brief  The magnitude of measured RX phase mismatch across the enabled channels at each \\n"]
    #[doc = "enabled RF frequency is compared against this threshold. The comparison result \\n"]
    #[doc = "is part of the monitoring report message (Error bit is set if any measurement \\n"]
    #[doc = "is above this threshold). Before the comparison, the measured phases for each \\n"]
    #[doc = "RF and RX are adjusted by subtracting the offset given in the \\n"]
    #[doc = "RX_PHASE_MISMATCH_OFFSET_VALUE field. \\n"]
    #[doc = "1 LSB = 360(degree) / 2^16 . \\n"]
    #[doc = "Valid range: corresponding to 0 degree to 359.9 degree. \\n"]
    pub rxGainPhaseMismatchErrThresh: rlUInt16_t,
    #[doc = " @brief  The offsets to be subtracted from the measured RX gain for each RX and RF before \\n"]
    #[doc = "the relevant threshold comparisons are given here. \\n"]
    #[doc = "Byte numbers corresponding to different RX and RF, in this field are \\n"]
    #[doc = "here: \\n"]
    #[doc = "RF1     RF2     RF3 \\n"]
    #[doc = "RX0    [1:0]   [9:8]    [17:16] \\n"]
    #[doc = "RX1    [3:2]   [11:10]  [19:18] \\n"]
    #[doc = "RX2    [5:4]   [13:12]  [21:20] \\n"]
    #[doc = "RX3    [7:6]   [15:14]  [23:22] \\n"]
    #[doc = "1 LSB = 0.1 dB, signed number \\n"]
    #[doc = "Only the entries of enabled RF Frequencies and enabled RX channels are \\n"]
    #[doc = "considered. \\n"]
    pub rxGainMismatchOffsetVal: [[rlInt16_t; 3usize]; 4usize],
    #[doc = " @brief  The offsets to be subtracted from the measured RX phase for each RX and RF \\n"]
    #[doc = "before the relevant threshold comparisons are given here. Byte numbers \\n"]
    #[doc = "corresponding to different RX and RF, in this field are here: \\n"]
    #[doc = "RF1       RF2       RF3 \\n"]
    #[doc = "RX0     [1:0]     [9:8]     [17:16] \\n"]
    #[doc = "RX1     [3:2]     [11:10]   [19:18] \\n"]
    #[doc = "RX2     [5:4]     [13:12]   [21:20] \\n"]
    #[doc = "RX3     [7:6]     [15:14]   [23:22] \\n"]
    #[doc = "1 LSB = 360(degree) / 2^16 , unsigned number \\n"]
    #[doc = "Only the entries of enabled RF Frequencies and enabled RX channels are \\n"]
    #[doc = "considered. \\n"]
    pub rxGainPhaseMismatchOffsetVal: [[rlUInt16_t; 3usize]; 4usize],
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRxGainPhaseMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlRxGainPhaseMonConf>(),
        68usize,
        concat!("Size of: ", stringify!(rlRxGainPhaseMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRxGainPhaseMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRxGainPhaseMonConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxGainPhaseMonConf>())).profileIndx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainPhaseMonConf),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxGainPhaseMonConf>())).rfFreqBitMask as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainPhaseMonConf),
            "::",
            stringify!(rfFreqBitMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxGainPhaseMonConf>())).reportMode as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainPhaseMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxGainPhaseMonConf>())).txSel as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainPhaseMonConf),
            "::",
            stringify!(txSel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxGainPhaseMonConf>())).rxGainAbsThresh as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainPhaseMonConf),
            "::",
            stringify!(rxGainAbsThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxGainPhaseMonConf>())).rxGainMismatchErrThresh as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainPhaseMonConf),
            "::",
            stringify!(rxGainMismatchErrThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxGainPhaseMonConf>())).rxGainFlatnessErrThresh as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainPhaseMonConf),
            "::",
            stringify!(rxGainFlatnessErrThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxGainPhaseMonConf>())).rxGainPhaseMismatchErrThresh
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainPhaseMonConf),
            "::",
            stringify!(rxGainPhaseMismatchErrThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxGainPhaseMonConf>())).rxGainMismatchOffsetVal as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainPhaseMonConf),
            "::",
            stringify!(rxGainMismatchOffsetVal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxGainPhaseMonConf>())).rxGainPhaseMismatchOffsetVal
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainPhaseMonConf),
            "::",
            stringify!(rxGainPhaseMismatchOffsetVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxGainPhaseMonConf>())).reserved0 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainPhaseMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxGainPhaseMonConf>())).reserved1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxGainPhaseMonConf),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlRxGainPhaseMonConf_t = rlRxGainPhaseMonConf;
#[doc = " \\brief"]
#[doc = " RX noise monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRxNoiseMonConf {
    #[doc = " @brief  This field indicates the profile Index for which this configuration applies."]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  This field indicates the exact RF frequencies inside the profile's RF band at \\n"]
    #[doc = "which to measure the required parameters. When each bit in this field is set, \\n"]
    #[doc = "the measurement at the corresponding RF frequency is enabled w.r.t. the \\n"]
    #[doc = "profile's RF band. \\n"]
    #[doc = "Bit number   RF frequency                    RF name \\n"]
    #[doc = "0        Lowest RF frequency in          RF1 \\n"]
    #[doc = "profile's sweep bandwidth \\n"]
    #[doc = "1        Center RF frequency in          RF2 \\n"]
    #[doc = "profile's sweep bandwidth \\n"]
    #[doc = "2        Highest RF frequency in         RF3 \\n"]
    #[doc = "profile's sweep bandwidth \\n"]
    #[doc = "The RF name column is mentioned here to set the convention for the purpose of \\n"]
    #[doc = "reporting and describing many monitoring packets. \\n"]
    pub rfFreqBitMask: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  Value        Definition \\n"]
    #[doc = "0          Report is sent every monitoring period without threshold check \\n"]
    #[doc = "1          Report is send only upon a failure (after checking for thresholds) \\n"]
    #[doc = "2          Report is sent every monitoring period with threshold check  \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt8_t,
    #[doc = " @brief  The measured RX input referred noise figure at the enabled RF frequencies, for \\n"]
    #[doc = "all channels, is compared against this threshold. The comparison result is part \\n"]
    #[doc = "of the monitoring report message (Error bit is set if any measurement is above \\n"]
    #[doc = "this threshold). \\n"]
    #[doc = "1 LSB = 0.1 dB \\n"]
    #[doc = "Valid range: 0 to 65535 (0 to 6553dB) \\n"]
    pub noiseThresh: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRxNoiseMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlRxNoiseMonConf>(),
        12usize,
        concat!("Size of: ", stringify!(rlRxNoiseMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRxNoiseMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRxNoiseMonConf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxNoiseMonConf>())).profileIndx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxNoiseMonConf),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxNoiseMonConf>())).rfFreqBitMask as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxNoiseMonConf),
            "::",
            stringify!(rfFreqBitMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxNoiseMonConf>())).reserved0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxNoiseMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxNoiseMonConf>())).reportMode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxNoiseMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxNoiseMonConf>())).reserved1 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxNoiseMonConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxNoiseMonConf>())).noiseThresh as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxNoiseMonConf),
            "::",
            stringify!(noiseThresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxNoiseMonConf>())).reserved2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxNoiseMonConf),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type rlRxNoiseMonConf_t = rlRxNoiseMonConf;
#[doc = " \\brief"]
#[doc = " RX IF stage monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRxIfStageMonConf {
    #[doc = " @brief  This field indicates the profile Index for which this configuration applies."]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  Value       Definition \\n"]
    #[doc = "0        Report is sent every monitoring period without threshold check \\n"]
    #[doc = "1        Report is send only upon a failure (after checking for thresholds) \\n"]
    #[doc = "2        Report is sent every monitoring period with threshold check. \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  The absolute values of RX IF HPF cutoff percentage frequency errors are \\n"]
    #[doc = "compared against the corresponding thresholds given in this field. The \\n"]
    #[doc = "comparison results are part of the monitoring report message (Error bit is set \\n"]
    #[doc = "if the absolute value of the errors exceeds respective thresholds). \\n"]
    #[doc = "1 LSB = 1%, unsigned number \\n"]
    #[doc = "Valid range: 1% to 128% \\n"]
    pub hpfCutoffErrThresh: rlUInt16_t,
    #[doc = " @brief  The absolute values of RX IF LPF cutoff percentage frequency errors are compared \\n"]
    #[doc = "against the corresponding thresholds given in this field. The comparison \\n"]
    #[doc = "results are part of the monitoring report message (Error bit is set if the \\n"]
    #[doc = "absolute value of the errors exceeds respective thresholds). \\n"]
    #[doc = "1 LSB = 1%, unsigned number \\n"]
    #[doc = "Valid range: 1% to 128% \\n"]
    #[doc = "@note 1: This feature is not supported in AWR1243, xWR1443, xWR1642 and \\n"]
    #[doc = "xWR1843 devices. \\n"]
    #[doc = "@note 2: This feature is not supported in this release. Please refer latest \\n"]
    #[doc = "DFP release note for more details. \\n"]
    pub lpfCutoffErrThresh: rlUInt16_t,
    #[doc = " @brief  The absolute deviation of RX IFA Gain from the expected gain for each enabled RX \\n"]
    #[doc = "channel is compared against the thresholds given in this field. The comparison \\n"]
    #[doc = "result is part of the monitoring report message (Error bit is set if the \\n"]
    #[doc = "absolute \\n"]
    #[doc = "value of the errors exceeds respective thresholds). \\n"]
    #[doc = "1 LSB = 0.1dB, unsigned number \\n"]
    #[doc = "Valid range: 0 to 65535 (0 to 6553dB) \\n"]
    pub ifaGainErrThresh: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRxIfStageMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlRxIfStageMonConf>(),
        16usize,
        concat!("Size of: ", stringify!(rlRxIfStageMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRxIfStageMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRxIfStageMonConf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxIfStageMonConf>())).profileIndx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxIfStageMonConf),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxIfStageMonConf>())).reportMode as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxIfStageMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxIfStageMonConf>())).reserved0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxIfStageMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxIfStageMonConf>())).reserved1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxIfStageMonConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxIfStageMonConf>())).hpfCutoffErrThresh as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxIfStageMonConf),
            "::",
            stringify!(hpfCutoffErrThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxIfStageMonConf>())).lpfCutoffErrThresh as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxIfStageMonConf),
            "::",
            stringify!(lpfCutoffErrThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxIfStageMonConf>())).ifaGainErrThresh as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxIfStageMonConf),
            "::",
            stringify!(ifaGainErrThresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxIfStageMonConf>())).reserved2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxIfStageMonConf),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type rlRxIfStageMonConf_t = rlRxIfStageMonConf;
#[doc = " \\brief"]
#[doc = " TX power monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlTxPowMonConf {
    #[doc = " @brief  This field indicates the profile Index for which this configuration applies."]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  This field indicates the exact RF frequencies inside the profile's RF band at \\n"]
    #[doc = "which to measure the required parameters. When each bit in this field is set, \\n"]
    #[doc = "the measurement at the corresponding RF frequency is enabled w.r.t. the \\n"]
    #[doc = "profile's RF band. \\n"]
    #[doc = ""]
    #[doc = "Bit number      RF frequency                            RF \\n"]
    #[doc = "0           Lowest RF frequency in profile's        RF1 \\n"]
    #[doc = "sweep bandwidth \\n"]
    #[doc = "1           Center RF frequency in profile's        RF2 \\n"]
    #[doc = "sweep bandwidth \\n"]
    #[doc = "2           Highest RF frequency in profile's       RF3 \\n"]
    #[doc = "sweep bandwidth \\n"]
    #[doc = "The RF Name column is mentioned here to set the convention for the purpose \\n"]
    #[doc = "of reporting and describing many monitoring packets. \\n"]
    pub rfFreqBitMask: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt16_t,
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt8_t,
    #[doc = " @brief  The magnitude of difference between the programmed and measured TX power for \\n"]
    #[doc = "each enabled channel at each enabled RF frequency, is compared against this \\n"]
    #[doc = "threshold. The comparison result is part of the monitoring report message(Error \\n"]
    #[doc = "bit is set if any measurement is above this threshold). \\n"]
    #[doc = "1 LSB = 0.1 dB \\n"]
    #[doc = "Valid range: 0 to 65535 (0 to 6553dB) \\n"]
    pub txPowAbsErrThresh: rlUInt16_t,
    #[doc = " @brief  The magnitude of measured TX power flatness error, for each enabled channel, is \\n"]
    #[doc = "compared against this threshold. The flatness error for a channel is defined as \\n"]
    #[doc = "the peak to peak variation across RF frequencies. The comparison result is part \\n"]
    #[doc = "of the monitoring report message(Error bit is set if any measurement is above \\n"]
    #[doc = "this threshold). \\n"]
    #[doc = "1 LSB = 0.1 dB \\n"]
    #[doc = "Valid range: 0 to 65535 (0 to 6553dB) \\n"]
    #[doc = "This flatness check is applicable only if multiple RF Frequencies are enabled. \\n"]
    pub txPowFlatnessErrThresh: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved3: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlTxPowMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlTxPowMonConf>(),
        16usize,
        concat!("Size of: ", stringify!(rlTxPowMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlTxPowMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlTxPowMonConf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxPowMonConf>())).profileIndx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxPowMonConf),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxPowMonConf>())).rfFreqBitMask as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxPowMonConf),
            "::",
            stringify!(rfFreqBitMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxPowMonConf>())).reserved0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxPowMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxPowMonConf>())).reportMode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxPowMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxPowMonConf>())).reserved1 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxPowMonConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxPowMonConf>())).txPowAbsErrThresh as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxPowMonConf),
            "::",
            stringify!(txPowAbsErrThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxPowMonConf>())).txPowFlatnessErrThresh as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxPowMonConf),
            "::",
            stringify!(txPowFlatnessErrThresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxPowMonConf>())).reserved2 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxPowMonConf),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxPowMonConf>())).reserved3 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxPowMonConf),
            "::",
            stringify!(reserved3)
        )
    );
}
pub type rlTxPowMonConf_t = rlTxPowMonConf;
#[doc = " \\brief"]
#[doc = " TX power monitoring configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlAllTxPowMonConf {
    #[doc = " @brief  Power Monitoring Configuration for Tx0"]
    pub tx0PowrMonCfg: *mut rlTxPowMonConf_t,
    #[doc = " @brief  Power Monitoring Configuration for Tx1"]
    pub tx1PowrMonCfg: *mut rlTxPowMonConf_t,
    #[doc = " @brief  Power Monitoring Configuration for Tx2"]
    pub tx2PowrMonCfg: *mut rlTxPowMonConf_t,
}
#[test]
fn bindgen_test_layout_rlAllTxPowMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlAllTxPowMonConf>(),
        12usize,
        concat!("Size of: ", stringify!(rlAllTxPowMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlAllTxPowMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlAllTxPowMonConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAllTxPowMonConf>())).tx0PowrMonCfg as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAllTxPowMonConf),
            "::",
            stringify!(tx0PowrMonCfg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAllTxPowMonConf>())).tx1PowrMonCfg as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAllTxPowMonConf),
            "::",
            stringify!(tx1PowrMonCfg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAllTxPowMonConf>())).tx2PowrMonCfg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAllTxPowMonConf),
            "::",
            stringify!(tx2PowrMonCfg)
        )
    );
}
impl Default for rlAllTxPowMonConf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlAllTxPowMonConf_t = rlAllTxPowMonConf;
#[doc = " \\brief"]
#[doc = " TX ballbreak monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlTxBallbreakMonConf {
    #[doc = " @brief  Value    Definition \\n"]
    #[doc = "0      Report is sent every monitoring period without threshold check \\n"]
    #[doc = "1      Report is send only upon a failure (after checking for thresholds) \\n"]
    #[doc = "2      Report is sent every monitoring period with threshold check. \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    pub txReflCoeffMagThresh: rlInt16_t,
    #[doc = " @brief  For xWR1xxx devices: \\n"]
    #[doc = "This field is reserved. Set to 0x0. \\n"]
    #[doc = "For xWR6x43 devices: \\n"]
    #[doc = "Start frequency of the monitoring chirp. \\n"]
    #[doc = "For 60GHz Devices (57GHz to 63.8Ghz):"]
    #[doc = "1 LSB = 2.7e9/2^26 = 40.233 Hz \\n"]
    #[doc = "Valid range: Only even numbers from 0x5471C71C to 0x5E84BDA1 \\n"]
    pub monStartFreqConst: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlTxBallbreakMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlTxBallbreakMonConf>(),
        12usize,
        concat!("Size of: ", stringify!(rlTxBallbreakMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlTxBallbreakMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlTxBallbreakMonConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxBallbreakMonConf>())).reportMode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBallbreakMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxBallbreakMonConf>())).reserved0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBallbreakMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxBallbreakMonConf>())).txReflCoeffMagThresh as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBallbreakMonConf),
            "::",
            stringify!(txReflCoeffMagThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxBallbreakMonConf>())).monStartFreqConst as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBallbreakMonConf),
            "::",
            stringify!(monStartFreqConst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxBallbreakMonConf>())).reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBallbreakMonConf),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlTxBallbreakMonConf_t = rlTxBallbreakMonConf;
#[doc = " \\brief"]
#[doc = " TX ballbreak monitoring configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlAllTxBallBreakMonCfg {
    #[doc = " @brief  Tx ballbreak monitoring config for Tx0"]
    pub tx0BallBrkMonCfg: *mut rlTxBallbreakMonConf_t,
    #[doc = " @brief  Tx ballbreak monitoring config for Tx1"]
    pub tx1BallBrkMonCfg: *mut rlTxBallbreakMonConf_t,
    #[doc = " @brief  Tx ballbreak monitoring config for Tx2."]
    pub tx2BallBrkMonCfg: *mut rlTxBallbreakMonConf_t,
}
#[test]
fn bindgen_test_layout_rlAllTxBallBreakMonCfg() {
    assert_eq!(
        ::core::mem::size_of::<rlAllTxBallBreakMonCfg>(),
        12usize,
        concat!("Size of: ", stringify!(rlAllTxBallBreakMonCfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rlAllTxBallBreakMonCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rlAllTxBallBreakMonCfg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAllTxBallBreakMonCfg>())).tx0BallBrkMonCfg as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAllTxBallBreakMonCfg),
            "::",
            stringify!(tx0BallBrkMonCfg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAllTxBallBreakMonCfg>())).tx1BallBrkMonCfg as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAllTxBallBreakMonCfg),
            "::",
            stringify!(tx1BallBrkMonCfg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAllTxBallBreakMonCfg>())).tx2BallBrkMonCfg as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAllTxBallBreakMonCfg),
            "::",
            stringify!(tx2BallBrkMonCfg)
        )
    );
}
impl Default for rlAllTxBallBreakMonCfg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlAllTxBallBreakMonCfg_t = rlAllTxBallBreakMonCfg;
#[doc = " \\brief"]
#[doc = " TX gain and phase mismatch monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlTxGainPhaseMismatchMonConf {
    #[doc = " @brief  This field indicates the Profile Index for which this monitoring configuration \\n"]
    #[doc = "applies. The TX settings corresponding to this profile index are used during \\n"]
    #[doc = "the monitoring. The RX gain used in this measurement may differ from the given \\n"]
    #[doc = "profile's RX gain. \\n"]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  This field indicates the exact RF frequencies inside the profile's RF band at \\n"]
    #[doc = "which to measure the required parameters. When each bit in this field is set, \\n"]
    #[doc = "the measurement at the corresponding RF frequency is enabled wrt the profile's \\n"]
    #[doc = "RF band. \\n"]
    #[doc = "Bit         RF frequency                            RF \\n"]
    #[doc = "number                                              name \\n"]
    #[doc = "0           Lowest RF frequency in profile's        RF1 \\n"]
    #[doc = "sweep bandwidth \\n"]
    #[doc = "1           Center RF frequency in profile's        RF2 \\n"]
    #[doc = "sweep bandwidth \\n"]
    #[doc = "2           Highest RF frequency in profile's       RF3 \\n"]
    #[doc = "sweep bandwidth \\n"]
    #[doc = "The RF Name column is mentioned here to set the convention for the purpose of \\n"]
    #[doc = "reporting and describing many monitoring packets. \\n"]
    pub rfFreqBitMask: rlUInt8_t,
    #[doc = " @brief  This field indicates the TX channels that should be compared for gain and phase \\n"]
    #[doc = "balance. Setting the corresponding bit to 1 enables that channel for imbalance \\n"]
    #[doc = "measurement \\n"]
    #[doc = "Bit number     TX Channel \\n"]
    #[doc = "0          TX0 \\n"]
    #[doc = "1          TX1 \\n"]
    #[doc = "2          TX2 \\n"]
    pub txEn: rlUInt8_t,
    #[doc = " @brief  This field indicates the RX channels that should be enabled for TX to RX loopback"]
    #[doc = "measurement. Setting the corresponding bit to 1 enables that channel for imbalance"]
    #[doc = "measurement."]
    #[doc = "Bit   RX Channel"]
    #[doc = "0    RX0"]
    #[doc = "1    RX1"]
    #[doc = "2    RX2"]
    #[doc = "3    RX3"]
    pub rxEn: rlUInt8_t,
    #[doc = " @brief  Value     Definition \\n"]
    #[doc = "0       Report is sent every monitoring period without threshold check \\n"]
    #[doc = "1       Report is send only upon a failure (after checking for thresholds) \\n"]
    #[doc = "2       Report is sent every monitoring period with threshold check. \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  The magnitude of difference between measured TX powers across the enabled \\n"]
    #[doc = "channels at each enabled RF frequency is compared against this threshold. The \\n"]
    #[doc = "comparison result is part of the monitoring report message(Error bit is set if \\n"]
    #[doc = "the measurement is above this threshold). Before the comparison, the measured \\n"]
    #[doc = "gains for each RF and RX are adjusted by subtracting the offset given in the \\n"]
    #[doc = "TX_GAIN_MISMATCH_OFFSET_VALUE field. \\n"]
    #[doc = "1 LSB = 0.1dB, signed number \\n"]
    #[doc = "Valid range: 0 to 65535 (0 to 6553dB) \\n"]
    pub txGainMismatchThresh: rlInt16_t,
    #[doc = " @brief  The magnitude of measured TX phase mismatch across the enabled channels at each \\n"]
    #[doc = "enabled RF frequency is compared against this threshold. The comparison result \\n"]
    #[doc = "is part of the monitoring report message (Error bit is set if any measurement \\n"]
    #[doc = "is above this threshold). Before the comparison, the measured gains for each RF \\n"]
    #[doc = "and RX are adjusted by subtracting the offset given in the \\n"]
    #[doc = "TX_PHASE_MISMATCH_OFFSET_VALUE field. \\n"]
    #[doc = "1 LSB = 360(degree)/ 2^16 , unsigned number \\n"]
    #[doc = "Valid range: corresponding to 0 degree to 359.9 degree. \\n"]
    pub txPhaseMismatchThresh: rlUInt16_t,
    #[doc = " @brief  The offsets to be subtracted from the measured TX gain for each TX and RF before \\n"]
    #[doc = "the relevant threshold comparisons are given here. Byte numbers corresponding \\n"]
    #[doc = "to different RX and RF, in this field are here: \\n"]
    #[doc = "RF1      RF2        RF3 \\n"]
    #[doc = "TX0     [1:0]    [7:6]      [13:12] \\n"]
    #[doc = "TX1     [3:2]    [9:8]      [15:14] \\n"]
    #[doc = "TX2     [5:4]    [11:10]    [17:16] \\n"]
    #[doc = "1 LSB = 0.1 dB \\n"]
    #[doc = "Only the entries of enabled RF Frequencies and enabled TX \\n"]
    #[doc = "channels are considered. \\n"]
    pub txGainMismatchOffsetVal: [[rlUInt16_t; 3usize]; 3usize],
    #[doc = " @brief  The offsets to be subtracted from the measured TX phase for each TX and RF before \\n"]
    #[doc = "the  \\n"]
    #[doc = "relevant threshold comparisons are given here. Byte numbers corresponding to  \\n"]
    #[doc = "different RX and RF, in this field are here: \\n"]
    #[doc = "RF1      RF2      RF3 \\n"]
    #[doc = "TX0     [1:0]    [7:6]    [13:12] \\n"]
    #[doc = "TX1     [3:2]    [9:8]    [15:14] \\n"]
    #[doc = "TX2     [5:4]    [11:10]  [17:16] \\n"]
    #[doc = "1 LSB = 360(degree)/216. \\n"]
    #[doc = "Only the entries of enabled RF Frequencies and enabled TX channels \\n"]
    #[doc = "are considered. \\n"]
    pub txPhaseMismatchOffsetVal: [[rlUInt16_t; 3usize]; 3usize],
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlTxGainPhaseMismatchMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlTxGainPhaseMismatchMonConf>(),
        52usize,
        concat!("Size of: ", stringify!(rlTxGainPhaseMismatchMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlTxGainPhaseMismatchMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlTxGainPhaseMismatchMonConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainPhaseMismatchMonConf>())).profileIndx as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainPhaseMismatchMonConf),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainPhaseMismatchMonConf>())).rfFreqBitMask as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainPhaseMismatchMonConf),
            "::",
            stringify!(rfFreqBitMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainPhaseMismatchMonConf>())).txEn as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainPhaseMismatchMonConf),
            "::",
            stringify!(txEn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainPhaseMismatchMonConf>())).rxEn as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainPhaseMismatchMonConf),
            "::",
            stringify!(rxEn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainPhaseMismatchMonConf>())).reportMode as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainPhaseMismatchMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainPhaseMismatchMonConf>())).reserved0 as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainPhaseMismatchMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainPhaseMismatchMonConf>())).txGainMismatchThresh
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainPhaseMismatchMonConf),
            "::",
            stringify!(txGainMismatchThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainPhaseMismatchMonConf>())).txPhaseMismatchThresh
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainPhaseMismatchMonConf),
            "::",
            stringify!(txPhaseMismatchThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainPhaseMismatchMonConf>())).txGainMismatchOffsetVal
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainPhaseMismatchMonConf),
            "::",
            stringify!(txGainMismatchOffsetVal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainPhaseMismatchMonConf>())).txPhaseMismatchOffsetVal
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainPhaseMismatchMonConf),
            "::",
            stringify!(txPhaseMismatchOffsetVal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainPhaseMismatchMonConf>())).reserved1 as *const _ as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainPhaseMismatchMonConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxGainPhaseMismatchMonConf>())).reserved2 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxGainPhaseMismatchMonConf),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type rlTxGainPhaseMismatchMonConf_t = rlTxGainPhaseMismatchMonConf;
#[doc = " \\brief"]
#[doc = " TX BPM monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlTxBpmMonConf {
    #[doc = " @brief  This field indicates the Profile Index for which this configuration applies."]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  This field indicates the phase shifter monitoring configuration. \\n"]
    #[doc = "Bit     Definition \\n"]
    #[doc = "5:0     Phase shifter monitoring increment value \\n"]
    #[doc = "1 LSB = 5.625 degree \\n"]
    #[doc = "6       Phase shifter monitoring auto increment enabled. On each FTTI phase shift \\n"]
    #[doc = "value increment by mentioned increment value at bit 0:5 \\n"]
    #[doc = "7       Phase shifter monitoring enabled \\n"]
    #[doc = "@note : Phase shifter monitoring control is not supported in this release for all"]
    #[doc = "devices. This is a RESERVED field and should be set to 0. \\n"]
    pub phaseShifterMonCnfg: rlUInt8_t,
    #[doc = " @brief  Phase1 of the phase shifter of TX which needs to be monitored"]
    #[doc = "1 LSB = 5.625 degree"]
    pub phaseShifterMon1: rlUInt8_t,
    #[doc = " @brief  Phase2 of the phase shifter of TX which needs to be monitored"]
    #[doc = "1 LSB = 5.625 degree"]
    pub phaseShifterMon2: rlUInt8_t,
    #[doc = " @brief  Value      Definition \\n"]
    #[doc = "0       Report is sent every monitoring period without threshold check \\n"]
    #[doc = "1       Report is send only upon a failure (after checking for thresholds) \\n"]
    #[doc = "2       Report is sent every monitoring period with threshold check. \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  This field indicates the RX channels that should be enabled for TX to RX loopback"]
    #[doc = "measurement. Setting the corresponding bit to 1 enables that channel for imbalance"]
    #[doc = "measurement."]
    #[doc = "Bit   RX Channel"]
    #[doc = "0    RX0"]
    #[doc = "1    RX1"]
    #[doc = "2    RX2"]
    #[doc = "3    RX3"]
    pub rxEn: rlUInt8_t,
    #[doc = " @brief  The deviation of the TX output phase difference between the two BPM settings from \\n"]
    #[doc = "the ideal 180o is compared against the threshold given here. The comparison \\n"]
    #[doc = "result is part of the monitoring report message (Error bit is set if the \\n"]
    #[doc = "measurement is lower than this threshold, with the units of both quantities \\n"]
    #[doc = "being the same). \\n"]
    #[doc = "1 LSB = 360(degree) /2^16. \\n"]
    #[doc = "Valid range: corresponding 0 degree to 359.9 degree \\n"]
    pub txBpmPhaseErrThresh: rlUInt16_t,
    #[doc = " @brief  The deviation of the TX output amplitude difference between the two BPM settings \\n"]
    #[doc = "is compared against the threshold given here. The comparison result is part of \\n"]
    #[doc = "the monitoring report message (Error bit is set if the measurement is lower \\n"]
    #[doc = "than this threshold, with the units of both quantities being the same). \\n"]
    #[doc = "1 LSB = 0.1 dB \\n"]
    #[doc = "Valid range: 0 to 65535 (0 to 6553dB) \\n"]
    pub txBpmAmplErrThresh: rlUInt16_t,
    #[doc = " @brief  Maximum threshold for the difference in the 2 configured phase shift values"]
    #[doc = "1 LSB = 5.625 degree"]
    pub phaseShifterThreshMax: rlUInt16_t,
    #[doc = " @brief   Minimum threshold for the difference in the 2 configured phase shift values"]
    #[doc = "1 LSB = 5.625 degree"]
    pub phaseShifterThreshMin: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlTxBpmMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlTxBpmMonConf>(),
        16usize,
        concat!("Size of: ", stringify!(rlTxBpmMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlTxBpmMonConf>(),
        2usize,
        concat!("Alignment of ", stringify!(rlTxBpmMonConf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxBpmMonConf>())).profileIndx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBpmMonConf),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxBpmMonConf>())).phaseShifterMonCnfg as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBpmMonConf),
            "::",
            stringify!(phaseShifterMonCnfg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxBpmMonConf>())).phaseShifterMon1 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBpmMonConf),
            "::",
            stringify!(phaseShifterMon1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxBpmMonConf>())).phaseShifterMon2 as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBpmMonConf),
            "::",
            stringify!(phaseShifterMon2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxBpmMonConf>())).reportMode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBpmMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxBpmMonConf>())).rxEn as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBpmMonConf),
            "::",
            stringify!(rxEn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxBpmMonConf>())).txBpmPhaseErrThresh as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBpmMonConf),
            "::",
            stringify!(txBpmPhaseErrThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxBpmMonConf>())).txBpmAmplErrThresh as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBpmMonConf),
            "::",
            stringify!(txBpmAmplErrThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxBpmMonConf>())).phaseShifterThreshMax as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBpmMonConf),
            "::",
            stringify!(phaseShifterThreshMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxBpmMonConf>())).phaseShifterThreshMin as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBpmMonConf),
            "::",
            stringify!(phaseShifterThreshMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlTxBpmMonConf>())).reserved as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxBpmMonConf),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rlTxBpmMonConf_t = rlTxBpmMonConf;
#[doc = " \\brief"]
#[doc = " TX BPM monitoring configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlAllTxBpmMonConf {
    #[doc = " @brief  Tx-0 BPM monitoring config"]
    pub tx0BpmMonCfg: *mut rlTxBpmMonConf_t,
    #[doc = " @brief  Tx-1 BPM monitoring config"]
    pub tx1BpmMonCfg: *mut rlTxBpmMonConf_t,
    #[doc = " @brief  Tx-2 BPM monitoring config"]
    pub tx2BpmMonCfg: *mut rlTxBpmMonConf_t,
}
#[test]
fn bindgen_test_layout_rlAllTxBpmMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlAllTxBpmMonConf>(),
        12usize,
        concat!("Size of: ", stringify!(rlAllTxBpmMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlAllTxBpmMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlAllTxBpmMonConf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAllTxBpmMonConf>())).tx0BpmMonCfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAllTxBpmMonConf),
            "::",
            stringify!(tx0BpmMonCfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAllTxBpmMonConf>())).tx1BpmMonCfg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAllTxBpmMonConf),
            "::",
            stringify!(tx1BpmMonCfg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAllTxBpmMonConf>())).tx2BpmMonCfg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAllTxBpmMonConf),
            "::",
            stringify!(tx2BpmMonCfg)
        )
    );
}
impl Default for rlAllTxBpmMonConf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlAllTxBpmMonConf_t = rlAllTxBpmMonConf;
#[doc = " \\brief"]
#[doc = " Synthesizer frequency monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlSynthFreqMonConf {
    #[doc = " @brief  This field indicates the Profile Index for which this configuration applies."]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  Value    Definition \\n"]
    #[doc = "0     Report is sent every monitoring period without threshold check \\n"]
    #[doc = "1     Report is send only upon a failure (after checking for thresholds) \\n"]
    #[doc = "2     Report is sent every monitoring period with threshold check \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  During the chirp, the error of the measured instantaneous chirp frequency w.r.t. \\n"]
    #[doc = "the desired value is continuously compared against this threshold. \\n"]
    #[doc = "The comparison result is part of the monitoring report message (Error bit is \\n"]
    #[doc = "set if the measurement is above this threshold, ever during the previous \\n"]
    #[doc = "monitoring period). \\n"]
    #[doc = "1 LSB = 10 kHz \\n"]
    #[doc = "Valid range: 0 to 65535 (0 to 655 MHz) \\n"]
    pub freqErrThresh: rlUInt16_t,
    #[doc = " @brief  This field determines when the monitoring starts in each \\n"]
    #[doc = "chirp relative to the start of the ramp. \\n"]
    #[doc = "1 LSB = 0.2us, signed number \\n"]
    #[doc = "Valid range: -25us to 25us \\n"]
    #[doc = "Recommended value: 6us or above \\n"]
    pub monStartTime: rlInt8_t,
    #[doc = " @brief  This field configures whether this monitor should be done \\n"]
    #[doc = "for functional active chirps (mode 0) or non live monitor chirps. In case of non \\n"]
    #[doc = "live monitor, the configuration needs to be sent twice for two VCOs \\n"]
    #[doc = "(use mode 1 and 2). \\n"]
    #[doc = "Value    Definition \\n"]
    #[doc = "0     LIVE_CONFIG, The profile configuration for live mode is picked"]
    #[doc = "from this API, supported only in master/single-chip mode. \\n"]
    #[doc = "1     VCO1_CONFIG, The profile configuration for Non-live mode is picked from"]
    #[doc = "this API for VCO1 monitor profile, supported in all modes (master, slave"]
    #[doc = "and single-chip). \\n"]
    #[doc = "2     VCO2_CONFIG, The profile configuration for Non-live mode is picked from"]
    #[doc = "this API for VCO2 monitor profile, supported in all modes (master, slave"]
    #[doc = "and single-chip). \\n"]
    #[doc = "@note : This feature is supported only on xWR6843 device. \\n"]
    pub monitorMode: rlUInt8_t,
    #[doc = " @brief  This bit mask can be used to enable/disable the monitoring of non-live VCO profiles,"]
    #[doc = "this helps to control monitoring of only single VCO if needed. This setting should"]
    #[doc = "be same in both VCO settings. \\n"]
    #[doc = "Bits    Definition \\n"]
    #[doc = "b0     Enable VCO1 non-live monitor \\n"]
    #[doc = "b1     Enable VCO2 non-live monitor \\n"]
    #[doc = "b31:2  RESERVED \\n"]
    #[doc = "@note : This field is applicable only on xWR6843 device. \\n"]
    pub vcoMonEn: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlSynthFreqMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlSynthFreqMonConf>(),
        12usize,
        concat!("Size of: ", stringify!(rlSynthFreqMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlSynthFreqMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlSynthFreqMonConf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSynthFreqMonConf>())).profileIndx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSynthFreqMonConf),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSynthFreqMonConf>())).reportMode as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSynthFreqMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlSynthFreqMonConf>())).freqErrThresh as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSynthFreqMonConf),
            "::",
            stringify!(freqErrThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlSynthFreqMonConf>())).monStartTime as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSynthFreqMonConf),
            "::",
            stringify!(monStartTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSynthFreqMonConf>())).monitorMode as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSynthFreqMonConf),
            "::",
            stringify!(monitorMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSynthFreqMonConf>())).vcoMonEn as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSynthFreqMonConf),
            "::",
            stringify!(vcoMonEn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSynthFreqMonConf>())).reserved1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSynthFreqMonConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSynthFreqMonConf>())).reserved2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSynthFreqMonConf),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type rlSynthFreqMonConf_t = rlSynthFreqMonConf;
#[doc = " \\brief"]
#[doc = " External analog signals monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlExtAnaSignalsMonConf {
    #[doc = " @brief  Value    Definition \\n"]
    #[doc = "0       Report is sent every monitoring period without threshold check \\n"]
    #[doc = "1       Report is send only upon a failure (after checking for thresholds) \\n"]
    #[doc = "2       Report is sent every monitoring period with threshold check \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  This field indicates the sets of externally fed DC signals which are to be \\n"]
    #[doc = "monitored using GPADC. When each bit in this field is set, the corresponding \\n"]
    #[doc = "signal is monitored. The monitored signals are compared against programmed \\n"]
    #[doc = "limits. The comparison result is part of the monitoring report message. \\n"]
    #[doc = "Bit Location  SIGNAL \\n"]
    #[doc = "0         ANALOGTEST1 \\n"]
    #[doc = "1         ANALOGTEST2 \\n"]
    #[doc = "2         ANALOGTEST3 \\n"]
    #[doc = "3         ANALOGTEST4 \\n"]
    #[doc = "4         ANAMUX \\n"]
    #[doc = "5         VSENSE \\n"]
    #[doc = "Others    RESERVED \\n"]
    pub signalInpEnables: rlUInt8_t,
    #[doc = " @brief  This field indicates the sets of externally fed DC signals which are to be \\n"]
    #[doc = "buffered before being fed to the GPADC. When each bit in this field is set, the \\n"]
    #[doc = "corresponding signal is buffered before the GPADC. The monitored signals are \\n"]
    #[doc = "compared against programmed limits. The comparison result is part of the \\n"]
    #[doc = "monitoring report message. \\n"]
    #[doc = "Bit      SIGNAL \\n"]
    #[doc = "0        ANALOGTEST1 \\n"]
    #[doc = "1        ANALOGTEST2 \\n"]
    #[doc = "2        ANALOGTEST3 \\n"]
    #[doc = "3        ANALOGTEST4 \\n"]
    #[doc = "4        ANAMUX \\n"]
    #[doc = "Others   RESERVED \\n"]
    pub signalBuffEnables: rlUInt8_t,
    #[doc = " @brief  After connecting an external signal to the GPADC, the amount of time to wait for \\n"]
    #[doc = "it to settle before taking GPADC samples is programmed in this field. For each \\n"]
    #[doc = "signal, after that settling time, GPADC measurements take place for 6.4us \\n"]
    #[doc = "(averaging 4 samples of the GPADC output).The byte locations of the settling \\n"]
    #[doc = "times for each signal are tabulated here: \\n"]
    #[doc = "Byte Location   SIGNAL \\n"]
    #[doc = "0           ANALOGTEST1 \\n"]
    #[doc = "1           ANALOGTEST2 \\n"]
    #[doc = "2           ANALOGTEST3 \\n"]
    #[doc = "3           ANALOGTEST4 \\n"]
    #[doc = "4           ANAMUX \\n"]
    #[doc = "5           VSENSE \\n"]
    #[doc = "1 LSB = 0.8us \\n"]
    #[doc = "Valid range: 0 to 12us \\n"]
    #[doc = "Valid programming condition: all the signals that are enabled \\n"]
    #[doc = "should take a total of <100us, including the programmed settling \\n"]
    #[doc = "times and a fixed 6.4us of measurement time per enabled signal. \\n"]
    pub signalSettlingTime: [rlUInt8_t; 6usize],
    #[doc = " @brief  The external DC signals measured on GPADC are compared against these minimum and \\n"]
    #[doc = "maximum thresholds. The comparison result is part of the monitoring report \\n"]
    #[doc = "message (Error bit is set if any measurement is outside this (minimum, maximum) \\n"]
    #[doc = "range). \\n"]
    #[doc = "Byte Location  Threshold     SIGNAL \\n"]
    #[doc = "0           Minimum      ANALOGTEST1 \\n"]
    #[doc = "1           Minimum      ANALOGTEST2 \\n"]
    #[doc = "2           Minimum      ANALOGTEST3 \\n"]
    #[doc = "3           Minimum      ANALOGTEST4 \\n"]
    #[doc = "4           Minimum      ANAMUX \\n"]
    #[doc = "5           Minimum      VSENSE \\n"]
    #[doc = "6           Maximum      ANALOGTEST1 \\n"]
    #[doc = "7           Maximum      ANALOGTEST2 \\n"]
    #[doc = "8           Maximum      ANALOGTEST3 \\n"]
    #[doc = "9           Maximum      ANALOGTEST4 \\n"]
    #[doc = "10          Maximum      ANAMUX \\n"]
    #[doc = "11          Maximum      VSENSE \\n"]
    #[doc = "1 LSB = 1.8V / 256 \\n"]
    #[doc = "Valid range: 0 to 255(0 to 1.79V) \\n"]
    pub signalThresh: [rlUInt8_t; 12usize],
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved3: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlExtAnaSignalsMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlExtAnaSignalsMonConf>(),
        32usize,
        concat!("Size of: ", stringify!(rlExtAnaSignalsMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlExtAnaSignalsMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlExtAnaSignalsMonConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlExtAnaSignalsMonConf>())).reportMode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlExtAnaSignalsMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlExtAnaSignalsMonConf>())).reserved0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlExtAnaSignalsMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlExtAnaSignalsMonConf>())).signalInpEnables as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlExtAnaSignalsMonConf),
            "::",
            stringify!(signalInpEnables)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlExtAnaSignalsMonConf>())).signalBuffEnables as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlExtAnaSignalsMonConf),
            "::",
            stringify!(signalBuffEnables)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlExtAnaSignalsMonConf>())).signalSettlingTime as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlExtAnaSignalsMonConf),
            "::",
            stringify!(signalSettlingTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlExtAnaSignalsMonConf>())).signalThresh as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlExtAnaSignalsMonConf),
            "::",
            stringify!(signalThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlExtAnaSignalsMonConf>())).reserved1 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rlExtAnaSignalsMonConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlExtAnaSignalsMonConf>())).reserved2 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rlExtAnaSignalsMonConf),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlExtAnaSignalsMonConf>())).reserved3 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rlExtAnaSignalsMonConf),
            "::",
            stringify!(reserved3)
        )
    );
}
pub type rlExtAnaSignalsMonConf_t = rlExtAnaSignalsMonConf;
#[doc = " \\brief"]
#[doc = " Internal signals in the TX path monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlTxIntAnaSignalsMonConf {
    #[doc = " @brief  The RF analog settings corresponding to this profile are used for monitoring the \\n"]
    #[doc = "enabled signals, using test chirps (static frequency, at the center of the \\n"]
    #[doc = "profile's RF frequency band). \\n"]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  Value   Definition \\n"]
    #[doc = "0    RESERVED \\n"]
    #[doc = "1    Report is send only upon a failure(after checking for thresholds) \\n"]
    #[doc = "2    Report is sent every monitoring period with threshold check. \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  The TX phase shifter DAC monitor delta threshold \\n"]
    #[doc = "1 LSB = 1.8V/1024 \\n"]
    #[doc = "This field is applicable only for xWR6843 and xWR1843 devices. \\n"]
    #[doc = "Value 0: TX_PS_DAC_MON is disabled \\n"]
    #[doc = "Valid range: 1 to 1023 \\n"]
    pub txPhShiftDacMonThresh: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlTxIntAnaSignalsMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlTxIntAnaSignalsMonConf>(),
        8usize,
        concat!("Size of: ", stringify!(rlTxIntAnaSignalsMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlTxIntAnaSignalsMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlTxIntAnaSignalsMonConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxIntAnaSignalsMonConf>())).profileIndx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxIntAnaSignalsMonConf),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxIntAnaSignalsMonConf>())).reportMode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxIntAnaSignalsMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxIntAnaSignalsMonConf>())).txPhShiftDacMonThresh as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxIntAnaSignalsMonConf),
            "::",
            stringify!(txPhShiftDacMonThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlTxIntAnaSignalsMonConf>())).reserved1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlTxIntAnaSignalsMonConf),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlTxIntAnaSignalsMonConf_t = rlTxIntAnaSignalsMonConf;
#[doc = " \\brief"]
#[doc = " Internal signals in the TX path monitoring configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlAllTxIntAnaSignalsMonConf {
    #[doc = " @brief  Internal signals in the Tx-0 path monitoring config"]
    pub tx0IntAnaSgnlMonCfg: *mut rlTxIntAnaSignalsMonConf_t,
    #[doc = " @brief  Internal signals in the Tx-1 path monitoring config"]
    pub tx1IntAnaSgnlMonCfg: *mut rlTxIntAnaSignalsMonConf_t,
    #[doc = " @brief  Internal signals in the Tx-2 path monitoring config"]
    pub tx2IntAnaSgnlMonCfg: *mut rlTxIntAnaSignalsMonConf_t,
}
#[test]
fn bindgen_test_layout_rlAllTxIntAnaSignalsMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlAllTxIntAnaSignalsMonConf>(),
        12usize,
        concat!("Size of: ", stringify!(rlAllTxIntAnaSignalsMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlAllTxIntAnaSignalsMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlAllTxIntAnaSignalsMonConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAllTxIntAnaSignalsMonConf>())).tx0IntAnaSgnlMonCfg as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAllTxIntAnaSignalsMonConf),
            "::",
            stringify!(tx0IntAnaSgnlMonCfg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAllTxIntAnaSignalsMonConf>())).tx1IntAnaSgnlMonCfg as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAllTxIntAnaSignalsMonConf),
            "::",
            stringify!(tx1IntAnaSgnlMonCfg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlAllTxIntAnaSignalsMonConf>())).tx2IntAnaSgnlMonCfg as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAllTxIntAnaSignalsMonConf),
            "::",
            stringify!(tx2IntAnaSgnlMonCfg)
        )
    );
}
impl Default for rlAllTxIntAnaSignalsMonConf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlAllTxIntAnaSignalsMonConf_t = rlAllTxIntAnaSignalsMonConf;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRxIntAnaSignalsMonConf {
    #[doc = " @brief  The RF analog settings corresponding to this profile are used for monitoring the \\n"]
    #[doc = "enabled signals, using test chirps(static frequency,at the center of the \\n"]
    #[doc = "profile's RF frequency band). \\n"]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  Value   Definition \\n"]
    #[doc = "0    RESERVED \\n"]
    #[doc = "1    Report is send only upon a failure(after checking for thresholds) \\n"]
    #[doc = "2    Report is sent every monitoring period with threshold check. \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRxIntAnaSignalsMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlRxIntAnaSignalsMonConf>(),
        8usize,
        concat!("Size of: ", stringify!(rlRxIntAnaSignalsMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRxIntAnaSignalsMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRxIntAnaSignalsMonConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxIntAnaSignalsMonConf>())).profileIndx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxIntAnaSignalsMonConf),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxIntAnaSignalsMonConf>())).reportMode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxIntAnaSignalsMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxIntAnaSignalsMonConf>())).reserved0 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxIntAnaSignalsMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxIntAnaSignalsMonConf>())).reserved1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxIntAnaSignalsMonConf),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlRxIntAnaSignalsMonConf_t = rlRxIntAnaSignalsMonConf;
#[doc = " \\brief"]
#[doc = " Internal signals for PM, CLK and LO monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlPmClkLoIntAnaSignalsMonConf {
    #[doc = " @brief  The RF analog settings corresponding to this profile are used for monitoring the \\n"]
    #[doc = "enabled signals, using test chirps(static frequency, at the center of the  \\n"]
    #[doc = "profile's RF frequency band). \\n"]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  Value   Definition \\n"]
    #[doc = "0    RESERVED \\n"]
    #[doc = "1    Report is send only upon a failure(after checking for thresholds) \\n"]
    #[doc = "2    Report is sent every monitoring period with threshold check. \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  Value   Definition \\n"]
    #[doc = "0    20GHz SYNC monitoring disabled \\n"]
    #[doc = "1    FMCW_SYNC_IN monitoring enabled \\n"]
    #[doc = "2    FMCW_SYNC_OUT monitoring enabled \\n"]
    #[doc = "3    FMCW_SYNC_CLKOUT monitoring enabled \\n"]
    #[doc = "@note : 20G signal monitoring control is not supported in this release for all devices."]
    #[doc = "This is a RESERVED field and should be set to 0. \\n"]
    pub sync20GSigSel: rlUInt8_t,
    #[doc = " @brief  Minimum threshold for 20GHz monitoring\\n"]
    #[doc = "1 LSB = 1 dBm"]
    pub sync20GMinThresh: rlInt8_t,
    #[doc = " @brief  Maximum threshold for 20GHz monitoring\\n"]
    #[doc = "1 LSB = 1 dBm"]
    pub sync20GMaxThresh: rlInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlPmClkLoIntAnaSignalsMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlPmClkLoIntAnaSignalsMonConf>(),
        8usize,
        concat!("Size of: ", stringify!(rlPmClkLoIntAnaSignalsMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlPmClkLoIntAnaSignalsMonConf>(),
        2usize,
        concat!("Alignment of ", stringify!(rlPmClkLoIntAnaSignalsMonConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPmClkLoIntAnaSignalsMonConf>())).profileIndx as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmClkLoIntAnaSignalsMonConf),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPmClkLoIntAnaSignalsMonConf>())).reportMode as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmClkLoIntAnaSignalsMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPmClkLoIntAnaSignalsMonConf>())).sync20GSigSel as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmClkLoIntAnaSignalsMonConf),
            "::",
            stringify!(sync20GSigSel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPmClkLoIntAnaSignalsMonConf>())).sync20GMinThresh as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmClkLoIntAnaSignalsMonConf),
            "::",
            stringify!(sync20GMinThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPmClkLoIntAnaSignalsMonConf>())).sync20GMaxThresh as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmClkLoIntAnaSignalsMonConf),
            "::",
            stringify!(sync20GMaxThresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPmClkLoIntAnaSignalsMonConf>())).reserved0 as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmClkLoIntAnaSignalsMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPmClkLoIntAnaSignalsMonConf>())).reserved1 as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPmClkLoIntAnaSignalsMonConf),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlPmClkLoIntAnaSignalsMonConf_t = rlPmClkLoIntAnaSignalsMonConf;
#[doc = " \\brief"]
#[doc = " Internal signals for GPADC monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlGpadcIntAnaSignalsMonConf {
    #[doc = " @brief  Value    Definition \\n"]
    #[doc = "0      RESERVED \\n"]
    #[doc = "1      Report is send only upon a failure (after checking for thresholds) \\n"]
    #[doc = "2      Report is sent every monitoring period with threshold check. \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlGpadcIntAnaSignalsMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlGpadcIntAnaSignalsMonConf>(),
        8usize,
        concat!("Size of: ", stringify!(rlGpadcIntAnaSignalsMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlGpadcIntAnaSignalsMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlGpadcIntAnaSignalsMonConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlGpadcIntAnaSignalsMonConf>())).reportMode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlGpadcIntAnaSignalsMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlGpadcIntAnaSignalsMonConf>())).reserved0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlGpadcIntAnaSignalsMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlGpadcIntAnaSignalsMonConf>())).reserved1 as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlGpadcIntAnaSignalsMonConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlGpadcIntAnaSignalsMonConf>())).reserved2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlGpadcIntAnaSignalsMonConf),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type rlGpadcIntAnaSignalsMonConf_t = rlGpadcIntAnaSignalsMonConf;
#[doc = " \\brief"]
#[doc = " Internal signals for PLL control voltage monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlPllContrlVoltMonConf {
    #[doc = " @brief  Value    Definition \\n"]
    #[doc = "0      RESERVED \\n"]
    #[doc = "1      Report is send only upon a failure (after checking for thresholds) \\n"]
    #[doc = "2      Report is sent every monitoring period with threshold check. \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  This field indicates the sets of signals which are to be monitored. When each bit \\n"]
    #[doc = "in this field is set, the corresponding signal set is monitored using test \\n"]
    #[doc = "chirps. Rest of the RF analog may not be ON during these test chirps. The APLL \\n"]
    #[doc = "VCO control voltage can be monitored. The Synthesizer VCO control voltage for \\n"]
    #[doc = "both VCO1 and VCO2 can be monitored, while operating at their respective \\n"]
    #[doc = "minimum and maximum frequencies, and their respective VCO slope (Hz/V) can be \\n"]
    #[doc = "monitored if both frequencies are enabled for that VCO. The monitored signals \\n"]
    #[doc = "are compared against internally chosen valid limits. The comparison results are \\n"]
    #[doc = "part of the monitoring \\n"]
    #[doc = "report message. \\n"]
    #[doc = "Bit Location   SIGNAL \\n"]
    #[doc = "0          APLL_VCTRL \\n"]
    #[doc = "1          SYNTH_VCO1_VCTRL \\n"]
    #[doc = "2          SYNTH_VCO2_VCTRL \\n"]
    #[doc = "15:3         RESERVED \\n"]
    #[doc = "The synthesizer VCO extreme frequencies are: \\n"]
    #[doc = "Synthesizer VCO      Frequency Limits (Min, Max) \\n"]
    #[doc = "VCO1             (76GHz, 78GHz) \\n"]
    #[doc = "VCO2             (77GHz, 81GHz) \\n"]
    #[doc = "Synthesizer measurements are done with TX switched off to avoid emissions. \\n"]
    pub signalEnables: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlPllContrlVoltMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlPllContrlVoltMonConf>(),
        8usize,
        concat!("Size of: ", stringify!(rlPllContrlVoltMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlPllContrlVoltMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlPllContrlVoltMonConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPllContrlVoltMonConf>())).reportMode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPllContrlVoltMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPllContrlVoltMonConf>())).reserved0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPllContrlVoltMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPllContrlVoltMonConf>())).signalEnables as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPllContrlVoltMonConf),
            "::",
            stringify!(signalEnables)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlPllContrlVoltMonConf>())).reserved1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlPllContrlVoltMonConf),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlPllContrVoltMonConf_t = rlPllContrlVoltMonConf;
#[doc = " \\brief"]
#[doc = " Internal signals for DCC based clock monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlDualClkCompMonConf {
    #[doc = " @brief  Value    Definition \\n"]
    #[doc = "0      RESERVED \\n"]
    #[doc = "1      Report is send only upon a failure (after checking for thresholds) \\n"]
    #[doc = "2      Report is sent every monitoring period with threshold check. \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  This field indicates which pairs of clocks to monitor. When a bit in the field is \\n"]
    #[doc = "set to 1, the firmware monitors the corresponding clock pair by deploying the \\n"]
    #[doc = "hardware's Dual Clock Comparator in the corresponding DCC mode. \\n"]
    #[doc = "Bit  CLOCK PAIR \\n"]
    #[doc = "0    BSS_600M \\n"]
    #[doc = "1    BSS_200M \\n"]
    #[doc = "2    BSS_100M \\n"]
    #[doc = "3    GPADC_10M \\n"]
    #[doc = "4    RCOSC_10M \\n"]
    #[doc = "15:5 RESERVED \\n"]
    #[doc = "The comparison results are part of the monitoring report message. The \\n"]
    #[doc = "definition of the clock pairs and their error thresholds for failure reporting \\n"]
    #[doc = "are given in the table below the message definition. \\n"]
    pub dccPairEnables: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlDualClkCompMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlDualClkCompMonConf>(),
        8usize,
        concat!("Size of: ", stringify!(rlDualClkCompMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlDualClkCompMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlDualClkCompMonConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDualClkCompMonConf>())).reportMode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDualClkCompMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDualClkCompMonConf>())).reserved0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDualClkCompMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlDualClkCompMonConf>())).dccPairEnables as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDualClkCompMonConf),
            "::",
            stringify!(dccPairEnables)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlDualClkCompMonConf>())).reserved1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlDualClkCompMonConf),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlDualClkCompMonConf_t = rlDualClkCompMonConf;
#[doc = " \\brief"]
#[doc = " RX saturation monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRxSatMonConf {
    #[doc = " @brief  This field indicates the profile Index for which this configuration applies."]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  01 => Enable only the ADC saturation monitor \\n"]
    #[doc = "11 => Enable both the ADC and IFA1 saturation monitors \\n"]
    pub satMonSel: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt16_t,
    #[doc = " @brief  It specifies the duration of each (primary) time slice. \\n"]
    #[doc = "1 LSB = 0.16us. \\n"]
    #[doc = "Valid range: 4 to floor(ADC sampling time us/0.16 us) \\n"]
    #[doc = "@note : The minimum allowed duration of each (primary) time slice is  \\n"]
    #[doc = "4 LSBs = 0.64us. Also, the maximum number of (primary) time slices that will \\n"]
    #[doc = "be monitored in a chirp is 64 so the recommendation is to set this value to \\n"]
    #[doc = "correspond to (ADC sampling time / 64). If the slice is smaller, such that the \\n"]
    #[doc = "ADC sampling time is longer than 64 primary slices,some regions of the valid \\n"]
    #[doc = "duration of a chirp may go un-monitored. \\n"]
    pub primarySliceDuration: rlUInt16_t,
    #[doc = " @brief  Number of (primary + secondary) time slices to monitor. \\n"]
    #[doc = "Valid range: 1 to 127 \\n"]
    #[doc = "@note 1: Together with primarySliceDuration, this determines the full \\n"]
    #[doc = "duration of the ADC valid time that gets covered by the monitor \\n"]
    #[doc = "Primary slices = (N+1) / 2 \\n"]
    #[doc = "Secondary slices = Primary slices - 1 \\n"]
    #[doc = "@note 2: The total monitoring duration is recommended to be programmed slightly \\n"]
    #[doc = "smaller than ADC sampling time to avoid last primary slice miss in \\n"]
    #[doc = "the CQ data.  If this recommendation is not followed and if ADC \\n"]
    #[doc = "sampling time is less than total requested monitoring duration then \\n"]
    #[doc = "no error is generated but the total number of slices reported back in \\n"]
    #[doc = "CQ buffer would be a different value M, which is less than user \\n"]
    #[doc = "requested value of N. In such cases, there will be (M+1)/2 primary \\n"]
    #[doc = "slices and (M-1)/2 secondary slices. However, if ADC sampling time is \\n"]
    #[doc = "such that Secondary (M-1)/2 can be measured and not Primary (M+1)/2, \\n"]
    #[doc = "then primary slice (M+1)/2 will not be present in the CQ buffer. In \\n"]
    #[doc = "such scenario, CQ buffer will have the total number of slices reported \\n"]
    #[doc = "back as M-1 instead of M. \\n"]
    pub numSlices: rlUInt16_t,
    #[doc = " @brief  This field is applicable only for SAT_MON_MODE = 0 Masks RX channels used for \\n"]
    #[doc = "monitoring. In every slice, saturation counts for all unmasked channels are \\n"]
    #[doc = "added together, and the total is capped to 127. The 8 bits are mapped \\n"]
    #[doc = "(MSB->LSB) to: \\n"]
    #[doc = "[RX3Q, RX2Q, RX1Q, RX0Q, RX3I, RX2I, RX1I, RX0I] \\n"]
    #[doc = "00000000 => All channels unmasked \\n"]
    #[doc = "11111111 => All channels masked. \\n"]
    pub rxChannelMask: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved3: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved4: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRxSatMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlRxSatMonConf>(),
        20usize,
        concat!("Size of: ", stringify!(rlRxSatMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRxSatMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRxSatMonConf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxSatMonConf>())).profileIndx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxSatMonConf),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxSatMonConf>())).satMonSel as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxSatMonConf),
            "::",
            stringify!(satMonSel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxSatMonConf>())).reserved0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxSatMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxSatMonConf>())).primarySliceDuration as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxSatMonConf),
            "::",
            stringify!(primarySliceDuration)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxSatMonConf>())).numSlices as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxSatMonConf),
            "::",
            stringify!(numSlices)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxSatMonConf>())).rxChannelMask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxSatMonConf),
            "::",
            stringify!(rxChannelMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxSatMonConf>())).reserved1 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxSatMonConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxSatMonConf>())).reserved2 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxSatMonConf),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxSatMonConf>())).reserved3 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxSatMonConf),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxSatMonConf>())).reserved4 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxSatMonConf),
            "::",
            stringify!(reserved4)
        )
    );
}
pub type rlRxSatMonConf_t = rlRxSatMonConf;
#[doc = " \\brief"]
#[doc = " Signal and image band energy monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlSigImgMonConf {
    #[doc = " @brief  This field indicates the profile index for which this configuration applies."]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief  Number of (primary + secondary) slices to monitor Valid range: 1 to 127."]
    pub numSlices: rlUInt8_t,
    #[doc = " @brief  This field specifies the number of samples constituting each time slice. The \\n"]
    #[doc = "minimum allowed value for this parameter is 4. \\n"]
    #[doc = "Valid range: 4 to NUM_ADC_SAMPLES \\n"]
    #[doc = "@note 1: The maximum number of (primary) time slices that will be monitored in \\n"]
    #[doc = "a chirp is 64, so our recommendation is that this value should at \\n"]
    #[doc = "least equal (NUM_ADC_SAMPLES / 64). If the slice is smaller, such \\n"]
    #[doc = "that the number of ADC samples per chirp is larger than 64 primary \\n"]
    #[doc = "slices, some regions of the valid duration of a chirp may go \\n"]
    #[doc = "un-monitored. \\n"]
    #[doc = "@note 2: In Complex1x mode, the minimum number of samples per slice is 4 and \\n"]
    #[doc = "for other modes it is 8. Also note that number of samples should be \\n"]
    #[doc = "an even number. \\n"]
    #[doc = "@note 3: The total monitoring duration is recommended to program slightly \\n"]
    #[doc = "smaller than ADC sampling time \\n"]
    pub timeSliceNumSamples: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt32_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlSigImgMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlSigImgMonConf>(),
        12usize,
        concat!("Size of: ", stringify!(rlSigImgMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlSigImgMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlSigImgMonConf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSigImgMonConf>())).profileIndx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSigImgMonConf),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSigImgMonConf>())).numSlices as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSigImgMonConf),
            "::",
            stringify!(numSlices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlSigImgMonConf>())).timeSliceNumSamples as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSigImgMonConf),
            "::",
            stringify!(timeSliceNumSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSigImgMonConf>())).reserved0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSigImgMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlSigImgMonConf>())).reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlSigImgMonConf),
            "::",
            stringify!(reserved1)
        )
    );
}
pub type rlSigImgMonConf_t = rlSigImgMonConf;
#[doc = " \\brief"]
#[doc = " RX mixer input power monitoring configuration"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlRxMixInPwrMonConf {
    #[doc = " @brief  The RF analog settings corresponding to this profile are used for monitoring RX \\n"]
    #[doc = "mixer input power using test chirps (static frequency, at the center of the \\n"]
    #[doc = "profile's RF frequency band). \\n"]
    pub profileIndx: rlUInt8_t,
    #[doc = " @brief    Indicates the desired reporting verbosity and threshold usage. \\n"]
    #[doc = "Value = 0    Report is sent every monitoring period without threshold check \\n"]
    #[doc = "Value = 1    Report is send only upon a failure (after checking for thresholds) \\n"]
    #[doc = "Value = 2    Report is sent every monitoring period with threshold check. \\n"]
    #[doc = "Other values: RESERVED. \\n"]
    pub reportMode: rlUInt8_t,
    #[doc = " @brief  This field indicates if and which TX channels should be enabled while measuring \\n"]
    #[doc = "RX mixer input power. Setting a bit to 1 enables the corresponding TX channel. \\n"]
    #[doc = "Enabling a TX channel may help find reflection power while disabling may help \\n"]
    #[doc = "find interference power. \\n"]
    #[doc = "Bit number   TX Channel \\n"]
    #[doc = "0            TX0 \\n"]
    #[doc = "1            TX1 \\n"]
    #[doc = "2            TX2 \\n"]
    pub txEnable: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief  The measured RX mixer input voltage swings during this monitoring is compared \\n"]
    #[doc = "against the minimum and maximum thresholds configured in this field. The"]
    #[doc = "comparison result is part of the monitoring report message (Error bit is set if \\n"]
    #[doc = "any measurement is outside this (minimum, maximum) range). \\n"]
    #[doc = "Byte number  Threshold \\n"]
    #[doc = "0            Minimum Threshold \\n"]
    #[doc = "1            Maximum Threshold \\n"]
    #[doc = "Only the RX channels enabled in the static configuration APIs are monitored. \\n"]
    #[doc = "1 LSB = 1800mV/256, unsigned number \\n"]
    #[doc = "Valid range: 0 to 255 (0 to 1792.96 mV), maximum threshold >= minimum threshold \\n"]
    pub thresholds: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt32_t,
}
#[test]
fn bindgen_test_layout_rlRxMixInPwrMonConf() {
    assert_eq!(
        ::core::mem::size_of::<rlRxMixInPwrMonConf>(),
        12usize,
        concat!("Size of: ", stringify!(rlRxMixInPwrMonConf))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRxMixInPwrMonConf>(),
        4usize,
        concat!("Alignment of ", stringify!(rlRxMixInPwrMonConf))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRxMixInPwrMonConf>())).profileIndx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxMixInPwrMonConf),
            "::",
            stringify!(profileIndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxMixInPwrMonConf>())).reportMode as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxMixInPwrMonConf),
            "::",
            stringify!(reportMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxMixInPwrMonConf>())).txEnable as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxMixInPwrMonConf),
            "::",
            stringify!(txEnable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxMixInPwrMonConf>())).reserved0 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxMixInPwrMonConf),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxMixInPwrMonConf>())).thresholds as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxMixInPwrMonConf),
            "::",
            stringify!(thresholds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxMixInPwrMonConf>())).reserved1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxMixInPwrMonConf),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlRxMixInPwrMonConf>())).reserved2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRxMixInPwrMonConf),
            "::",
            stringify!(reserved2)
        )
    );
}
pub type rlRxMixInPwrMonConf_t = rlRxMixInPwrMonConf;
#[doc = " \\brief"]
#[doc = " RX signal and image band energy statistics"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rlRfSigImgPowerCqData {
    #[doc = " @brief  Number of (primary + secondary) slices to monitor Valid range: 1 to 127."]
    pub numSlices: rlUInt16_t,
    #[doc = " @brief The signal band and image band are separated using a two-channel filter"]
    #[doc = "bank and the ADC sampling time duration is monitored in terms of primary and"]
    #[doc = "secondary time slices as configured using rlRfRxSigImgMonConfig."]
    #[doc = "If Number of Slices configured in rlRfRxSigImgMonConfig is N, then number"]
    #[doc = "of Primary slices = N+1/2 and number of secondary slices = N-1/2 \\n"]
    #[doc = "For each of the two bands (signal and image), for each time slice,"]
    #[doc = "the input-referred average power in the slice in negative dBm is"]
    #[doc = "recorded as an 8-bit unsigned number, with 1 LSB = -0.5 dBm."]
    #[doc = "CQ data is stored in 16bit format as follows:"]
    #[doc = "Pi[1] Ps[1], Si[1] Ss[1], Pi[2] Ps[2], Si[2] Ss[2]......"]
    #[doc = "Pi[63] Ps[63], Si[63] Ss[63], Pi[64] Ps[64]"]
    #[doc = "Where,"]
    #[doc = "Pi = Primary Slice Image Band Power, 1LSB = -0.5dBm"]
    #[doc = "Ps = Primary Slice Signal Band Power, 1LSB = -0.5dBm"]
    #[doc = "Si = Secondary Slice Image Band Power, 1LSB = -0.5dBm"]
    #[doc = "Ss = Secondary Slice Signal Band Power, 1LSB = -0.5dBm"]
    #[doc = ""]
    #[doc = "This data is stored in CQ1 section of CQ RAM. If multiple chirps"]
    #[doc = "are defined, then this data is concatenated and stored in CQ RAM"]
    #[doc = "in ping pong manner"]
    #[doc = ""]
    #[doc = "@note : CQ0 section in CQ RAM will contain invalid data and the user should"]
    #[doc = "to ignore this."]
    pub sigImgPowerCqVal: [rlUInt16_t; 127usize],
}
#[test]
fn bindgen_test_layout_rlRfSigImgPowerCqData() {
    assert_eq!(
        ::core::mem::size_of::<rlRfSigImgPowerCqData>(),
        256usize,
        concat!("Size of: ", stringify!(rlRfSigImgPowerCqData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfSigImgPowerCqData>(),
        2usize,
        concat!("Alignment of ", stringify!(rlRfSigImgPowerCqData))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfSigImgPowerCqData>())).numSlices as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfSigImgPowerCqData),
            "::",
            stringify!(numSlices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfSigImgPowerCqData>())).sigImgPowerCqVal as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfSigImgPowerCqData),
            "::",
            stringify!(sigImgPowerCqVal)
        )
    );
}
impl Default for rlRfSigImgPowerCqData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlRfSigImgPowerCqData_t = rlRfSigImgPowerCqData;
#[doc = " \\brief"]
#[doc = " RX ADC and IF saturation information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rlRfRxSaturationCqData {
    #[doc = " @brief  Number of (primary + secondary) slices to monitor Valid range: 1 to 127."]
    pub numSlices: rlUInt8_t,
    #[doc = " @brief The analog to digital interface includes a 100 MHz bit stream indicating"]
    #[doc = "saturation events in the ADC/IF sections, for each channel. This one-bit"]
    #[doc = "indicator for each channel is monitored during the ADC sampling time"]
    #[doc = "duration in a time-sliced manner as defined in rlRfRxIfSatMonConfig.\\n"]
    #[doc = "If Number of Slices configured in rlRfRxSigImgMonConfig is N, then number"]
    #[doc = "of Primary slices = (N+1)/2 and number of secondary slices = (N-1)/2 \\n"]
    #[doc = "For each time slice, a saturation event count is recorded. This count"]
    #[doc = "is the sum of saturation event counts across all RX channels selected"]
    #[doc = "for monitoring, capped to a maximum count of 255 (8 bits).\\n"]
    #[doc = "CQ data is stored in 16bit format as follows:"]
    #[doc = "P[1], S[1], P[2] S[2]......P[63], S[63], P[64]"]
    #[doc = "Where,"]
    #[doc = "P[n] = indicates the accumulated saturation count for all enabled RX"]
    #[doc = "channels in primary slice n"]
    #[doc = "S[n] = indicates the accumulated saturation count for all enabled RX"]
    #[doc = "channels in secondary slice n"]
    #[doc = ""]
    #[doc = "This data is stored in CQ2 section of CQ RAM. If multiple chirps"]
    #[doc = "are defined, then this data is concatenated and stored in CQ RAM"]
    #[doc = "in ping pong manner"]
    #[doc = ""]
    #[doc = "@note 1: CQ0 section in CQ RAM will contain invalid data."]
    #[doc = "@note 2: This satCqVal data transfer happen through DMA not through SPI. So there"]
    #[doc = "is no problem of endianess."]
    #[doc = ""]
    pub satCqVal: [rlUInt8_t; 127usize],
}
#[test]
fn bindgen_test_layout_rlRfRxSaturationCqData() {
    assert_eq!(
        ::core::mem::size_of::<rlRfRxSaturationCqData>(),
        128usize,
        concat!("Size of: ", stringify!(rlRfRxSaturationCqData))
    );
    assert_eq!(
        ::core::mem::align_of::<rlRfRxSaturationCqData>(),
        1usize,
        concat!("Alignment of ", stringify!(rlRfRxSaturationCqData))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfRxSaturationCqData>())).numSlices as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfRxSaturationCqData),
            "::",
            stringify!(numSlices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rlRfRxSaturationCqData>())).satCqVal as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlRfRxSaturationCqData),
            "::",
            stringify!(satCqVal)
        )
    );
}
impl Default for rlRfRxSaturationCqData {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rlRfRxSaturationCqData_t = rlRfRxSaturationCqData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlAnaFaultInj {
    #[doc = " @brief  Reserved for Future use"]
    pub reserved0: rlUInt8_t,
    #[doc = " @brief Primary Fault: RX Gain. This field indicates which RX RF sections should have \\n"]
    #[doc = "fault injected. If the fault is enabled, the RX RF gain drops significantly. \\n"]
    #[doc = "The fault can be used to cause significant gain change, inter-RX gain imbalance \\n"]
    #[doc = "and an uncontrolled amount of inter-RX phase imbalance. \\n"]
    #[doc = "This fault can be seen in RX_GAIN_PHASE_MONITOR. \\n"]
    #[doc = "Bit RX Channel  \\n"]
    #[doc = "0  RX0         \\n"]
    #[doc = "1  RX1         \\n"]
    #[doc = "2  RX2         \\n"]
    #[doc = "3  RX3         \\n"]
    #[doc = "Others RESERVED \\n"]
    #[doc = "For each bit, 1 = inject fault, 0 = remove injected fault"]
    pub rxGainDrop: rlUInt8_t,
    #[doc = " @brief Primary Fault: RX Phase. This field indicates which RX channels should have \\n"]
    #[doc = "fault injected. If the fault is enabled, the RX phase gets inverted. The fault \\n"]
    #[doc = "can be used to cause a controlled amount (180 deg) of inter-RX phase imbalance. \\n"]
    #[doc = "This fault can be seen in RX_GAIN_PHASE_MONITOR. \\n"]
    #[doc = "Bit RX Channel   \\n"]
    #[doc = "0  RX0          \\n"]
    #[doc = "1  RX1          \\n"]
    #[doc = "2  RX2          \\n"]
    #[doc = "3  RX3          \\n"]
    #[doc = "Others RESERVED \\n"]
    #[doc = "For each bit, 1 = inject fault, 0 = remove injected fault"]
    pub rxPhInv: rlUInt8_t,
    #[doc = " @brief Primary Fault: RX Noise. This field indicates which RX channels should have fault \\n"]
    #[doc = "injected. If the fault is enabled, the RX IFA square wave loopback paths are \\n"]
    #[doc = "engaged to inject high noise at RX IFA input. The fault can be used to cause \\n"]
    #[doc = "significant RX noise floor elevation. \\n"]
    #[doc = "This fault can be seen in RX_GAIN_PHASE_MONITOR and RX_NOISE_FIGURE_MONITOR. \\n"]
    #[doc = "Bit RX Channel   \\n"]
    #[doc = "0  RX0          \\n"]
    #[doc = "1  RX1          \\n"]
    #[doc = "2  RX2          \\n"]
    #[doc = "3  RX3          \\n"]
    #[doc = "Others RESERVED \\n"]
    #[doc = "For each bit, 1 = inject fault, 0 = remove injected fault"]
    pub rxHighNoise: rlUInt8_t,
    #[doc = " @brief Primary Fault: Cutoff frequencies of RX IFA HPF & LPF, IFA Gain. This field \\n"]
    #[doc = "indicates which RX channels should have fault injected. If the fault is enabled, \\n"]
    #[doc = "the RX IFA HPF cutoff frequency becomes very high (about 15MHz). The fault can be \\n"]
    #[doc = "used to cause the measured inband IFA gain, HPF and LPF attenuations to vary from \\n"]
    #[doc = "ideal expectations. \\n"]
    #[doc = "This fault can be seen in RX_IFSTAGE_MONITOR. \\n"]
    #[doc = "Bit RX Channel   \\n"]
    #[doc = "0  RX0          \\n"]
    #[doc = "1  RX1          \\n"]
    #[doc = "2  RX2          \\n"]
    #[doc = "3  RX3          \\n"]
    #[doc = "Others RESERVED \\n"]
    #[doc = "For each bit, 1 = inject fault, 0 = remove injected fault \\n"]
    #[doc = "@note : during the execution of RX_IFSTAGE_MONITOR, the RX_HIGH_NOISE faults are \\n"]
    #[doc = "temporarily removed."]
    pub rxIfStagesFault: rlUInt8_t,
    #[doc = " @brief Primary Fault: RX Mixer LO input swing reduction. This field indicates which RX \\n"]
    #[doc = "channels should have fault injected. If the fault is enabled, the RX mixer LO \\n"]
    #[doc = "input swing is significantly reduced. The fault is primarily expected to be \\n"]
    #[doc = "detected by RX_INTERNAL_ANALOG_SIGNALS_MONITOR (under PWRDET_RX category). \\n"]
    #[doc = "Bit Channel       \\n"]
    #[doc = "0   RX0 and RX1  \\n"]
    #[doc = "1   RX2 and RX3  \\n"]
    #[doc = "Others RESERVED  \\n"]
    #[doc = "For each bit, 1 = inject fault, 0 = remove injected fault"]
    #[doc = "@note : This option is de-featured, please refer latest release note. \\n"]
    pub rxLoAmpFault: rlUInt8_t,
    #[doc = " @brief Primary Fault: TX PA input signal generator turning off. This field indicates \\n"]
    #[doc = "which TX channels should have fault injected. If the fault is enabled, the \\n"]
    #[doc = "amplifier generating TX power amplifier's LO input signal is turned off. The \\n"]
    #[doc = "fault is primarily expected to be detected by \\n"]
    #[doc = "TX<n>_INTERNAL_ANALOG_SIGNALS_MONITOR (under DCBIAS category). \\n"]
    #[doc = "Bit Channel     \\n"]
    #[doc = "0  TX0 and TX1 \\n"]
    #[doc = "1  TX2 (applicable only if available in the xWR device) \\n"]
    #[doc = "Others RESERVED \\n"]
    #[doc = "For each bit, 1 = inject fault, 0 = remove injected fault"]
    #[doc = "@note : This option is de-featured, please refer latest release note. \\n"]
    pub txLoAmpFault: rlUInt8_t,
    #[doc = " @brief Primary Fault: TX Gain (power). This field indicates which TX RF sections should \\n"]
    #[doc = "have fault injected. If the fault is enabled, the TX RF gain drops significantly. \\n"]
    #[doc = "The fault can be used to cause significant TX output power change, inter-TX gain \\n"]
    #[doc = "imbalance and an uncontrolled amount of inter-TX phase imbalance. \\n"]
    #[doc = "This fault can be seen in TXn_POWER_MONITOR \\n"]
    #[doc = "Bit TX Channel   \\n"]
    #[doc = "0  TX0          \\n"]
    #[doc = "1  TX1          \\n"]
    #[doc = "2  TX2          \\n"]
    #[doc = "Others RESERVED \\n"]
    #[doc = "For each bit, 1 = inject fault, 0 = remove injected fault"]
    pub txGainDrop: rlUInt8_t,
    #[doc = " @brief Primary Fault: TX Phase. This field indicates if TX channels should have fault \\n"]
    #[doc = "injected, along with some further programmability. If the fault is enabled, the \\n"]
    #[doc = "TX BPM polarity (phase) is forced to a constant value as programmed. The fault \\n"]
    #[doc = "can be used to cause a controlled amount (180 degree) of inter-TX phase imbalance \\n"]
    #[doc = "as well as BPM functionality failure. \\n"]
    #[doc = "This fault can be seen in TX_GAIN_PHASE_MISMATCH_MONITOR and"]
    #[doc = "TXn_PHASE_SHIFTER_MONITOR. \\n"]
    #[doc = "Bit TX Channel     \\n"]
    #[doc = "0  TX fault (Common for all TX channels) \\n"]
    #[doc = "1  RESERVED       \\n"]
    #[doc = "2  RESERVED       \\n"]
    #[doc = "3  TX0 BPM VALUE  \\n"]
    #[doc = "4  TX1 BPM VALUE  \\n"]
    #[doc = "5  TX2 BPM VALUE  \\n"]
    #[doc = "Others RESERVED    \\n"]
    #[doc = "For each TX<n> BPM VALUE: Applicable only if TX FAULT is enabled. \\n"]
    #[doc = "Value = 0: force TX<n> BPM polarity to 0 \\n"]
    #[doc = "Value = 1: force TX<n> BPM polarity to 1."]
    pub txPhInv: rlUInt8_t,
    #[doc = " @brief Primary Fault: Synthesizer Frequency. This field indicates which Synthesizer \\n"]
    #[doc = "faults should be injected. SYNTH_VCO_OPENLOOP: If the fault is enabled, the \\n"]
    #[doc = "synthesizer is forced in open loop mode with the VCO control voltage forced to \\n"]
    #[doc = "a constant. In order to avoid out of band emissions in this faulty state, this \\n"]
    #[doc = "fault is injected just before the PLL_CONTROL_VOLTAGE_MONITOR is executed and \\n"]
    #[doc = "released just after its completion. \\n"]
    #[doc = "This fault can be seen in PLL_CONTROL_VOLTAGE_MONITOR. \\n"]
    #[doc = "SYNTH_FREQ_MON_OFFSET: If the fault is enabled, the synthesizer frequency \\n"]
    #[doc = "monitor's ideal frequency ramp waveform is forced to be offset from the actual \\n"]
    #[doc = "ramp waveform by a constant, causing monitoring to detect failures. \\n"]
    #[doc = "This fault can be seen in SYNTH_FREQ_MONITOR. \\n"]
    #[doc = "Bit Enable Fault"]
    #[doc = "0  SYNTH_VCO_OPENLOOP"]
    #[doc = "1  SYNTH_FREQ_MON_OFFSET"]
    #[doc = "Others RESERVED"]
    #[doc = "For each bit, 1 = inject fault, 0 = remove injected fault"]
    pub synthFault: rlUInt8_t,
    #[doc = " @brief This field indicates whether some LDO output voltage faults should be injected or"]
    #[doc = "not.\\n"]
    #[doc = "Bit Enable Fault \\n"]
    #[doc = "0   SUPPLY_LDO_RX_LODIST_FAULT \\n"]
    #[doc = "Others RESERVED\\ n"]
    #[doc = "SUPPLY_LDO_RX_LODIST_FAULT: if enabled, the RX LO distribution sub system's LDO \\n"]
    #[doc = "output voltage is slightly changed compared to normal levels to cause \\n"]
    #[doc = "INTERNAL_PMCLKLO_SIGNALS_MONITOR to detect failure (under SUPPLY category). \\n"]
    #[doc = "This fault can be seen in INTERNAL_PMCLKLO_SIGNALS_MONITOR. \\n"]
    #[doc = "For each bit, 1 = inject fault, 0 = remove injected fault \\n"]
    #[doc = "@note : This fault injection is ineffective under LDO bypass condition."]
    pub supplyLdoFault: rlUInt8_t,
    #[doc = " @brief This field indicates whether a few miscellaneous faults should be injected or not. \\n"]
    #[doc = "Bit Enable Fault         \\n"]
    #[doc = "0  GPADC_CLK_FREQ_FAULT  \\n"]
    #[doc = "Others RESERVED          \\n"]
    #[doc = "GPADC_CLK_FREQ_FAULT: if enabled, the GPADC clock frequency is slightly increased \\n"]
    #[doc = "compared to normal usage to cause BSS DCC_CLOCK_FREQ_MONITOR to detect failure. \\n"]
    #[doc = "This fault can be seen in DCC_CLOCK_FREQ_MONITOR. \\n"]
    #[doc = "For each bit, 1 = inject fault, 0 = remove injected fault"]
    pub miscFault: rlUInt8_t,
    #[doc = " @brief This field indicates whether faults should be forced in the threshold comparisons \\n"]
    #[doc = "in the software layer of some monitors. If a fault is enabled, the logic in the \\n"]
    #[doc = "min-max threshold comparisons used for failure detection is inverted, causing a \\n"]
    #[doc = "fault to be reported. During these faults, no hardware fault condition is  \\n"]
    #[doc = "injected in the device."]
    #[doc = "This fault can be seen in GPADC_INTERNAL_SIGNALS_MONITOR. \\n"]
    #[doc = "Bit Enable Fault"]
    #[doc = "0  EXTERNAL_ANALOG_SIGNALS_MONITOR"]
    #[doc = "1  GPADC_INTERNAL_SIGNALS_MONITOR"]
    #[doc = "Others RESERVED"]
    #[doc = "For each bit, 1 = inject fault, 0 = remove injected fault"]
    pub miscThreshFault: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved1: rlUInt8_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved2: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved3: rlUInt16_t,
    #[doc = " @brief  Reserved for Future use"]
    pub reserved4: rlUInt16_t,
}
#[test]
fn bindgen_test_layout_rlAnaFaultInj() {
    assert_eq!(
        ::core::mem::size_of::<rlAnaFaultInj>(),
        20usize,
        concat!("Size of: ", stringify!(rlAnaFaultInj))
    );
    assert_eq!(
        ::core::mem::align_of::<rlAnaFaultInj>(),
        2usize,
        concat!("Alignment of ", stringify!(rlAnaFaultInj))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).reserved0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).rxGainDrop as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(rxGainDrop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).rxPhInv as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(rxPhInv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).rxHighNoise as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(rxHighNoise)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).rxIfStagesFault as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(rxIfStagesFault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).rxLoAmpFault as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(rxLoAmpFault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).txLoAmpFault as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(txLoAmpFault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).txGainDrop as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(txGainDrop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).txPhInv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(txPhInv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).synthFault as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(synthFault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).supplyLdoFault as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(supplyLdoFault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).miscFault as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(miscFault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).miscThreshFault as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(miscThreshFault)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).reserved1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).reserved2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).reserved3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlAnaFaultInj>())).reserved4 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rlAnaFaultInj),
            "::",
            stringify!(reserved4)
        )
    );
}
pub type rlAnaFaultInj_t = rlAnaFaultInj;
extern "C" {
    #[doc = " FUNCTION DECLARATIONS"]
    #[doc = ""]
    pub fn rlRfDigMonEnableConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlMonDigEnables_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfDigMonPeriodicConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlDigMonPeriodicConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfAnaMonConfig(deviceMap: rlUInt8_t, data: *mut rlMonAnaEnables_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfTempMonConfig(deviceMap: rlUInt8_t, data: *mut rlTempMonConf_t) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfRxGainPhMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRxGainPhaseMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfRxNoiseMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRxNoiseMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfRxIfStageMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRxIfStageMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfTxPowrMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlAllTxPowMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfTxBallbreakMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlAllTxBallBreakMonCfg_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfTxGainPhaseMismatchMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlTxGainPhaseMismatchMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfTxBpmMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlAllTxBpmMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfSynthFreqMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlSynthFreqMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfExtAnaSignalsMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlExtAnaSignalsMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfTxIntAnaSignalsMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlAllTxIntAnaSignalsMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfRxIntAnaSignalsMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRxIntAnaSignalsMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfPmClkLoIntAnaSignalsMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlPmClkLoIntAnaSignalsMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfGpadcIntAnaSignalsMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlGpadcIntAnaSignalsMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfPllContrlVoltMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlPllContrVoltMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfDualClkCompMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlDualClkCompMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfRxIfSatMonConfig(deviceMap: rlUInt8_t, data: *mut rlRxSatMonConf_t)
        -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfRxSigImgMonConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlSigImgMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfRxMixerInPwrConfig(
        deviceMap: rlUInt8_t,
        data: *mut rlRxMixInPwrMonConf_t,
    ) -> rlReturnVal_t;
}
extern "C" {
    pub fn rlRfAnaFaultInjConfig(deviceMap: rlUInt8_t, data: *mut rlAnaFaultInj_t)
        -> rlReturnVal_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
